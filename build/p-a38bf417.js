import{s as e,c as t,T as n}from"./p-98455486.js";import{O as r}from"./p-2570f2bd.js";function o(){const e=new Float32Array(4);return e[3]=1,e}function i(e){const t=new Float32Array(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function c(e,t,n,r){const o=new Float32Array(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o}function s(e,t){return new Float32Array(e,t,4)}Object.freeze(Object.defineProperty({__proto__:null,clone:i,create:o,createView:s,fromValues:c},Symbol.toStringTag,{value:"Module"}));const a=!0,f={identifierOffset:0,identifierLength:10,versionOffset:10,checksumOffset:12,byteCount:16};function u(e,t,n){return{identifier:String.fromCharCode.apply(null,new Uint8Array(e,n+f.identifierOffset,f.identifierLength)),version:t.getUint16(n+f.versionOffset,a),checksum:t.getUint32(n+f.checksumOffset,a)}}const l={sizeLo:0,sizeHi:4,minX:8,minY:16,minZ:24,maxX:32,maxY:40,maxZ:48,errorX:56,errorY:64,errorZ:72,count:80,reserved:84,byteCount:88};function d(e,t){return{sizeLo:e.getUint32(t+l.sizeLo,a),sizeHi:e.getUint32(t+l.sizeHi,a),minX:e.getFloat64(t+l.minX,a),minY:e.getFloat64(t+l.minY,a),minZ:e.getFloat64(t+l.minZ,a),maxX:e.getFloat64(t+l.maxX,a),maxY:e.getFloat64(t+l.maxY,a),maxZ:e.getFloat64(t+l.maxZ,a),errorX:e.getFloat64(t+l.errorX,a),errorY:e.getFloat64(t+l.errorY,a),errorZ:e.getFloat64(t+l.errorZ,a),count:e.getUint32(t+l.count,a),reserved:e.getUint32(t+l.reserved,a)}}function w(t){const n=new DataView(t,0);let r=0;const{identifier:o,version:i}=u(t,n,r);if(r+=f.byteCount,"LEPCC     "!==o)throw new e("lepcc-decode-error","Bad identifier");if(i>1)throw new e("lepcc-decode-error","Unknown version");const c=d(n,r);r+=l.byteCount;if(c.sizeHi*2**32+c.sizeLo!==t.byteLength)throw new e("lepcc-decode-error","Bad size");const s=new Float64Array(3*c.count),a=[],w=[],p=[],h=[];if(r=y(t,r,a),r=y(t,r,w),r=y(t,r,p),r=y(t,r,h),r!==t.byteLength)throw new e("lepcc-decode-error","Bad length");let b=0,m=0;for(let e=0;e<a.length;e++){m+=a[e];let t=0;for(let n=0;n<w[e];n++){t+=p[b];const e=h[b];s[3*b]=Math.min(c.maxX,c.minX+2*c.errorX*t),s[3*b+1]=Math.min(c.maxY,c.minY+2*c.errorY*m),s[3*b+2]=Math.min(c.maxZ,c.minZ+2*c.errorZ*e),b++}}return{errorX:c.errorX,errorY:c.errorY,errorZ:c.errorZ,result:s}}function y(e,t,n){const r=[];t=p(e,t,r);const o=[];for(let i=0;i<r.length;i++){o.length=0,t=p(e,t,o);for(let e=0;e<o.length;e++)n.push(o[e]+r[i])}return t}function p(t,n,r){const o=new DataView(t,n),i=o.getUint8(0),c=31&i,s=!!(32&i),f=(192&i)>>6;let u=0;if(0===f)u=o.getUint32(1,a),n+=5;else if(1===f)u=o.getUint16(1,a),n+=3;else{if(2!==f)throw new e("lepcc-decode-error","Bad count type");u=o.getUint8(1),n+=2}if(s)throw new e("lepcc-decode-error","LUT not implemented");const l=Math.ceil(u*c/8),d=new Uint8Array(t,n,l);let w=0,y=0,p=0;const h=-1>>>32-c;for(let e=0;e<u;e++){for(;y<c;)w|=d[p]<<y,y+=8,p+=1;r[e]=w&h,w>>>=c,y-=c,y+c>32&&(w|=d[p-1]>>8-y)}return n+p}const h={sizeLo:0,sizeHi:4,count:8,colorMapCount:12,lookupMethod:14,compressionMethod:15,byteCount:16};function b(e,t){return{sizeLo:e.getUint32(t+h.sizeLo,a),sizeHi:e.getUint32(t+h.sizeHi,a),count:e.getUint32(t+h.count,a),colorMapCount:e.getUint16(t+h.colorMapCount,a),lookupMethod:e.getUint8(t+h.lookupMethod),compressionMethod:e.getUint8(t+h.compressionMethod)}}function m(t){const n=new DataView(t,0);let r=0;const{identifier:o,version:i}=u(t,n,r);if(r+=f.byteCount,"ClusterRGB"!==o)throw new e("lepcc-decode-error","Bad identifier");if(i>1)throw new e("lepcc-decode-error","Unknown version");const c=b(n,r);r+=h.byteCount;if(c.sizeHi*2**32+c.sizeLo!==t.byteLength)throw new e("lepcc-decode-error","Bad size");if((2===c.lookupMethod||1===c.lookupMethod)&&0===c.compressionMethod){if(3*c.colorMapCount+c.count+r!==t.byteLength||c.colorMapCount>256)throw new e("lepcc-decode-error","Bad count");const n=new Uint8Array(t,r,3*c.colorMapCount),o=new Uint8Array(t,r+3*c.colorMapCount,c.count),i=new Uint8Array(3*c.count);for(let e=0;e<c.count;e++){const t=o[e];i[3*e]=n[3*t],i[3*e+1]=n[3*t+1],i[3*e+2]=n[3*t+2]}return i}if(0===c.lookupMethod&&0===c.compressionMethod){if(3*c.count+r!==t.byteLength||0!==c.colorMapCount)throw new e("lepcc-decode-error","Bad count");return new Uint8Array(t,r).slice()}if(c.lookupMethod<=2&&1===c.compressionMethod){if(r+3!==t.byteLength||1!==c.colorMapCount)throw new e("lepcc-decode-error","Bad count");const o=n.getUint8(r),i=n.getUint8(r+1),s=n.getUint8(r+2),a=new Uint8Array(3*c.count);for(let e=0;e<c.count;e++)a[3*e]=o,a[3*e+1]=i,a[3*e+2]=s;return a}throw new e("lepcc-decode-error","Bad method "+c.lookupMethod+","+c.compressionMethod)}const U={sizeLo:0,sizeHi:4,count:8,scaleFactor:12,bitsPerPoint:14,reserved:15,byteCount:16};function g(e,t){return{sizeLo:e.getUint32(t+U.sizeLo,a),sizeHi:e.getUint32(t+U.sizeHi,a),count:e.getUint32(t+U.count,a),scaleFactor:e.getUint16(t+U.scaleFactor,a),bitsPerPoint:e.getUint8(t+U.bitsPerPoint),reserved:e.getUint8(t+U.reserved)}}function I(t){const n=new DataView(t,0);let r=0;const{identifier:o,version:i}=u(t,n,r);if(r+=f.byteCount,"Intensity "!==o)throw new e("lepcc-decode-error","Bad identifier");if(i>1)throw new e("lepcc-decode-error","Unknown version");const c=g(n,r);r+=U.byteCount;if(c.sizeHi*2**32+c.sizeLo!==t.byteLength)throw new e("lepcc-decode-error","Bad size");const s=new Uint16Array(c.count);if(8===c.bitsPerPoint){if(c.count+r!==t.byteLength)throw new e("lepcc-decode-error","Bad size");const n=new Uint8Array(t,r,c.count);for(let e=0;e<c.count;e++)s[e]=n[e]*c.scaleFactor}else if(16===c.bitsPerPoint){if(2*c.count+r!==t.byteLength)throw new e("lepcc-decode-error","Bad size");const n=new Uint16Array(t,r,c.count);for(let e=0;e<c.count;e++)s[e]=n[e]*c.scaleFactor}else{const n=[];if(p(t,r,n)!==t.byteLength)throw new e("lepcc-decode-error","Bad size");for(let e=0;e<c.count;e++)s[e]=n[e]*c.scaleFactor}return s}const A=t.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function v(t,n,r){let o="",i=0;for(;i<r;){const c=t[n+i];if(c<128)o+=String.fromCharCode(c),i++;else if(c>=192&&c<224){if(i+1>=r)throw new e("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");const s=(31&c)<<6|63&t[n+i+1];o+=String.fromCharCode(s),i+=2}else if(c>=224&&c<240){if(i+2>=r)throw new e("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const s=(15&c)<<12|(63&t[n+i+1])<<6|63&t[n+i+2];o+=String.fromCharCode(s),i+=3}else{if(!(c>=240&&c<248))throw new e("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(i+3>=r)throw new e("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const s=(7&c)<<18|(63&t[n+i+1])<<12|(63&t[n+i+2])<<6|63&t[n+i+3];if(s>=65536){const e=55296+(s-65536>>10),t=56320+(1023&s);o+=String.fromCharCode(e,t)}else o+=String.fromCharCode(s);i+=4}}}return o}function z(e,t){const n={byteOffset:0,byteCount:0,fields:Object.create(null)};let r=0;for(let o=0;o<t.length;o++){const i=t[o],c=i.valueType||i.type,s=x[c];n.fields[i.property]=s(e,r),r+=j[c].BYTES_PER_ELEMENT}return n.byteCount=r,n}function B(e,t,n){return D(e,t,n).map((e=>{const t=e?Date.parse(e):null;return t&&!Number.isNaN(t)?t:null}))}function D(t,n,r){const o=[];let i,c,s=0;for(c=0;c<t;c+=1){if(i=n[c],i>0){if(o.push(v(r,s,i-1)),0!==r[s+i-1])throw new e("string-array-error","Invalid string array: missing null termination.")}else o.push(null);s+=i}return o}function F(e,t){return new j[t.valueType](e,t.byteOffset,t.count*t.valuesPerElement)}function C(e,t){return new Uint8Array(e,t.byteOffset,t.byteCount)}function O(t,r,o){const i=null!=r.header?z(t,r.header):{byteOffset:0,byteCount:0,fields:{count:o}},c={header:i,byteOffset:i.byteCount,byteCount:0,entries:Object.create(null)};let s=i.byteCount;for(let t=0;t<r.ordering.length;t++){const o=r.ordering[t],a=n(r[o]);if(a.count=i.fields.count??0,"String"===a.valueType){if(a.byteOffset=s,a.byteCount=i.fields[o+"ByteCount"],"UTF-8"!==a.encoding)throw new e("unsupported-encoding","Unsupported String encoding.",{encoding:a.encoding});if(a.timeEncoding&&"ECMA_ISO8601"!==a.timeEncoding)throw new e("unsupported-time-encoding","Unsupported time encoding.",{timeEncoding:a.timeEncoding})}else{if(!k(a.valueType))throw new e("unsupported-value-type","Unsupported binary valueType",{valueType:a.valueType});{const e=L(a.valueType);s+=s%e!=0?e-s%e:0,a.byteOffset=s,a.byteCount=e*a.valuesPerElement*a.count}}s+=a.byteCount??0,c.entries[o]=a}return c.byteCount=s-c.byteOffset,c}function S(t,n,r){if(n!==t&&A.error(`Invalid ${r} buffer size\n expected: ${t}, actual: ${n})`),n<t)throw new e("buffer-too-small","Binary buffer is too small",{expectedSize:t,actualSize:n})}function M(e,t){const n=z(e,t&&t.header);let r=n.byteCount;const o={isDraco:!1,header:n,byteOffset:n.byteCount,byteCount:0,vertexAttributes:{}},i=n.fields,c=null!=i.vertexCount?i.vertexCount:i.count;for(const e of t.ordering){if(!t.vertexAttributes[e])continue;const n={...t.vertexAttributes[e],byteOffset:r,count:c},i=V[e]||"_"+e;o.vertexAttributes[i]=n,r+=L(n.valueType)*n.valuesPerElement*c}const s=i.faceCount;if(t.faces&&s){o.faces={};for(const e of t.ordering){if(!t.faces[e])continue;const n={...t.faces[e],byteOffset:r,count:s};o.faces[e]=n,r+=L(n.valueType)*n.valuesPerElement*s}}const a=i.featureCount;if(t.featureAttributes&&t.featureAttributeOrder&&a){o.featureAttributes={};for(const e of t.featureAttributeOrder){if(!t.featureAttributes[e])continue;const n={...t.featureAttributes[e],byteOffset:r,count:a};o.featureAttributes[e]=n;r+=("UInt64"===n.valueType?8:L(n.valueType))*n.valuesPerElement*a}}return S(r,e.byteLength,"geometry"),o.byteCount=r-o.byteOffset,o}const V={position:r.POSITION,normal:r.NORMAL,color:r.COLOR,uv0:r.UV0,region:r.UVREGION};function T(t,n,r){if("lepcc-rgb"===t.encoding)return m(n);if("lepcc-intensity"===t.encoding)return I(n);if(null!=t.encoding&&""!==t.encoding)throw new e("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");t["attributeByteCounts "]&&!t.attributeByteCounts&&(A.warn("Warning: Trailing space in 'attributeByteCounts '."),t.attributeByteCounts=t["attributeByteCounts "]),"ObjectIds"===t.ordering[0]&&t.hasOwnProperty("objectIds")&&(A.warn("Warning: Case error in objectIds"),t.ordering[0]="objectIds");const o=O(n,t,r);S(o.byteOffset+o.byteCount,n.byteLength,"attribute");const i=o.entries.attributeValues||o.entries.objectIds;if(i){if("String"===i.valueType){const e=o.entries.attributeByteCounts,t=F(n,e),r=C(n,i);return i.timeEncoding?B(e.count,t,r):D(e.count,t,r)}return F(n,i)}throw new e("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const j={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},x={Float32:(e,t)=>new DataView(e,0).getFloat32(t,!0),Float64:(e,t)=>new DataView(e,0).getFloat64(t,!0),UInt8:(e,t)=>new DataView(e,0).getUint8(t),Int8:(e,t)=>new DataView(e,0).getInt8(t),UInt16:(e,t)=>new DataView(e,0).getUint16(t,!0),Int16:(e,t)=>new DataView(e,0).getInt16(t,!0),UInt32:(e,t)=>new DataView(e,0).getUint32(t,!0),Int32:(e,t)=>new DataView(e,0).getInt32(t,!0)};function k(e){return j.hasOwnProperty(e)}function L(e){return k(e)?j[e].BYTES_PER_ELEMENT:0}export{T as I,w as c,o as e,F as l,i as r,M as w};
//# sourceMappingURL=p-a38bf417.js.map