import{bu as t,ct as s,eV as e,v as i,eW as n,T as r,eX as h,k as o,l as a,n as c,a2 as u,aq as l,eY as f,eZ as d,e_ as p,bM as y,aC as g,cO as m,aV as w,J as b,g as _,aS as v,cK as S,c as C,aE as E,e$ as F,f0 as j,a1 as I,ar as T,ab as O,ag as x,aT as M,f1 as R,ac as P,z as A}from"./p-98455486.js";import{m as $}from"./p-db9c2186.js";import{e as z}from"./p-c05df3c1.js";import{j as D,t as N}from"./p-ec443a8b.js";import{f as k,i as q,y as V}from"./p-8399f9e1.js";import{a as J}from"./p-da8336be.js";import{S as Z,c as H,m as U,p as B}from"./p-dfd7ee02.js";import{t as G,c as Q}from"./p-c7303555.js";import{E as L}from"./p-52d8e383.js";import{o as W}from"./p-c73bdcee.js";import"./p-073c3089.js";import"./p-c6ce33a2.js";import"./p-e6a64715.js";import"./p-f63bd4b0.js";import"./p-14843b2a.js";import"./p-ffb89da5.js";import"./p-0ea2a103.js";import"./p-623dbe5e.js";import"./p-1b4a7439.js";import"./p-0d2202fd.js";import"./p-f33b44a5.js";import"./p-f4b056c3.js";import"./p-dc29c329.js";import"./p-1172b129.js";import"./p-fe526e38.js";import"./p-9a4094ba.js";import"./p-9f1a0adc.js";function K(t=!1,s){if(t){const{elevationInfo:t,alignPointsInFeatures:e,spatialReference:i}=s;return new tt(t,e,i)}return new X}class X{async alignCandidates(t,s){return t}notifyElevationSourceChange(){}}const Y=1024;class tt{constructor(e,i,n){this._elevationInfo=e,this._alignPointsInFeatures=i,this.spatialReference=n,this._alignmentsCache=new t(Y),this._cacheVersion=0,this._metersPerVerticalUnit=s(n)}async alignCandidates(t,s){const e=this._elevationInfo;return null==e||"absolute-height"!==e.mode||e.featureExpressionInfo?this._alignComputedElevationCandidates(t,s):(this._alignAbsoluteElevationCandidates(t,e),t)}notifyElevationSourceChange(){this._alignmentsCache.clear(),this._cacheVersion++}_alignAbsoluteElevationCandidates(t,s){const{offset:e,unit:i}=s;if(null==e)return;const r=e*(n(i??"meters")/this._metersPerVerticalUnit);for(const s of t)switch(s.type){case"edge":s.start.z+=r,s.end.z+=r;continue;case"vertex":s.target.z+=r;continue}}async _alignComputedElevationCandidates(t,s){const n=new Map;for(const s of t)e(n,s.objectId,it).push(s);const[r,h,o]=this._prepareQuery(n),a=await this._alignPointsInFeatures(r,s);i(s);if(o!==this._cacheVersion)return this._alignComputedElevationCandidates(t,s);this._applyCacheAndResponse(r,a,h);const{drapedObjectIds:c,failedObjectIds:u}=a,l=[];for(const s of t){const{objectId:t}=s;c.has(t)&&"edge"===s.type&&(s.draped=!0),u.has(t)||l.push(s)}return l}_prepareQuery(t){const s=[],e=[];for(const[i,n]of t){const t=[];for(const s of n)this._addToQueriesOrCachedResult(i,s.target,t,e),"edge"===s.type&&(this._addToQueriesOrCachedResult(i,s.start,t,e),this._addToQueriesOrCachedResult(i,s.end,t,e));0!==t.length&&s.push({objectId:i,points:t})}return[s,e,this._cacheVersion]}_addToQueriesOrCachedResult(t,s,e,i){const n=et(t,s),r=this._alignmentsCache.get(n);null==r?e.push(s):i.push(new st(s,r))}_applyCacheAndResponse(t,{elevations:s,drapedObjectIds:e,failedObjectIds:i},n){for(const t of n)t.apply();let r=0;const h=this._alignmentsCache;for(const{objectId:n,points:o}of t){if(i.has(n)){r+=o.length;continue}const t=!e.has(n);for(const e of o){const i=et(n,e),o=s[r++];e.z=o,t&&h.put(i,o,1)}}}}class st{constructor(t,s){this.point=t,this.z=s}apply(){this.point.z=this.z}}function et(t,{x:s,y:e,z:i}){return`${t}-${s}-${e}-${i??0}}`}function it(){return[]}class nt{filter(t,s){return s}notifyElevationSourceChange(){}}class rt{filter(t,s){const{point:e,distance:i}=t,{z:n}=e;if(!(null!=n))return s;if(0===s.length)return s;const r=lt(i),h=this._updateCandidatesTo3D(s,e,r).filter(ht);return h.sort(ft),h}_updateCandidatesTo3D(t,s,e){for(const i of t)switch(i.type){case"edge":at(i,s,e);continue;case"vertex":ut(i,s,e);continue}return t}}function ht(t){return t.distance<=1}function ot(t=!1){return t?new rt:new nt}function at(t,s,{x:e,y:i,z:n}){const{start:r,end:h,target:o}=t;t.draped||ct(o,s,r,h);const a=(s.x-o.x)/e,c=(s.y-o.y)/i,u=(s.z-o.z)/n;t.distance=Math.sqrt(a*a+c*c+u*u)}function ct(t,s,e,i){const n=i.x-e.x,r=i.y-e.y,h=i.z-e.z,o=n*n+r*r+h*h,a=(s.x-e.x)*n+(s.y-e.y)*r+h*(s.z-e.z),c=Math.min(1,Math.max(0,a/o)),u=e.x+n*c,l=e.y+r*c,f=e.z+h*c;t.x=u,t.y=l,t.z=f}function ut(t,s,{x:e,y:i,z:n}){const{target:r}=t,h=(s.x-r.x)/e,o=(s.y-r.y)/i,a=(s.z-r.z)/n,c=Math.sqrt(h*h+o*o+a*a);t.distance=c}function lt(t){return"number"==typeof t?{x:t,y:t,z:t}:t}function ft(t,s){return t.distance-s.distance}function dt(t=!1,s){return t?new gt(s):new pt}class pt{async fetch(){return[]}notifySymbologyChange(){}}const yt=1024;class gt{constructor(s){this._getSymbologyCandidates=s,this._candidatesCache=new t(yt),this._cacheVersion=0}async fetch(t,s){if(0===t.length)return[];const e=[],n=[],h=this._candidatesCache;for(const s of t){const t=mt(s),i=h.get(t);if(i)for(const t of i)n.push(r(t));else e.push(s),h.put(t,[],1)}if(0===e.length)return n;const o=this._cacheVersion,{candidates:a,sourceCandidateIndices:c}=await this._getSymbologyCandidates(e,s);i(s);if(o!==this._cacheVersion)return this.fetch(t,s);const u=[],{length:l}=a;for(let t=0;t<l;++t){const s=a[t],i=mt(e[c[t]]),n=h.get(i);n.push(s),h.put(i,n,n.length),u.push(r(s))}return n.concat(u)}notifySymbologyChange(){this._candidatesCache.clear(),this._cacheVersion++}}function mt(t){switch(t.type){case"vertex":{const{objectId:s,target:e}=t,i=`${s}-vertex-${e.x}-${e.y}-${e.z??0}`;return h(i).toString()}case"edge":{const{objectId:s,start:e,end:i}=t,n=`${s}-edge-${e.x}-${e.y}-${e.z??0}-to-${i.x}-${i.y}-${i.z??0}`;return h(n).toString()}default:return""}}let wt=class extends u{constructor(){super(...arguments),this.updating=!1,this._pending=[]}push(t,s){this._pending.push({promise:t,callback:s}),1===this._pending.length&&this._process()}_process(){if(!this._pending.length)return void(this.updating=!1);this.updating=!0;const t=this._pending[0];t.promise.then((s=>t.callback(s))).catch((()=>{})).then((()=>{this._pending.shift(),this._process()}))}};o([a()],wt.prototype,"updating",void 0),wt=o([c("esri.core.AsyncSequence")],wt);class bt{constructor(t,s){this.data=t,this.resolution=s,this.state={type:_t.CREATED},this.alive=!0}process(t){switch(this.state.type){case _t.CREATED:return this.state=this._gotoFetchCount(this.state,t),this.state.task.promise.then(t.resume,t.resume);case _t.FETCH_COUNT:break;case _t.FETCHED_COUNT:return this.state=this._gotoFetchFeatures(this.state,t),this.state.task.promise.then(t.resume,t.resume);case _t.FETCH_FEATURES:break;case _t.FETCHED_FEATURES:this.state=this._goToDone(this.state,t)}return null}get debugInfo(){return{data:this.data,featureCount:this._featureCount,state:this._stateToString}}get _featureCount(){switch(this.state.type){case _t.CREATED:case _t.FETCH_COUNT:return 0;case _t.FETCHED_COUNT:return this.state.featureCount;case _t.FETCH_FEATURES:return this.state.previous.featureCount;case _t.FETCHED_FEATURES:return this.state.features.length;case _t.DONE:return this.state.previous.features.length}}get _stateToString(){switch(this.state.type){case _t.CREATED:return"created";case _t.FETCH_COUNT:return"fetch-count";case _t.FETCHED_COUNT:return"fetched-count";case _t.FETCH_FEATURES:return"fetch-features";case _t.FETCHED_FEATURES:return"fetched-features";case _t.DONE:return"done"}}_gotoFetchCount(t,s){return{type:_t.FETCH_COUNT,previous:t,task:l((async t=>{const e=await f(s.fetchCount(this,t));this.state.type===_t.FETCH_COUNT&&(this.state=this._gotoFetchedCount(this.state,e.ok?e.value:1/0))}))}}_gotoFetchedCount(t,s){return{type:_t.FETCHED_COUNT,featureCount:s,previous:t}}_gotoFetchFeatures(t,s){return{type:_t.FETCH_FEATURES,previous:t,task:l((async e=>{const i=await f(s.fetchFeatures(this,t.featureCount,e));this.state.type===_t.FETCH_FEATURES&&(this.state=this._gotoFetchedFeatures(this.state,i.ok?i.value:[]))}))}}_gotoFetchedFeatures(t,s){return{type:_t.FETCHED_FEATURES,previous:t,features:s}}_goToDone(t,s){return s.finish(this,t.features),{type:_t.DONE,previous:t}}reset(){const t=this.state;switch(this.state={type:_t.CREATED},t.type){case _t.CREATED:case _t.FETCHED_COUNT:case _t.FETCHED_FEATURES:case _t.DONE:break;case _t.FETCH_COUNT:case _t.FETCH_FEATURES:t.task.abort()}}intersects(t){return null==t||!this.data.extent||(d(t,vt),p(this.data.extent,vt))}}var _t;!function(t){t[t.CREATED=0]="CREATED",t[t.FETCH_COUNT=1]="FETCH_COUNT",t[t.FETCHED_COUNT=2]="FETCHED_COUNT",t[t.FETCH_FEATURES=3]="FETCH_FEATURES",t[t.FETCHED_FEATURES=4]="FETCHED_FEATURES",t[t.DONE=5]="DONE"}(_t||(_t={}));const vt=y();let St=class extends g{get _minimumVerticesPerFeature(){switch(this.store?.featureStore.geometryType){case"esriGeometryPoint":case"esriGeometryMultipoint":return 1;case"esriGeometryPolygon":return 4;case"esriGeometryPolyline":return 2}}set filter(t){const s=this._get("filter"),e=this._filterProperties(t);JSON.stringify(s)!==JSON.stringify(e)&&this._set("filter",e)}set customParameters(t){const s=this._get("customParameters");JSON.stringify(s)!==JSON.stringify(t)&&this._set("customParameters",t)}get _configuration(){return{filter:this.filter,customParameters:this.customParameters,tileInfo:this.tileInfo,tileSize:this.tileSize}}set tileInfo(t){const s=this._get("tileInfo");s!==t&&(null!=t&&null!=s&&JSON.stringify(t)===JSON.stringify(s)||(this._set("tileInfo",t),this.store.tileInfo=t))}set tileSize(t){this._get("tileSize")!==t&&this._set("tileSize",t)}get updating(){return this.updatingExcludingEdits||this._pendingEdits.updating}get updatingExcludingEdits(){return this.updatingHandles.updating}get hasZ(){return this.store.featureStore.hasZ}constructor(t){super(t),this.tilesOfInterest=[],this.availability=0,this._pendingTiles=new Map,this._pendingEdits=new wt,this._pendingEditsAbortController=new AbortController}initialize(){this._initializeFetchExtent(),this.updatingHandles.add((()=>this._configuration),(()=>this.refresh())),this.updatingHandles.add((()=>this.tilesOfInterest),((t,s)=>{m(t,s,(({id:t},{id:s})=>t===s))||this._process()}),w)}destroy(){this._pendingTiles.forEach((t=>this._deletePendingTile(t))),this._pendingTiles.clear(),this.store.destroy(),this.tilesOfInterest.length=0,this._pendingEditsAbortController.abort(),this._pendingEditsAbortController=null}refresh(){this.store.refresh(),this._pendingTiles.forEach((t=>this._deletePendingTile(t))),this._process()}applyEdits(t){this._pendingEdits.push(t,(async t=>{if(0===t.addedFeatures.length&&0===t.updatedFeatures.length&&0===t.deletedFeatures.length)return;for(const[,t]of this._pendingTiles)t.reset();const s={...t,deletedFeatures:t.deletedFeatures.map((({objectId:t,globalId:s})=>t&&-1!==t?t:this._lookupObjectIdByGlobalId(s)))};await this.updatingHandles.addPromise(this.store.processEdits(s,((t,s)=>this._queryFeaturesById(t,s)),this._pendingEditsAbortController.signal)),this._processPendingTiles()}))}_initializeFetchExtent(){if(!this.capabilities.query.supportsExtent||!b(this.url))return;const t=l((async t=>{try{const s=await Z(this.url,new _({where:"1=1",outSpatialReference:this.spatialReference,cacheHint:this.capabilities.query.supportsCacheHint??void 0}),{query:this._configuration.customParameters,signal:t});this.store.extent=v.fromJSON(s.data?.extent)}catch(t){S(t),C.getLogger(this).warn("Failed to fetch data extent",t)}}));this.updatingHandles.addPromise(t.promise.then((()=>this._process()))),this.handles.add(E((()=>t.abort())))}get debugInfo(){return{numberOfFeatures:this.store.featureStore.numFeatures,tilesOfInterest:this.tilesOfInterest,pendingTiles:Array.from(this._pendingTiles.values()).map((t=>t.debugInfo)),storedTiles:this.store.debugInfo}}_process(){this._markTilesNotAlive(),this._createPendingTiles(),this._deletePendingTiles(),this._processPendingTiles()}_markTilesNotAlive(){for(const[,t]of this._pendingTiles)t.alive=!1}_createPendingTiles(){const t=this._collectMissingTilesInfo();if(this._setAvailability(null==t?1:t.coveredArea/t.fullArea),null!=t)for(const{data:s,resolution:e}of t.missingTiles){const t=this._pendingTiles.get(s.id);t?(t.resolution=e,t.alive=!0):this._createPendingTile(s,e)}}_collectMissingTilesInfo(){let t=null;for(let s=this.tilesOfInterest.length-1;s>=0;s--){const e=this.tilesOfInterest[s],i=this.store.process(e,((t,s)=>this._verifyTileComplexity(t,s)));null==t?t=i:t.prepend(i)}return t}_deletePendingTiles(){for(const[,t]of this._pendingTiles)t.alive||this._deletePendingTile(t)}_processPendingTiles(){const t={fetchCount:(t,s)=>this._fetchCount(t,s),fetchFeatures:(t,s,e)=>this._fetchFeatures(t,s,e),finish:(t,s)=>this._finishPendingTile(t,s),resume:()=>this._processPendingTiles()};if(this._ensureFetchAllCounts(t))for(const[,s]of this._pendingTiles)this._verifyTileComplexity(this.store.getFeatureCount(s.data),s.resolution)&&this.updatingHandles.addPromise(s.process(t))}_verifyTileComplexity(t,s){return this._verifyVertexComplexity(t)&&this._verifyFeatureDensity(t,s)}_verifyVertexComplexity(t){return t*this._minimumVerticesPerFeature<Ft}_verifyFeatureDensity(t,s){if(null==this.tileInfo)return!1;const e=this.tileSize*s;return t*(jt/(e*e))<It}_ensureFetchAllCounts(t){let s=!0;for(const[,e]of this._pendingTiles)e.state.type<_t.FETCHED_COUNT&&this.updatingHandles.addPromise(e.process(t)),e.state.type<=_t.FETCH_COUNT&&(s=!1);return s}_finishPendingTile(t,s){this.store.add(t.data,s),this._deletePendingTile(t),this._updateAvailability()}_updateAvailability(){const t=this._collectMissingTilesInfo();this._setAvailability(null==t?1:t.coveredArea/t.fullArea)}_setAvailability(t){this._set("availability",t)}_createPendingTile(t,s){const e=new bt(t,s);return this._pendingTiles.set(t.id,e),e}_deletePendingTile(t){t.reset(),this._pendingTiles.delete(t.data.id)}async _fetchCount(t,s){return this.store.fetchCount(t.data,this.url,this._createCountQuery(t),{query:this.customParameters,timeout:Et,signal:s})}async _fetchFeatures(t,s,e){let i=0;const n=[];let r=0,h=s;for(;;){const o=this._createFeaturesQuery(t),a=this._setPagingParameters(o,i,h),{features:c,exceededTransferLimit:u}=await this._queryFeatures(o,e);a&&(i+=o.num),r+=c.length;for(const t of c)n.push(t);if(h=s-r,!a||!u||h<=0)return n}}_filterProperties(t){return null==t?{where:"1=1",gdbVersion:void 0,timeExtent:void 0}:{where:t.where||"1=1",timeExtent:t.timeExtent,gdbVersion:t.gdbVersion}}_lookupObjectIdByGlobalId(t){const s=this.globalIdField,e=this.objectIdField;if(null==s)throw new Error("Expected globalIdField to be defined");let i=null;if(this.store.featureStore.forEach((n=>{t===n.attributes[s]&&(i=n.objectId??n.attributes[e])})),null==i)throw new Error(`Expected to find a feature with globalId ${t}`);return i}_queryFeaturesById(t,s){const e=this._createFeaturesQuery();return e.objectIds=t,this._queryFeatures(e,s)}_queryFeatures(t,s){return this.capabilities.query.supportsFormatPBF?this._queryFeaturesPBF(t,s):this._queryFeaturesJSON(t,s)}async _queryFeaturesPBF(t,s){const{sourceSpatialReference:e}=this,{data:i}=await H(this.url,t,new J({sourceSpatialReference:e}),{query:this._configuration.customParameters,timeout:Et,signal:s});return k(i)}async _queryFeaturesJSON(t,s){const{sourceSpatialReference:e}=this,{data:i}=await U(this.url,t,e,{query:this._configuration.customParameters,timeout:Et,signal:s});return q(i,this.objectIdField)}_createCountQuery(t){const s=this._createBaseQuery(t);return this.capabilities.query.supportsCacheHint&&(s.cacheHint=!0),s}_createFeaturesQuery(t=null){const s=this._createBaseQuery(t);return s.outFields=this.globalIdField?[this.globalIdField,this.objectIdField]:[this.objectIdField],s.returnGeometry=!0,null!=t&&(this.capabilities.query.supportsResultType?s.resultType="tile":this.capabilities.query.supportsCacheHint&&(s.cacheHint=!0)),s}_createBaseQuery(t){const s=new _({returnZ:this.hasZ,returnM:!1,geometry:null!=this.tileInfo&&null!=t?F(t.data.extent,this.tileInfo.spatialReference):void 0}),e=this._configuration.filter;return null!=e&&(s.where=e.where,s.gdbVersion=e.gdbVersion,s.timeExtent=e.timeExtent),s.outSpatialReference=this.spatialReference,s}_setPagingParameters(t,s,e){if(!this.capabilities.query.supportsPagination)return!1;const{supportsMaxRecordCountFactor:i,supportsCacheHint:n,tileMaxRecordCount:r,maxRecordCount:h,supportsResultType:o}=this.capabilities.query,a=i?_.MAX_MAX_RECORD_COUNT_FACTOR:1,c=a*((o||n)&&r?r:h||Ct);return t.start=s,i?(t.maxRecordCountFactor=Math.min(a,Math.ceil(e/c)),t.num=Math.min(e,t.maxRecordCountFactor*c)):t.num=Math.min(e,c),!0}};o([a({constructOnly:!0})],St.prototype,"url",void 0),o([a({constructOnly:!0})],St.prototype,"objectIdField",void 0),o([a({constructOnly:!0})],St.prototype,"globalIdField",void 0),o([a({constructOnly:!0})],St.prototype,"capabilities",void 0),o([a({constructOnly:!0})],St.prototype,"sourceSpatialReference",void 0),o([a({constructOnly:!0})],St.prototype,"spatialReference",void 0),o([a({constructOnly:!0})],St.prototype,"store",void 0),o([a({readOnly:!0})],St.prototype,"_minimumVerticesPerFeature",null),o([a()],St.prototype,"filter",null),o([a()],St.prototype,"customParameters",null),o([a({readOnly:!0})],St.prototype,"_configuration",null),o([a()],St.prototype,"tileInfo",null),o([a()],St.prototype,"tileSize",null),o([a()],St.prototype,"tilesOfInterest",void 0),o([a({readOnly:!0})],St.prototype,"updating",null),o([a({readOnly:!0})],St.prototype,"updatingExcludingEdits",null),o([a({readOnly:!0})],St.prototype,"availability",void 0),o([a()],St.prototype,"hasZ",null),St=o([c("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")],St);const Ct=2e3,Et=6e5,Ft=1e6,jt=25,It=1;class Tt{constructor(){this._store=new Map,this._byteSize=0}set(t,s){this.delete(t),this._store.set(t,s),this._byteSize+=s.byteSize}delete(t){const s=this._store.get(t);return!!this._store.delete(t)&&(null!=s&&(this._byteSize-=s.byteSize),!0)}get(t){return this._used(t),this._store.get(t)}has(t){return this._used(t),this._store.has(t)}clear(){this._store.clear()}applyByteSizeLimit(t,s){for(const[e,i]of this._store){if(this._byteSize<=t)break;this.delete(e),s(i)}}values(){return this._store.values()}[Symbol.iterator](){return this._store[Symbol.iterator]()}_used(t){const s=this._store.get(t);s&&(this._store.delete(t),this._store.set(t,s))}}let Ot=class extends u{constructor(t){super(t),this.tileInfo=null,this.extent=null,this.maximumByteSize=10*L.MEGABYTES,this._tileBounds=new W,this._tiles=new Tt,this._refCounts=new Map,this._tileFeatureCounts=new Map,this._tmpBoundingRect=y()}add(t,s){const e=[];for(const t of s)this._referenceFeature(t.objectId)===Nt.ADDED&&e.push(t);this._addTileStorage(t,new Set(s.map((t=>t.objectId))),xt(s)),this.featureStore.addMany(e),this._tiles.applyByteSizeLimit(this.maximumByteSize,(t=>this._removeTileStorage(t)))}destroy(){this.clear(),this._tileFeatureCounts.clear()}clear(){this.featureStore.clear(),this._tileBounds.clear(),this._tiles.clear(),this._refCounts.clear()}refresh(){this.clear(),this._tileFeatureCounts.clear()}processEdits(t,s,e){return this._processEditsDelete(t.deletedFeatures.concat(t.updatedFeatures)),this._processEditsRefetch(t.addedFeatures.concat(t.updatedFeatures),s,e)}_addTileStorage(t,s,e){const i=t.id;this._tiles.set(i,new Pt(t,s,e)),this._tileBounds.set(i,t.extent),this._tileFeatureCounts.set(i,s.size)}_remove({id:t}){const s=this._tiles.get(t);s&&this._removeTileStorage(s)}_removeTileStorage(t){const s=[];for(const e of t.objectIds)this._unreferenceFeature(e)===Nt.REMOVED&&s.push(e);this.featureStore.removeManyById(s);const e=t.data.id;this._tiles.delete(e),this._tileBounds.delete(e)}_processEditsDelete(t){this.featureStore.removeManyById(t);for(const[,s]of this._tiles){for(const e of t)s.objectIds.delete(e);this._tileFeatureCounts.set(s.data.id,s.objectIds.size)}for(const s of t)this._refCounts.delete(s)}async _processEditsRefetch(t,s,e){const i=(await s(t,e)).features,{hasZ:n,hasM:r}=this.featureStore;for(const t of i){const s=V(this._tmpBoundingRect,t.geometry,n,r);null!=s&&this._tileBounds.forEachInBounds(s,(s=>{const e=this._tiles.get(s);this.featureStore.add(t);const i=t.objectId;e.objectIds.has(i)||(e.objectIds.add(i),this._referenceFeature(i),this._tileFeatureCounts.set(e.data.id,e.objectIds.size))}))}}process(t,s=(()=>!0)){if(null==this.tileInfo||!t.extent||null!=this.extent&&!p(d(this.extent,this._tmpBoundingRect),t.extent))return new $t(t);if(this._tiles.has(t.id))return new $t(t);const e=this._createTileTree(t,this.tileInfo);return this._simplify(e,s,null,0,1),this._collectMissingTiles(t,e,this.tileInfo)}get debugInfo(){return Array.from(this._tiles.values()).map((({data:t})=>({data:t,featureCount:this._tileFeatureCounts.get(t.id)||0})))}getFeatureCount(t){return this._tileFeatureCounts.get(t.id)??0}async fetchCount(t,s,e,i){const n=this._tileFeatureCounts.get(t.id);if(null!=n)return n;const r=await B(s,e,i);return this._tileFeatureCounts.set(t.id,r.data.count),r.data.count}_createTileTree(t,s){const e=new At(t.level,t.row,t.col);return s.updateTileInfo(e,D.ExtrapolateOptions.POWER_OF_TWO),this._tileBounds.forEachInBounds(t.extent,(i=>{const n=this._tiles.get(i)?.data;n&&this._tilesAreRelated(t,n)&&this._populateChildren(e,n,s,this._tileFeatureCounts.get(n.id)||0)})),e}_tilesAreRelated(t,s){if(!t||!s)return!1;if(t.level===s.level)return t.row===s.row&&t.col===s.col;const e=t.level<s.level,i=e?t:s,n=e?s:t,r=1<<n.level-i.level;return Math.floor(n.row/r)===i.row&&Math.floor(n.col/r)===i.col}_populateChildren(t,s,e,i){const n=s.level-t.level-1;if(n<0)return void(t.isLeaf=!0);const r=s.row>>n,h=s.col>>n,o=t.row<<1,a=h-(t.col<<1)+(r-o<<1),c=t.children[a];if(null!=c)this._populateChildren(c,s,e,i);else{const n=new At(t.level+1,r,h);e.updateTileInfo(n,D.ExtrapolateOptions.POWER_OF_TWO),t.children[a]=n,this._populateChildren(n,s,e,i)}}_simplify(t,s,e,i,n){const r=n*n;if(t.isLeaf)return s(this.getFeatureCount(t),n)?0:(this._remove(t),null!=e&&(e.children[i]=null),r);const h=n/2,o=h*h;let a=0;for(let e=0;e<t.children.length;e++){const i=t.children[e];a+=null!=i?this._simplify(i,s,t,e,h):o}return 0===a?this._mergeChildren(t):1-a/r<Dt&&(this._purge(t),null!=e&&(e.children[i]=null),a=r),a}_mergeChildren(t){const s=new Set;let e=0;this._forEachLeaf(t,(t=>{const i=this._tiles.get(t.id);if(i){e+=i.byteSize;for(const t of i.objectIds)s.has(t)||(s.add(t),this._referenceFeature(t));this._remove(t)}})),this._addTileStorage(t,s,e),t.isLeaf=!0,t.children[0]=t.children[1]=t.children[2]=t.children[3]=null,this._tileFeatureCounts.set(t.id,s.size)}_forEachLeaf(t,s){for(const e of t.children)null!=e&&(e.isLeaf?s(e):this._forEachLeaf(e,s))}_purge(t){if(null!=t)if(t.isLeaf)this._remove(t);else for(let s=0;s<t.children.length;s++){const e=t.children[s];this._purge(e),t.children[s]=null}}_collectMissingTiles(t,s,e){const i=new zt(e,t,this.extent);return this._collectMissingTilesRecurse(s,i,1),i.info}_collectMissingTilesRecurse(t,s,e){if(t.isLeaf)return;if(!t.hasChildren)return void s.addMissing(t.level,t.row,t.col,e);const i=e/2;for(let e=0;e<t.children.length;e++){const n=t.children[e];null==n?s.addMissing(t.level+1,(t.row<<1)+((2&e)>>1),(t.col<<1)+(1&e),i):this._collectMissingTilesRecurse(n,s,i)}}_referenceFeature(t){const s=(this._refCounts.get(t)||0)+1;return this._refCounts.set(t,s),1===s?Nt.ADDED:Nt.UNCHANGED}_unreferenceFeature(t){const s=(this._refCounts.get(t)||0)-1;return 0===s?(this._refCounts.delete(t),Nt.REMOVED):(s>0&&this._refCounts.set(t,s),Nt.UNCHANGED)}get test(){return{tiles:Array.from(this._tiles.values()).map((t=>`${t.data.id}:[${Array.from(t.objectIds)}]`)),featureReferences:Array.from(this._refCounts.keys()).map((t=>`${t}:${this._refCounts.get(t)}`))}}};function xt(t){return t.reduce(((t,s)=>t+Mt(s)),0)}function Mt(t){return 32+Rt(t.geometry)+G(t.attributes)}function Rt(t){if(null==t)return 0;const s=Q(t.lengths,4);return 32+Q(t.coords,8)+s}o([a({constructOnly:!0})],Ot.prototype,"featureStore",void 0),o([a()],Ot.prototype,"tileInfo",void 0),o([a()],Ot.prototype,"extent",void 0),o([a()],Ot.prototype,"maximumByteSize",void 0),Ot=o([c("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")],Ot);class Pt{constructor(t,s,e){this.data=t,this.objectIds=s,this.byteSize=e}}class At{constructor(t,s,e){this.level=t,this.row=s,this.col=e,this.isLeaf=!1,this.extent=null,this.children=[null,null,null,null]}get hasChildren(){return!this.isLeaf&&(null!=this.children[0]||null!=this.children[1]||null!=this.children[2]||null!=this.children[3])}}class $t{constructor(t,s=[]){this.missingTiles=s,this.fullArea=0,this.coveredArea=0,this.fullArea=j(t.extent),this.coveredArea=this.fullArea}prepend(t){this.missingTiles=t.missingTiles.concat(this.missingTiles),this.coveredArea+=t.coveredArea,this.fullArea+=t.fullArea}}class zt{constructor(t,s,e){this._tileInfo=t,this._extent=null,this.info=new $t(s),null!=e&&(this._extent=d(e))}addMissing(t,s,e,i){const n=new N(null,t,s,e);this._tileInfo.updateTileInfo(n,D.ExtrapolateOptions.POWER_OF_TWO),null==n.extent||null!=this._extent&&!p(this._extent,n.extent)||(this.info.missingTiles.push({data:n,resolution:i}),this.info.coveredArea-=j(n.extent))}}const Dt=.18751;var Nt;!function(t){t[t.ADDED=0]="ADDED",t[t.REMOVED=1]="REMOVED",t[t.UNCHANGED=2]="UNCHANGED"}(Nt||(Nt={}));let kt=class extends I.EventedAccessor{constructor(){super(...arguments),this._isInitializing=!0,this.remoteClient=null,this._whenSetup=T(),this._elevationAligner=K(),this._elevationFilter=ot(),this._symbologyCandidatesFetcher=dt(),this._handles=new O,this._updatingHandles=new x,this._editsUpdatingHandles=new x,this._pendingApplyEdits=new Map,this._alignPointsInFeatures=async(t,s)=>{const e={points:t},n=await this.remoteClient.invoke("alignElevation",e,{signal:s});return i(s),n},this._getSymbologyCandidates=async(t,s)=>{const e={candidates:t,spatialReference:this._spatialReference.toJSON()},n=await this.remoteClient.invoke("getSymbologyCandidates",e,{signal:s});return i(s),n}}get updating(){return this.updatingExcludingEdits||this._editsUpdatingHandles.updating||this._featureFetcher.updating}get updatingExcludingEdits(){return this._featureFetcher.updatingExcludingEdits||this._isInitializing||this._updatingHandles.updating}destroy(){this._featureFetcher?.destroy(),this._queryEngine?.destroy(),this._featureStore?.clear(),this._handles?.destroy()}async setup(t){if(this.destroyed)return{result:{}};const{geometryType:s,objectIdField:e,timeInfo:i,fields:n}=t.serviceInfo,{hasZ:r}=t,h=M.fromJSON(t.spatialReference);this._spatialReference=h,this._featureStore=new $({...t.serviceInfo,hasZ:r,hasM:!1}),this._queryEngine=new z({spatialReference:t.spatialReference,featureStore:this._featureStore,geometryType:s,fields:n,hasZ:r,hasM:!1,objectIdField:e,timeInfo:i}),this._featureFetcher=new St({store:new Ot({featureStore:this._featureStore}),url:t.serviceInfo.url,objectIdField:t.serviceInfo.objectIdField,globalIdField:t.serviceInfo.globalIdField,capabilities:t.serviceInfo.capabilities,spatialReference:h,sourceSpatialReference:M.fromJSON(t.serviceInfo.spatialReference)});const o="3d"===t.configuration.viewType;return this._elevationAligner=K(o,{elevationInfo:null!=t.elevationInfo?R.fromJSON(t.elevationInfo):null,alignPointsInFeatures:this._alignPointsInFeatures,spatialReference:h}),this._elevationFilter=ot(o),this._handles.add([P((()=>this._featureFetcher.availability),(t=>this.emit("notify-availability",{availability:t})),w),P((()=>this.updating),(()=>this._notifyUpdating()))]),this._whenSetup.resolve(),this._isInitializing=!1,this.configure(t.configuration)}async configure(t){return await this._updatingHandles.addPromise(this._whenSetup.promise),this._updateFeatureFetcherConfiguration(t),{result:{}}}async fetchCandidates(t,s){await this._whenSetup.promise,i(s);const e=Vt(t),n=null!=s?s.signal:null,r=await this._queryEngine.executeQueryForSnapping(e,n);i(n);const h=await this._elevationAligner.alignCandidates(r.candidates,n);i(n);const o=await this._symbologyCandidatesFetcher.fetch(h,n);i(n);const a=0===o.length?h:h.concat(o);return{result:{candidates:this._elevationFilter.filter(e,a)}}}async updateTiles(t,s){return await this._updatingHandles.addPromise(this._whenSetup.promise),i(s),this._featureFetcher.tileSize=t.tileSize,this._featureFetcher.tilesOfInterest=t.tiles,this._featureFetcher.tileInfo=null!=t.tileInfo?D.fromJSON(t.tileInfo):null,Jt}async refresh(t,s){return await this._updatingHandles.addPromise(this._whenSetup.promise),i(s),this._featureFetcher.refresh(),Jt}async whenNotUpdating(t,s){return await this._updatingHandles.addPromise(this._whenSetup.promise),i(s),await A((()=>!this.updatingExcludingEdits),s),i(s),Jt}async getDebugInfo(t,s){return i(s),{result:this._featureFetcher.debugInfo}}async beginApplyEdits(t,s){this._updatingHandles.addPromise(this._whenSetup.promise),i(s);const e=T();return this._pendingApplyEdits.set(t.id,e),this._featureFetcher.applyEdits(e.promise),this._editsUpdatingHandles.addPromise(e.promise),Jt}async endApplyEdits(t,s){const e=this._pendingApplyEdits.get(t.id);return e&&e.resolve(t.edits),i(s),Jt}async notifyElevationSourceChange(t,s){return this._elevationAligner.notifyElevationSourceChange(),Jt}async notifySymbologyChange(t,s){return this._symbologyCandidatesFetcher.notifySymbologyChange(),Jt}async setSymbologySnappingSupported(t){return this._symbologyCandidatesFetcher=dt(t,this._getSymbologyCandidates),Jt}_updateFeatureFetcherConfiguration(t){this._featureFetcher.filter=null!=t.filter?_.fromJSON(t.filter):null,this._featureFetcher.customParameters=t.customParameters}_notifyUpdating(){this.emit("notify-updating",{updating:this.updating})}};o([a({readOnly:!0})],kt.prototype,"updating",null),o([a({readOnly:!0})],kt.prototype,"updatingExcludingEdits",null),o([a()],kt.prototype,"_isInitializing",void 0),kt=o([c("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")],kt);const qt=kt;function Vt(t){return{point:t.point,mode:t.mode,distance:t.distance,returnEdge:t.returnEdge,returnVertex:t.returnVertex,query:null!=t.filter?t.filter:{where:"1=1"}}}const Jt={result:{}};export default qt;
//# sourceMappingURL=p-ab375b3e.js.map