import{i as e,aT as n,a5 as t,bW as a,b1 as i,bX as o,s as l,bY as s,bZ as r}from"./p-98455486.js";import{L as u,c as f,z as c,g as d,F as m,M as p,S as y,f as z,d as v,x as h,D as T,m as w}from"./p-0d2202fd.js";let b=null;function F(e,n,t){return e.x<0?e.x+=n:e.x>t&&(e.x-=n),e}function x(e,n,o,l){const s=a(o)?i(o):null,r=s?Math.round((s.valid[1]-s.valid[0])/n.scale[0]):null;return e.map((e=>{const a=new t(e.geometry);return u(n,a,a,a.hasZ,a.hasM),e.geometry=s?F(a,r??0,l[0]):a,e}))}function M(e,n=18,t,a,i,l){const u=new Float64Array(i*l);n=Math.round(o(n));let f=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,d=0,m=0,p=0,y=0;const z=s(a,t);for(const{geometry:t,attributes:a}of e){const{x:e,y:o}=t,s=Math.max(0,e-n),v=Math.max(0,o-n),h=Math.min(l,o+n),T=Math.min(i,e+n),w=+z(a);for(let t=v;t<h;t++)for(let a=s;a<T;a++){const l=t*i+a,s=r(a-e,t-o,n),z=u[l];d=u[l]+=s*w;const v=d-z;m+=v,p+=v*v,d<f&&(f=d),d>c&&(c=d),y++}}if(!y)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const v=(c-f)/2;return{mean:m/y,stdDev:Math.sqrt((p-m*m/y)/y),min:f,max:c,mid:v,count:y}}async function I(t,a){if(!a)return[];const{field:i,field2:o,field3:l,fieldDelimiter:s}=t,r=t.valueExpression,u=t.normalizationType,d=t.normalizationField,m=t.normalizationTotal,p=[],y=t.viewInfoParams;let z=null,v=null;if(r){if(!b){const{arcadeUtils:n}=await e();b=n}b.hasGeometryOperations(r)&&await b.enableGeometryOperations(),z=b.createFunction(r),v=y&&b.getViewInfo({viewingMode:y.viewingMode,scale:y.scale,spatialReference:new n(y.spatialReference)})}const h=t.fieldInfos,T=!(a[0]&&"declaredClass"in a[0]&&"esri.Graphic"===a[0].declaredClass)&&h?{fields:h}:null;return a.forEach((e=>{const n=e.attributes;let t;if(r){const n=T?{...e,layer:T}:e,a=b.createExecContext(n,v);t=b.executeFunction(z,a)}else n&&(t=n[i],o&&(t=`${f(t)}${s}${f(n[o])}`,l&&(t=`${t}${s}${f(n[l])}`)));if(u&&"number"==typeof t&&isFinite(t)){const e=n&&parseFloat(n[d]);t=c(t,u,e,m)}p.push(t)})),p}function V(e){const n=e.field,t=e.normalizationType,a=e.normalizationField;let i;return"field"===t?i="(NOT "+a+" = 0)":"log"!==t&&"natural-log"!==t&&"square-root"!==t||(i=`(${n} > 0)`),i}function g(e,n,t){const a=null!=n?e+" >= "+n:"",i=null!=t?e+" <= "+t:"";let o="";return o=a&&i?$(a,i):a||i,o?"("+o+")":""}function D(e,n,t,a){let i;return n?n.name!==e.objectIdField&&a.includes(n.type)||(i=new l(t,"'field' should be one of these types: "+a.join(","))):i=new l(t,"'field' is not defined in the layer schema"),i}function $(e,n){let t=null!=e?e:"";return null!=n&&n&&(t=t?"("+t+") AND ("+n+")":n),t}function N(e,n){if(e&&"intersects"!==e.spatialRelationship)return new l(n,"Only 'intersects' spatialRelationship is supported for featureFilter")}function P(e,n,t){const a=S({layer:e,fields:n});if(a.length)return new l(t,"Unknown fields: "+a.join(", ")+". You can only use fields defined in the layer schema");const i=C({layer:e,fields:n});return i.length?new l(t,"Unsupported fields: "+i.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function S(e){const n=e.layer;return e.fields.filter((e=>!n.getField(e)))}function C(e){const n=e.layer;return e.fields.filter((e=>{const t=n.getFieldUsageInfo(e);return!t||!t.supportsStatistics}))}async function E(e){const{attribute:n,features:t}=e,{normalizationType:a,normalizationField:i,minValue:o,maxValue:l,fieldType:s}=n,r=await I({field:n.field,valueExpression:n.valueExpression,normalizationType:a,normalizationField:i,normalizationTotal:n.normalizationTotal,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},t),u=w({normalizationType:a,normalizationField:i,minValue:o,maxValue:l}),f={value:.5,fieldType:s},c="esriFieldTypeString"===s?z({values:r,supportsNullCount:u,percentileParams:f}):v({values:r,minValue:o,maxValue:l,useSampleStdDev:!a,supportsNullCount:u,percentileParams:f});return d(c,"esriFieldTypeDate"===s)}async function O(e){const{attribute:n,features:t}=e,a=await I({field:n.field,field2:n.field2,field3:n.field3,fieldDelimiter:n.fieldDelimiter,valueExpression:n.valueExpression,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},t),i=h(a);return m(i,n.domains,n.returnAllCodedValues,n.fieldDelimiter)}async function U(e){const{attribute:n,features:t}=e,{field:a,normalizationType:i,normalizationField:o,normalizationTotal:l,classificationMethod:s}=n,r=await I({field:a,valueExpression:n.valueExpression,normalizationType:i,normalizationField:o,normalizationTotal:l,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},t),u=T(r,{field:a,normalizationType:i,normalizationField:o,normalizationTotal:l,classificationMethod:s,standardDeviationInterval:n.standardDeviationInterval,numClasses:n.numClasses,minValue:n.minValue,maxValue:n.maxValue});return y(u,s)}async function _(e){const{attribute:n,features:t}=e,{field:a,normalizationType:i,normalizationField:o,normalizationTotal:l,classificationMethod:s}=n,r=await I({field:a,valueExpression:n.valueExpression,normalizationType:i,normalizationField:o,normalizationTotal:l,viewInfoParams:n.viewInfoParams,fieldInfos:n.fieldInfos},t);return p(r,{field:a,normalizationType:i,normalizationField:o,normalizationTotal:l,classificationMethod:s,standardDeviationInterval:n.standardDeviationInterval,numBins:n.numBins,minValue:n.minValue,maxValue:n.maxValue})}async function j(e){const{attribute:n,features:t}=e,{field:a,radius:i,fieldOffset:o,transform:l,spatialReference:s}=n,r=n.size??[0,0],u=x(t??[],l,s,r),{count:f,min:c,max:d,mean:m,stdDev:p}=M(u,i??void 0,o,a,r[0],r[1]);return{count:f,min:c,max:d,avg:m,stddev:p}}const A=Object.freeze({__proto__:null,classBreaks:U,heatmapStatistics:j,histogram:_,summaryStatistics:E,uniqueValues:O});export{$ as F,I,P as a,N as b,_ as c,E as d,V as g,g as j,O as p,A as s,U as v,D as x,j as z};
//# sourceMappingURL=p-a9fef357.js.map