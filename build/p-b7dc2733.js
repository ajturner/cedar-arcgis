import{aT as e,r as t,aB as n,j as r,fI as a,s,fJ as o,cy as i,fK as c,aS as u,aQ as l,dJ as p,cL as y,aJ as f,q as m,fL as d}from"./p-98455486.js";import{s as w}from"./p-a8d7d0e1.js";import{n as g,o as b}from"./p-d5b10b16.js";function T(e){return h(e)??S(e)}function S(e){const t=new Date(e).getTime();return Number.isNaN(t)?null:t}function h(e){const t=x.exec(e);if(!t?.groups)return null;const n=t.groups,r=+n.year,a=+n.month-1,s=+n.day,o=+(n.hours??"0"),i=+(n.minutes??"0"),c=+(n.seconds??"0");if(o>23)return null;if(i>59)return null;if(c>59)return null;const u=n.ms??"0",l=u?+u.padEnd(3,"0").substring(0,3):0;let p;if(n.isUTC)p=Date.UTC(r,a,s,o,i,c,l);else if(n.offsetSign){const e=+n.offsetHours,t=+n.offsetMinutes;p=6e4*("+"===n.offsetSign?-1:1)*(60*e+t)+Date.UTC(r,a,s,o,i,c,l)}else p=new Date(r,a,s,o,i,c,l).getTime();return Number.isNaN(p)?null:p}const x=/^(?:(?<year>-?\d{4,})-(?<month>\d{2})-(?<day>\d{2}))(?:T(?<hours>\d{2}):(?<minutes>\d{2}):(?<seconds>\d{2})(?:\.(?<ms>\d+))?)?(?:(?<isUTC>Z)|(?:(?<offsetSign>\+|-)(?<offsetHours>\d{2}):(?<offsetMinutes>\d{2})))?$/;const F="xlink:href",E="2.0.0",k="__esri_wfs_id__",P="wfs-layer:getWFSLayerTypeInfo-error",R="wfs-layer:empty-service",v="wfs-layer:feature-type-not-found",C="wfs-layer:geojson-not-supported",N="wfs-layer:kvp-encoding-not-supported",j="wfs-layer:malformed-json",D="wfs-layer:unknown-geometry-type",$="wfs-layer:unknown-field-type",I="wfs-layer:unsupported-spatial-reference",O="wfs-layer:unsupported-wfs-version";async function M(e,t){const n=G((await r(e,{responseType:"text",query:{SERVICE:"WFS",REQUEST:"GetCapabilities",VERSION:E,...t?.customParameters},signal:t?.signal})).data);return L(e,n),n}function G(e){const t=te(e);re(t),ae(t);const n=t.firstElementChild,r=a(A(n));return{operations:V(n),get featureTypes(){return Array.from(r())},readFeatureTypes:r}}const U=new Set(["json","application/json","geojson","application/json; subtype=geojson"]);function V(e){let t=!1;const n={GetCapabilities:{url:""},DescribeFeatureType:{url:""},GetFeature:{url:"",outputFormat:null,supportsPagination:!1}};if(b(e,{OperationsMetadata:{Operation:e=>{switch(e.getAttribute("name")){case"GetCapabilities":return{DCP:{HTTP:{Get:e=>{n.GetCapabilities.url=e.getAttribute(F)}}}};case"DescribeFeatureType":return{DCP:{HTTP:{Get:e=>{n.DescribeFeatureType.url=e.getAttribute(F)}}}};case"GetFeature":return{DCP:{HTTP:{Get:e=>{n.GetFeature.url=e.getAttribute(F)}}},Parameter:e=>{if("outputFormat"===e.getAttribute("name"))return{AllowedValues:{Value:e=>{const t=e.textContent;t&&U.has(t.toLowerCase())&&(n.GetFeature.outputFormat=t)}}}}}}},Constraint:e=>{switch(e.getAttribute("name")){case"KVPEncoding":return{DefaultValue:e=>{t="true"===e.textContent.toLowerCase()}};case"ImplementsResultPaging":return{DefaultValue:e=>{n.GetFeature.supportsPagination="true"===e.textContent.toLowerCase()}}}}}}),!t)throw new s(N,"WFS service doesn't support key/value pair (KVP) encoding");if(null==n.GetFeature.outputFormat)throw new s(C,"WFS service doesn't support GeoJSON output format");return n}function L(e,t){o(e)&&(i(e,t.operations.DescribeFeatureType.url,!0)&&(t.operations.DescribeFeatureType.url=c(t.operations.DescribeFeatureType.url)),i(e,t.operations.GetFeature.url,!0)&&(t.operations.GetFeature.url=c(t.operations.GetFeature.url)))}function A(e){return g(e,{FeatureTypeList:{FeatureType:e=>{const t={typeName:"undefined:undefined",name:"",title:"",description:"",extent:null,namespacePrefix:"",namespaceUri:"",supportedSpatialReferences:[]},n=new Set([4326]),r=e=>{const t=parseInt(e.textContent?.match(/(?<wkid>\d+$)/i)?.groups?.wkid??"",10);Number.isNaN(t)||n.add(t)};return b(e,{Name:e=>{const{name:n,prefix:r}=ne(e.textContent);t.typeName=`${r}:${n}`,t.name=n,t.namespacePrefix=r,t.namespaceUri=e.lookupNamespaceURI(r)},Abstract:e=>{t.description=e.textContent},Title:e=>{t.title=e.textContent},WGS84BoundingBox:e=>{t.extent=W(e)},DefaultSRS:r,DefaultCRS:r,OtherSRS:r,OtherCRS:r}),t.title||(t.title=t.name),t.supportedSpatialReferences.push(...n),t}}})}function W(e){let t,n,r,a;for(const s of e.children)switch(s.localName){case"LowerCorner":[t,n]=s.textContent.split(" ").map((e=>Number.parseFloat(e)));break;case"UpperCorner":[r,a]=s.textContent.split(" ").map((e=>Number.parseFloat(e)))}return{xmin:t,ymin:n,xmax:r,ymax:a,spatialReference:p}}function X(e,t,r){return n(e,(e=>r?e.name===t&&e.namespaceUri===r:e.typeName===t||e.name===t))}async function q(t,n,r,a={}){const{featureType:s,extent:o}=await J(t,n,r,a),{fields:i,geometryType:c,swapXY:u,objectIdField:l,geometryField:p}=await Y(t,s.typeName,a);return{url:t.operations.GetCapabilities.url,name:s.name,namespaceUri:s.namespaceUri,fields:i,geometryField:p,geometryType:c,objectIdField:l,spatialReference:a.spatialReference??e.WGS84,extent:o,swapXY:u,wfsCapabilities:t,customParameters:a.customParameters}}async function J(t,n,r,a={}){const{spatialReference:o=e.WGS84}=a,i=t.readFeatureTypes(),c=n?X(i,n,r):i.next().value;if(null==c)throw n?new s(v,`The type '${n}' could not be found in the service`):new s(R,"The service is empty");let m=new u({...c.extent,spatialReference:o});if(!l(o,p))try{await y(p,o,void 0,a),m=f(m,p)}catch{throw new s(I,"Projection not supported")}return{extent:m,spatialReference:o,featureType:c}}async function Y(e,t,n={}){const[r,a]=await m([H(e.operations.DescribeFeatureType.url,t,n),z(e,t,n)]);if(r.error||a.error)throw new s(P,`An error occurred while getting info about the feature type '${t}'`,{error:r.error||a.error});const{fields:o,errors:i}=r.value??{},c=r.value?.geometryType||a.value?.geometryType,u=a.value?.swapXY??!1;if(null==c)throw new s(D,`The geometry type could not be determined for type '${t}`,{typeName:t,geometryType:c,fields:o,errors:i});return{..._(o??[]),geometryType:c,swapXY:u}}function _(e){const n=e.find((e=>"geometry"===e.type));let r=e.find((e=>"oid"===e.type));return e=e.filter((e=>"geometry"!==e.type)),r||(r=new t({name:k,type:"oid",alias:k}),e.unshift(r)),{geometryField:n?.name??null,objectIdField:r.name,fields:e}}async function z(e,t,n={}){let a,s=!1;const[o,i]=await Promise.all([Z(e.operations.GetFeature.url,t,e.operations.GetFeature.outputFormat,{...n,count:1}),r(e.operations.GetFeature.url,{responseType:"text",query:ee(t,void 0,{...n,count:1}),signal:n?.signal})]),c="FeatureCollection"===o.type&&o.features[0]?.geometry;if(c){let e;switch(a=d.fromJSON(w(c.type)),c.type){case"Point":e=c.coordinates;break;case"LineString":case"MultiPoint":e=c.coordinates[0];break;case"MultiLineString":case"Polygon":e=c.coordinates[0][0];break;case"MultiPolygon":e=c.coordinates[0][0][0]}const t=/<[^>]*pos[^>]*> *(-?\d+(?:\.\d+)?) (-?\d+(?:\.\d+)?)/.exec(i.data);if(t){const n=e[0].toFixed(3),r=e[1].toFixed(3),a=parseFloat(t[1]).toFixed(3);n===parseFloat(t[2]).toFixed(3)&&r===a&&(s=!0)}}return{geometryType:a,swapXY:s}}async function H(e,t,n){return Q(t,(await r(e,{responseType:"text",query:{SERVICE:"WFS",REQUEST:"DescribeFeatureType",VERSION:E,TYPENAME:t,...n?.customParameters},signal:n?.signal})).data)}function Q(e,t){const{name:r}=ne(e),a=te(t);ae(a);const o=n(g(a.firstElementChild,{element:e=>({name:e.getAttribute("name"),typeName:ne(e.getAttribute("type")).name})}),(({name:e})=>e===r));if(null!=o){const e=n(g(a.firstElementChild,{complexType:e=>e}),(e=>e.getAttribute("name")===o.typeName));if(null!=e)return K(e)}throw new s(v,`Type '${e}' not found in document`,{document:(new XMLSerializer).serializeToString(a)})}const B=new Set(["objectid","fid"]);function K(e){const n=[],r=[];let a;const o=g(e,{complexContent:{extension:{sequence:{element:e=>e}}}});for(const i of o){const o=i.getAttribute("name");if(!o)continue;let c,u;if(i.hasAttribute("type")?c=ne(i.getAttribute("type")).name:b(i,{simpleType:{restriction:e=>(c=ne(e.getAttribute("base")).name,{maxLength:e=>{u=+e.getAttribute("value")}})}}),!c)continue;const l="true"===i.getAttribute("nillable");let p=!1;switch(c.toLowerCase()){case"integer":case"nonpositiveinteger":case"negativeinteger":case"long":case"int":case"short":case"byte":case"nonnegativeinteger":case"unsignedlong":case"unsignedint":case"unsignedshort":case"unsignedbyte":case"positiveinteger":r.push(new t({name:o,alias:o,type:"integer",nullable:l}));break;case"float":case"double":case"decimal":r.push(new t({name:o,alias:o,type:"double",nullable:l}));break;case"boolean":case"string":case"gyearmonth":case"gyear":case"gmonthday":case"gday":case"gmonth":case"anyuri":case"qname":case"notation":case"normalizedstring":case"token":case"language":case"idrefs":case"entities":case"nmtoken":case"nmtokens":case"name":case"ncname":case"id":case"idref":case"entity":case"duration":case"time":r.push(new t({name:o,alias:o,type:"string",nullable:l,length:u??255}));break;case"datetime":case"date":r.push(new t({name:o,alias:o,type:"date",nullable:l,length:u??36}));break;case"pointpropertytype":a="point",p=!0;break;case"multipointpropertytype":a="multipoint",p=!0;break;case"curvepropertytype":case"multicurvepropertytype":case"multilinestringpropertytype":a="polyline",p=!0;break;case"surfacepropertytype":case"multisurfacepropertytype":case"multipolygonpropertytype":a="polygon",p=!0;break;case"geometrypropertytype":case"multigeometrypropertytype":p=!0,n.push(new s(D,`geometry type '${c}' is not supported`,{type:(new XMLSerializer).serializeToString(e)}));break;default:n.push(new s($,`Unknown field type '${c}'`,{type:(new XMLSerializer).serializeToString(e)}))}p&&r.push(new t({name:o,alias:o,type:"geometry",nullable:l}))}for(const e of r)if("integer"===e.type&&!e.nullable&&B.has(e.name.toLowerCase())){e.type="oid";break}return{geometryType:a,fields:r,errors:n}}async function Z(e,t,n,a){let{data:o}=await r(e,{responseType:"text",query:ee(t,n,a),signal:a?.signal});o=o.replaceAll(/": +(-?\d+),(\d+)(,)?/g,'": $1.$2$3');try{if(a?.dateFields?.length){const e=new Set(a.dateFields);return JSON.parse(o,((t,n)=>e.has(t)?T(n):n))}return JSON.parse(o)}catch(e){throw new s(j,"Error while parsing theÂ response",{response:o,error:e})}}function ee(e,t,n){return{SERVICE:"WFS",REQUEST:"GetFeature",VERSION:E,TYPENAMES:e,OUTPUTFORMAT:t,SRSNAME:"EPSG:4326",STARTINDEX:n?.startIndex,COUNT:n?.count,...n?.customParameters}}function te(e){return(new DOMParser).parseFromString(e.trim(),"text/xml")}function ne(e){const[t,n]=e.split(":");return{prefix:n?t:"",name:n??t}}function re(e){const t=e.firstElementChild?.getAttribute("version");if(t&&t!==E)throw new s(O,`Unsupported WFS version ${t}. Supported version: ${E}`)}function ae(e){let t="",n="";if(b(e.firstElementChild,{Exception:e=>(t=e.getAttribute("exceptionCode"),{ExceptionText:e=>{n=e.textContent}})}),t)throw new s(`wfs-layer:${t}`,n)}export{Z as H,X as M,k as S,q as V,_ as Y,M as v};
//# sourceMappingURL=p-b7dc2733.js.map