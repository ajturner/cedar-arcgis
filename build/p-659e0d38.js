import{k as t,l as i,n as s,a2 as o,bC as a,v as e,cK as n,q as r,e$ as h,bM as c,b1 as u}from"./p-98455486.js";import{j as l}from"./p-ec443a8b.js";import{T as p}from"./p-fde2045e.js";import{h as d}from"./p-f5452a6b.js";import{e as m}from"./p-8b2bb530.js";const f=Math.PI/180;function g(t){return t*f}function M(t,i){const s=g(i.rotation),o=Math.abs(Math.cos(s)),a=Math.abs(Math.sin(s)),[e,n]=i.size;return t[0]=Math.round(n*a+e*o),t[1]=Math.round(n*o+e*a),t}function v(t,i,s,o){const[a,e]=i,[n,r]=o,h=.5*s;return t[0]=a-h*n,t[1]=e-h*r,t[2]=a+h*n,t[3]=e+h*r,t}const w=c(),x=[0,0],b=new m(0,0,0,0),y={container:null,fetchSource:null,requestUpdate:null,imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let S=class extends o{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=y.hidpi,this.imageMaxWidth=y.imageMaxWidth,this.imageMaxHeight=y.imageMaxHeight,this.imageRotationSupported=y.imageRotationSupported,this.imageNormalizationSupported=y.imageNormalizationSupported,this.update=a((async(t,i)=>{if(e(i),!t.stationary||this.destroyed)return;const s=t.state,o=u(s.spatialReference),a=this.hidpi?t.pixelRatio:1,r=this.imageNormalizationSupported&&s.worldScreenWidth&&s.worldScreenWidth<s.size[0],h=this.imageMaxWidth??0,c=this.imageMaxHeight??0;r?(x[0]=s.worldScreenWidth,x[1]=s.size[1]):this.imageRotationSupported?(x[0]=s.size[0],x[1]=s.size[1]):M(x,s);const l=Math.floor(x[0]*a)>h||Math.floor(x[1]*a)>c,p=o&&(s.extent.xmin<o.valid[0]||s.extent.xmax>o.valid[1]),d=!this.imageNormalizationSupported&&p,m=!l&&!d,f=this.imageRotationSupported?s.rotation:0,g=this.container.children.slice();if(m){const t=r?s.paddedViewState.center:s.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(s,x,t,s.resolution,f,a,i)}else{let t=Math.min(h,c);d&&(t=Math.min(s.worldScreenWidth,t)),this._imagePromise=this._tiledExport(s,t,a,i)}try{const t=await this._imagePromise??[];e(i);const s=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=t;for(const i of g)t.includes(i)||s.push(i.fadeOut().then((()=>{i.remove(),i.destroy()})));for(const i of t)s.push(i.fadeIn());await Promise.all(s)}catch(t){this._imagePromise=null,n(t)}}),5e3),this.updateExports=a((async t=>{const i=[];for(const s of this.container.children){if(!s.visible||!s.stage)return;i.push(t(s).then((()=>{s.invalidateTexture(),s.requestRender()})))}this._imagePromise=r(i).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((t=>t.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}async _export(t,i,s,o,a,n){const r=await this.fetchSource(t,Math.floor(i*a),Math.floor(s*a),{rotation:o,pixelRatio:a,signal:n});e(n);const h=new p(null,!0);return h.x=t.xmin,h.y=t.ymax,h.resolution=t.width/i,h.rotation=o,h.pixelRatio=a,h.opacity=0,this.container.addChild(h),await h.setSourceAsync(r,n),e(n),h}async _singleExport(t,i,s,o,a,e,n){v(w,s,o,i);const r=h(w,t.spatialReference);return[await this._export(r,i[0],i[1],a,e,n)]}_tiledExport(t,i,s,o){const a=l.create({size:i,spatialReference:t.spatialReference,scales:[t.scale]}),e=new d(a),n=e.getTileCoverage(t);if(!n)return null;const r=[];return n.forEach(((a,n,c,u)=>{b.set(a,n,c,0),e.getTileBounds(w,b);const l=h(w,t.spatialReference);r.push(this._export(l,i,i,0,s,o).then((t=>(0!==u&&(b.set(a,n,c,u),e.getTileBounds(w,b),t.x=w[0],t.y=w[3]),t))))})),Promise.all(r)}};t([i()],S.prototype,"_imagePromise",void 0),t([i()],S.prototype,"bitmaps",void 0),t([i()],S.prototype,"container",void 0),t([i()],S.prototype,"fetchSource",void 0),t([i()],S.prototype,"hidpi",void 0),t([i()],S.prototype,"imageMaxWidth",void 0),t([i()],S.prototype,"imageMaxHeight",void 0),t([i()],S.prototype,"imageRotationSupported",void 0),t([i()],S.prototype,"imageNormalizationSupported",void 0),t([i()],S.prototype,"requestUpdate",void 0),t([i()],S.prototype,"updating",null),S=t([s("esri.views.2d.layers.support.ExportStrategy")],S);const j=S;export{j as v};
//# sourceMappingURL=p-659e0d38.js.map