import{j as t,aL as s,cF as i,f as e,bF as h,cK as n,P as r,q as o,bu as a,fS as c,da as l,a1 as f,ar as u,bM as p,L as d,ac as m,ad as y,f8 as w,f9 as g,ae as b,aQ as M,c as j,T as v,k as A,l as S,n as _}from"./p-98455486.js";import{E as T,I as x}from"./p-8a4ae095.js";import{t as D}from"./p-de65627f.js";import{G as I,D as k,F as U,O as P,I as R,R as C,E as L,C as F}from"./p-13e550f5.js";import{T as O,b as z}from"./p-7099a764.js";import{n as q}from"./p-1172b129.js";import{e as B}from"./p-a2737e04.js";import{e as N}from"./p-8b2bb530.js";import{l as $,h as V}from"./p-f5452a6b.js";import{r as K,M as H,h as W,f as G}from"./p-b8afab55.js";import{e as Q,r as E}from"./p-07f12c16.js";import{c as J,u as X}from"./p-908b7a05.js";import{e as Y,t as Z,c as tt}from"./p-42c332a2.js";import{r as st}from"./p-cc77f67d.js";import{n as it,r as et,l as ht,i as nt,a as rt}from"./p-4f76b2d1.js";import{T as ot}from"./p-7dc0ec82.js";import{i as at}from"./p-1382d09e.js";import{l as ct}from"./p-32ef36d0.js";import{f as lt,d as ft}from"./p-f7917469.js";import"./p-0c70c0e2.js";import"./p-620ed352.js";import{a as ut}from"./p-5572f01a.js";import{t as pt}from"./p-795f7c81.js";import{j as dt}from"./p-ec443a8b.js";import{y as mt}from"./p-4cbc7b66.js";import"./p-a3c11f30.js";import"./p-9a4094ba.js";import"./p-9f1a0adc.js";import"./p-0e94eaa4.js";import"./p-ed1a11ab.js";import"./p-1abe3c64.js";import"./p-220b11a0.js";import"./p-2d1dac84.js";import"./p-38e70926.js";import"./p-3a9bb31c.js";import"./p-783b6965.js";import"./p-8399f9e1.js";import"./p-e6a64715.js";import"./p-dc29c329.js";import"./p-7833a3a9.js";import"./p-6bb7b693.js";import"./p-f5f26b1f.js";import"./p-d46be2b1.js";import"./p-fc9cd10b.js";import"./p-4f27d9ab.js";import"./p-ecc7ed03.js";import"./p-c5929b55.js";import"./p-8043ab9b.js";import"./p-a9fef357.js";import"./p-0d2202fd.js";import"./p-f33b44a5.js";import"./p-e91d9d8d.js";import"./p-e22a21a4.js";import"./p-958a5da8.js";import"./p-fcbd27c0.js";import"./p-5abe9c67.js";import"./p-66f65b6a.js";import"./p-14843b2a.js";import"./p-ffb89da5.js";import"./p-dfd7ee02.js";import"./p-da8336be.js";import"./p-0fdabe4a.js";import"./p-9803a24d.js";import"./p-b15bfa44.js";import"./p-baa730bb.js";import"./p-e1758a64.js";import"./p-f4b056c3.js";import"./p-6133cc0f.js";import"./p-e75aa2b5.js";import"./p-c782b111.js";class yt{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new D(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new D;let i=null,e=-1;for(let h=0;h<this._free.length;++h){const n=this._free[h];t<=n.width&&s<=n.height&&(null===i||n.y<=i.y&&n.x<=i.x)&&(i=n,e=h)}return null===i?new D:(this._free.splice(e,1),i.width<i.height?(i.width>t&&this._free.push(new D(i.x+t,i.y,i.width-t,s)),i.height>s&&this._free.push(new D(i.x,i.y+s,i.width,i.height-s))):(i.width>t&&this._free.push(new D(i.x+t,i.y,i.width-t,i.height)),i.height>s&&this._free.push(new D(i.x,i.y+s,t,i.height-s))),new D(i.x,i.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const i=this._free[s];if(i.y===t.y&&i.height===t.height&&i.x+i.width===t.x)i.width+=t.width;else if(i.x===t.x&&i.width===t.width&&i.y+i.height===t.y)i.height+=t.height;else if(t.y===i.y&&t.height===i.height&&t.x+t.width===i.x)i.x=t.x,i.width+=t.width;else{if(t.x!==i.x||t.width!==i.width||t.y+t.height!==i.y)continue;i.y=t.y,i.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}class wt{constructor(t,s,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=i,this._binPack=new yt(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const i=[],e=this._glyphSource,h=new Set,n=1/256;for(const t of s){const s=Math.floor(t*n);h.add(s)}const r=[];return h.forEach((s=>{const i=t+s;if(this._rangePromises.has(i))r.push(this._rangePromises.get(i));else{const h=e.getRange(t,s).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,h),r.push(h)}})),Promise.all(r).then((()=>{let h=this._glyphIndex[t];h||(h={},this._glyphIndex[t]=h);for(const n of s){const s=h[n];if(s){i[n]={sdf:!0,rect:s.rect,metrics:s.metrics,page:s.page,code:n};continue}const r=e.getGlyph(t,n);if(!r||!r.metrics)continue;const o=r.metrics;let a;if(0===o.width)a=new D(0,0,0,0);else{const t=3,s=o.width+2*t,i=o.height+2*t;let e=s%4?4-s%4:4,h=i%4?4-i%4:4;1===e&&(e=5),1===h&&(h=5),a=this._binPack.allocate(s+e,i+h),a.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new yt(this.width-4,this.height-4),a=this._binPack.allocate(s+e,i+h));const n=this._glyphData[this._currentPage],c=r.bitmap;let l,f;if(c)for(let t=0;t<i;t++){l=s*t,f=this.width*(a.y+t+1)+a.x;for(let t=0;t<s;t++)n[f+t+1]=c[l+t]}}h[n]={rect:a,metrics:o,tileIDs:null,page:this._currentPage},i[n]={sdf:!0,rect:a,metrics:o,page:this._currentPage,code:n},this._dirties[this._currentPage]=!0}return i}))}removeGlyphs(t){for(const s in this._glyphIndex){const i=this._glyphIndex[s];if(!i)continue;let e;for(const s in i)if(e=i[s],e.tileIDs.delete(t),0===e.tileIDs.size){const t=this._glyphData[e.page],h=e.rect;let n,r;for(let s=0;s<h.height;s++)for(n=this.width*(h.y+s)+h.x,r=0;r<h.width;r++)t[n+r]=0;delete i[s],this._dirties[e.page]=!0}}}bind(t,s,i,e=0){if(!this._textures[i]){const s=new z;s.pixelFormat=I.ALPHA,s.wrapMode=k.CLAMP_TO_EDGE,s.width=this.width,s.height=this.height,this._textures[i]=new O(t,s,new Uint8Array(this.width*this.height))}const h=this._textures[i];h.setSamplingMode(s),this._dirties[i]&&h.setData(this._glyphData[i]),t.bindTexture(h,e),this._dirties[i]=!1}dispose(){this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}}class gt{constructor(t){if(this._metrics=[],this._bitmaps=[],t)for(;t.next();)switch(t.tag()){case 1:{const s=t.getMessage();for(;s.next();)switch(s.tag()){case 3:{const t=s.getMessage();let i,e,h,n,r,o,a;for(;t.next();)switch(t.tag()){case 1:i=t.getUInt32();break;case 2:e=t.getBytes();break;case 3:h=t.getUInt32();break;case 4:n=t.getUInt32();break;case 5:r=t.getSInt32();break;case 6:o=t.getSInt32();break;case 7:a=t.getUInt32();break;default:t.skip()}t.release(),i&&(this._metrics[i]={width:h,height:n,left:r,top:o,advance:a},this._bitmaps[i]=e);break}default:s.skip()}s.release();break}default:t.skip()}}getMetrics(t){return this._metrics[t]}getBitmap(t){return this._bitmaps[t]}}class bt{constructor(){this._ranges=[]}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}class Mt{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(s,i){const e=this._getFontStack(s);if(e.getRange(i))return Promise.resolve();const h=256*i,n=h+255;if(this._baseURL){const r=this._baseURL.replace("{fontstack}",s).replace("{range}",h+"-"+n);return t(r,{responseType:"array-buffer"}).then((t=>{e.addRange(i,new gt(new q(new Uint8Array(t.data),new DataView(t.data))))})).catch((()=>{e.addRange(i,new gt)}))}return e.addRange(i,new gt),Promise.resolve()}getGlyph(t,s){const i=this._getFontStack(t);if(!i)return;const e=Math.floor(s/256),h=i.getRange(e);return h?{metrics:h.getMetrics(s),bitmap:h.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new bt),s}}const jt="dasharray-";class vt{constructor(t,s,i=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(t<=0||s<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,i>0&&(this._maxItemSize=i),this._binPack=new yt(t-4,s-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new yt(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),s=Math.floor(this._pageHeight),i=new Uint32Array(t*s);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let i,e,h=this._mosaicRects[t];if(h)return h;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(t&&t.startsWith(jt)?([i,e]=this._rasterizeDash(t),s=!0):i=this._sprites.getSpriteInfo(t),!i||!i.width||!i.height||i.width<0||i.height<0)return null;const n=i.width,r=i.height,[o,a,c]=this._allocateImage(n,r);return o.width<=0?null:(this._copy(o,i,a,c,s,e),h={rect:o,width:n,height:r,sdf:i.sdf,simplePattern:!1,pixelRatio:i.pixelRatio,page:a},this._mosaicRects[t]=h,h)}getSpriteItems(t){const s={};for(const i of t)s[i.name]=this.getSpriteItem(i.name,i.repeat);return s}getMosaicItemPosition(t,s){const i=this.getSpriteItem(t,s),e=i&&i.rect;if(!e)return null;e.width=i.width,e.height=i.height;const h=i.width,n=i.height,r=2;return{tl:[e.x+r,e.y+r],br:[e.x+r+h,e.y+r+n],page:i.page}}bind(t,s,i=0,e=0){if(i>=this._size.length||i>=this._mosaicsData.length)return;if(!this._textures[i]){const s=new z;s.wrapMode=k.CLAMP_TO_EDGE,s.width=this._size[i][0],s.height=this._size[i][1],this._textures[i]=new O(t,s,new Uint8Array(this._mosaicsData[i].buffer))}const h=this._textures[i];h.setSamplingMode(s),this._dirties[i]&&h.setData(new Uint8Array(this._mosaicsData[i].buffer)),t.bindTexture(h,e),this._dirties[i]=!1}static _copyBits(t,s,i,e,h,n,r,o,a,c,l){let f=e*s+i,u=o*n+r;if(l){u-=n;for(let r=-1;r<=c;r++,f=((r+c)%c+e)*s+i,u+=n)for(let s=-1;s<=a;s++)h[u+s]=t[f+(s+a)%a]}else for(let i=0;i<c;i++){for(let s=0;s<a;s++)h[u+s]=t[f+s];f+=s,u+=n}}_copy(t,s,i,e,h,n){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const r=new Uint32Array(n?n.buffer:this._sprites.image.buffer),o=this._mosaicsData[i];o&&r||console.error("Source or target images are uninitialized!");const a=2,c=n?s.width:this._sprites.width;vt._copyBits(r,c,s.x,s.y,o,e[0],t.x+a,t.y+a,s.width,s.height,h),this._dirties[i]=!0}_allocateImage(t,s){t+=2,s+=2;const i=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<i){const i=new D(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[t,s]]}let e=t%4?4-t%4:4,h=s%4?4-s%4:4;1===e&&(e=5),1===h&&(h=5);const n=this._binPack.allocate(t+e,s+h);return n.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new yt(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[n,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=/\[(.*?)\]/,i=t.match(s);if(!i)return null;const e=i[1].split(",").map(Number),h=t.slice(t.lastIndexOf("-")+1),[n,r,o]=B(e,h);return[{x:0,y:0,width:r,height:o,sdf:!0,pixelRatio:1},new Uint8Array(n.buffer)]}}class At{constructor(t,s,i){this._layer=t,this._styleRepository=s,this.devicePixelRatio=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=s(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const s=this._layer.currentStyleInfo.glyphsUrl,n=new Mt(s?i(s,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new wt(1024,1024,n),this._broadcastPromise=e("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then((s=>{if(this._layer&&(this._connection?.close(),this._connection=s,this._layer&&!this._connection.closed)){const i=s.broadcast("setStyle",this._layer.currentStyleInfo.style,t);Promise.all(i).catch((t=>h(t)))}}))}_requestSprite(t){this._spriteSourceAbortController?.abort();const s=new AbortController;this._spriteSourceAbortController=s;const i=t?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,i&&(this._inputSignalEventListener=St(s),i.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:e}=s,h={...t,signal:e};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,h),this._spriteSourcePromise.then((t=>{n(e),this._spriteMosaic=new vt(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}))}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(t){const s=new vt(1024,1024,250);return s.setSpriteSource(t),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,s}async setStyle(t,s){await this._broadcastPromise,this._styleRepository=t,this._requestSprite();const e=new Mt(this._layer.currentStyleInfo.glyphsUrl?i(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new wt(1024,1024,e),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",s)),this._broadcastPromise}fetchTileData(t,s){return this._getRefKeys(t,s).then((t=>{const i=this._layer.sourceNameToSource,e=[];for(const t in i)e.push(t);return this._getSourcesData(e,t,s)}))}parseTileData(t,s){const i=t&&t.data;if(!i)return Promise.resolve(null);const{sourceName2DataAndRefKey:e,transferList:h}=i;return 0===Object.keys(e).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:e,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:h})))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,s,i){const e=N.pool.acquire(t.id),h=this._layer.sourceNameToSource[s],{level:n,row:o,col:a}=e;N.pool.release(e);try{return{protobuff:await h.requestTile(n,o,a,i),sourceName:s}}catch(t){if(r(t))throw t;return{protobuff:null,sourceName:s}}}_getRefKeys(t,s){const i=this._layer.sourceNameToSource,e=new Array;for(const h in i){const n=i[h].getRefKey(t,s);e.push(n)}return o(e)}_getSourcesData(t,s,i){const e=[];for(let h=0;h<s.length;h++)if(null==s[h].value||null==t[h])e.push(null);else{const n=this._getTilePayload(s[h].value,t[h],i);e.push(n)}return o(e).then((t=>{const i={},e=[];for(let h=0;h<t.length;h++){const n=t[h].value;if(n&&(n.protobuff&&n.protobuff.byteLength>0)){const t=s[h].value.id;i[n.sourceName]={refKey:t,protobuff:n.protobuff},e.push(n.protobuff)}}return{sourceName2DataAndRefKey:i,transferList:e}}))}}function St(t){return()=>t.abort()}const _t=512,Tt=1e-6,xt=(t,s)=>t+1/(1<<2*s);class Dt{constructor(t,s){this._tiles=new Map,this._tileCache=new a(40,(t=>t.dispose())),this._viewSize=[0,0],this._visibleTiles=new Map,this.acquireTile=t.acquireTile,this.releaseTile=t.releaseTile,this.tileInfoView=t.tileInfoView,this._container=s}destroy(){for(const[t,s]of this._tiles)s.dispose();this._tiles=null,this._tileCache.clear(),this._tileCache=null}update(t){this._updateCacheSize(t);const s=this.tileInfoView,i=s.getTileCoverage(t.state,0,!0,"smallest"),{spans:e,lodInfo:h}=i,{level:n}=h,r=this._tiles,o=new Set,a=new Set;for(const{row:t,colFrom:s,colTo:i}of e)for(let e=s;e<=i;e++){const s=N.getId(n,t,h.normalizeCol(e),h.getWorldForColumn(e)),i=this._getOrAcquireTile(s);o.add(s),i.processed()?this._addToContainer(i):a.add(new N(s))}for(const[t,s]of r)s.isCoverage=o.has(t);for(const t of a)this._findPlaceholdersForMissingTiles(t,o);let c=!1;for(const[t,e]of r)e.neededForCoverage=o.has(t),e.neededForCoverage||e.isHoldingForFade&&s.intersects(i,e.key)&&o.add(t),e.isFading&&(c=!0);for(const[t,s]of this._tiles)o.has(t)||this._releaseTile(t);return $.pool.release(i),!c}clear(){this._tiles.clear(),this._tileCache.clear(),this._visibleTiles.clear()}clearCache(){this._tileCache.clear()}_findPlaceholdersForMissingTiles(t,s){const i=[];for(const[e,h]of this._tiles)this._addPlaceholderChild(i,h,t,s);const e=i.reduce(xt,0);Math.abs(1-e)<Tt||this._addPlaceholderParent(t.id,s)}_addPlaceholderChild(t,s,i,e){s.key.level<=i.level||!s.hasData()||kt(i,s.key)&&(this._addToContainer(s),e.add(s.id),t.push(s.key.level-i.level))}_addPlaceholderParent(t,s){const i=this._tiles;let e=t;for(;;){if(e=It(e),!e||s.has(e))return;const t=i.get(e);if(t&&t.hasData())return this._addToContainer(t),void s.add(t.id)}}_getOrAcquireTile(t){let s=this._tiles.get(t);return s||(s=this._tileCache.pop(t),s||(s=this.acquireTile(new N(t))),this._tiles.set(t,s),s)}_releaseTile(t){const s=this._tiles.get(t);this.releaseTile(s),this._removeFromContainer(s),this._tiles.delete(t),s.hasData()?this._tileCache.put(t,s,1):s.dispose()}_addToContainer(t){let s;const i=[],e=this._container;if(e.contains(t))return;const h=this._visibleTiles;for(const[e,n]of h)this._canConnectDirectly(t,n)&&i.push(n),null==s&&this._canConnectDirectly(n,t)&&(s=n);if(null!=s){for(const e of i)s.childrenTiles.delete(e),t.childrenTiles.add(e),e.parentTile=t;s.childrenTiles.add(t),t.parentTile=s}else for(const s of i)t.childrenTiles.add(s),s.parentTile=t;h.set(t.id,t),e.addChild(t)}_removeFromContainer(t){if(this._visibleTiles.delete(t.id),this._container.removeChild(t),null!=t.parentTile){t.parentTile.childrenTiles.delete(t);for(const s of t.childrenTiles)null!=t.parentTile&&t.parentTile.childrenTiles.add(s)}for(const s of t.childrenTiles)s.parentTile=t.parentTile;t.parentTile=null,t.childrenTiles.clear()}_canConnectDirectly(t,s){const i=t.key;let{level:e,row:h,col:n,world:r}=s.key;const o=this._visibleTiles;for(;e>0;){if(e--,h>>=1,n>>=1,i.level===e&&i.row===h&&i.col===n&&i.world===r)return!0;if(o.has(`${e}/${h}/${n}/${r}`))return!1}return!1}_updateCacheSize(t){const s=t.state.size;if(s[0]===this._viewSize[0]&&s[1]===this._viewSize[1])return;const i=Math.ceil(s[0]/_t)+1,e=Math.ceil(s[1]/_t)+1;this._viewSize[0]=s[0],this._viewSize[1]=s[1],this._tileCache.maxSize=5*i*e}}function It(t){const[s,i,e,h]=t.split("/"),n=parseInt(s,10);return 0===n?null:`${n-1}/${parseInt(i,10)>>1}/${parseInt(e,10)>>1}/${parseInt(h,10)}`}function kt(t,s){const i=s.level-t.level;return t.row===s.row>>i&&t.col===s.col>>i&&t.world===s.world}class Ut{constructor(t){this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=t}}class Pt{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}}function Rt(t,s,i,e,h,n){const r=i-h;if(r>=0)return(s>>r)+(e-(n<<r))*(t>>r);const o=-r;return s-(n-(e<<o))*(t>>o)<<o}class Ct{constructor(t,s,i){this._rows=Math.ceil(s/i),this._columns=Math.ceil(t/i),this._cellSize=i,this.cells=new Array(this._rows);for(let t=0;t<this._rows;t++){this.cells[t]=new Array(this._columns);for(let s=0;s<this._columns;s++)this.cells[t][s]=[]}}getCell(t,s){const i=Math.min(Math.max(Math.floor(s/this._cellSize),0),this._rows-1),e=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._columns-1);return this.cells[i]&&this.cells[i][e]||null}getCellSpan(t,s,i,e){return[Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(i/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function Lt(t,s,i,e,h,n){const r=s[e++];for(let o=0;o<r;o++){const r=new Ut(n);r.xTile=s[e++],r.yTile=s[e++],r.hash=s[e++],r.priority=s[e++];const o=s[e++];for(let t=0;t<o;t++){const t=s[e++],h=s[e++],n=s[e++],o=s[e++],a=!!s[e++],c=s[e++],l=i[e++],f=i[e++],u=s[e++],p=s[e++];r.colliders.push({xTile:t,yTile:h,dxPixels:n,dyPixels:o,hard:a,partIndex:c,width:u,height:p,minLod:l,maxLod:f})}const a=t[e++];for(let s=0;s<a;s++)r.textVertexRanges.push([t[e++],t[e++]]);const c=t[e++];for(let s=0;s<c;s++)r.iconVertexRanges.push([t[e++],t[e++]]);h.push(r)}return e}function Ft(t,s,i){for(const[e,h]of t.symbols)Ot(t,s,i,h,e)}function Ot(t,s,i,e,h){const n=t.layerData.get(h);if(n.type===T.SYMBOL){for(const s of e){const e=s.unique;let h;if(s.selectedForRendering){const s=e.parts[0],n=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*n)|r<<7:r?255:0;h=o<<24|o<<16|o<<8|o}else h=0;for(const[t,i]of s.iconVertexRanges)for(let s=t;s<t+i;s+=4)n.iconOpacity[s/4]=h;if(s.selectedForRendering){const s=e.parts[1],n=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*n)|r<<7:r?255:0;h=o<<24|o<<16|o<<8|o}else h=0;for(const[t,i]of s.textVertexRanges)for(let s=t;s<t+i;s+=4)n.textOpacity[s/4]=h}n.lastOpacityUpdate=s,n.opacityChanged=!0}}class zt{constructor(t,s){this.layerUIDs=[],this.isDestroyed=!1,this._data=t;let i=1;const e=new Uint32Array(t);this.layerUIDs=[];const h=e[i++];for(let t=0;t<h;t++)this.layerUIDs[t]=e[i++];this.bufferDataOffset=i,s&&(this.layer=s.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this.isDestroyed=!0)}prepareForRendering(t){null!=this._data&&(this.doPrepareForRendering(t,this._data,this.bufferDataOffset),this._data=null)}}class qt extends zt{constructor(t,s){super(t,s),this.type=T.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.lineIndexStart=i[e++],this.lineIndexCount=i[e++];const h=i[e++];if(h>0){this.patternMap=new Map;for(let t=0;t<h;t++){const t=i[e++],s=i[e++],h=i[e++];this.patternMap.set(t,[s,h])}}this.bufferDataOffset=e}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.memoryEstimate??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=c(this.vao)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++],r=J.createVertex(t,U.STATIC_DRAW,new Int32Array(h.buffer,4*i,n));i+=n;const o=e[i++],a=J.createIndex(t,U.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=this.layer.lineMaterial;this.vao=new X(t,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:r},a)}}class Bt extends zt{constructor(t,s){super(t,s),this.type=T.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.fillIndexStart=i[e++],this.fillIndexCount=i[e++],this.outlineIndexStart=i[e++],this.outlineIndexCount=i[e++];const h=i[e++];if(h>0){this.patternMap=new Map;for(let t=0;t<h;t++){const t=i[e++],s=i[e++],h=i[e++];this.patternMap.set(t,[s,h])}}this.bufferDataOffset=e}get memoryUsed(){return(this.data?.byteLength??0)+(this.fillVAO?.memoryEstimate??0)+(this.outlineVAO?.memoryEstimate??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=c(this.fillVAO),this.outlineVAO=c(this.outlineVAO)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++],r=J.createVertex(t,U.STATIC_DRAW,new Int32Array(h.buffer,4*i,n));i+=n;const o=e[i++],a=J.createIndex(t,U.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=e[i++],l=J.createVertex(t,U.STATIC_DRAW,new Int32Array(h.buffer,4*i,c));i+=c;const f=e[i++],u=J.createIndex(t,U.STATIC_DRAW,new Uint32Array(e.buffer,4*i,f));i+=f;const p=this.layer,d=p.fillMaterial,m=p.outlineMaterial;this.fillVAO=new X(t,d.getAttributeLocations(),d.getLayoutInfo(),{geometry:r},a),this.outlineVAO=new X(t,m.getAttributeLocations(),m.getLayoutInfo(),{geometry:l},u)}}class Nt extends zt{constructor(t,s,i){super(t,s),this.type=T.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const e=new Uint32Array(t),h=new Int32Array(t),n=new Float32Array(t);let r=this.bufferDataOffset;this.isIconSDF=!!e[r++];const o=e[r++];for(let t=0;t<o;t++){const t=e[r++],s=e[r++],i=e[r++];this.iconPerPageElementsMap.set(t,[s,i])}const a=e[r++];for(let t=0;t<a;t++){const t=e[r++],s=e[r++],i=e[r++];this.glyphPerPageElementsMap.set(t,[s,i])}const c=e[r++],l=e[r++];this.iconOpacity=new Int32Array(c),this.textOpacity=new Int32Array(l),r=Lt(e,h,n,r,this.symbols,i),this.bufferDataOffset=r}get memoryUsed(){return(this.data?.byteLength??0)+(this.iconVAO?.memoryEstimate??0)+(this.textVAO?.memoryEstimate??0)+l(this.iconOpacity)+l(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let t=0;for(const[s,i]of this.iconPerPageElementsMap)t+=i[1];for(const[s,i]of this.glyphPerPageElementsMap)t+=i[1];return t/3}doDestroy(){this.iconVAO=c(this.iconVAO),this.textVAO=c(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const t=this.iconOpacity,s=this.iconVAO.vertexBuffers.opacity;t.length>0&&t.byteLength===s.byteLength&&s.setSubData(t,0,0,t.length);const i=this.textOpacity,e=this.textVAO.vertexBuffers.opacity;i.length>0&&i.byteLength===e.byteLength&&e.setSubData(i,0,0,i.length)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++],r=J.createVertex(t,U.STATIC_DRAW,new Int32Array(h.buffer,4*i,n));i+=n;const o=e[i++],a=J.createIndex(t,U.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=e[i++],l=J.createVertex(t,U.STATIC_DRAW,new Int32Array(h.buffer,4*i,c));i+=c;const f=e[i++],u=J.createIndex(t,U.STATIC_DRAW,new Uint32Array(e.buffer,4*i,f));i+=f;const p=J.createVertex(t,U.STATIC_DRAW,this.iconOpacity.buffer),d=J.createVertex(t,U.STATIC_DRAW,this.textOpacity.buffer),m=this.layer,y=m.iconMaterial,w=m.textMaterial;this.iconVAO=new X(t,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:r,opacity:p},a),this.textVAO=new X(t,w.getAttributeLocations(),w.getLayoutInfo(),{geometry:l,opacity:d},u)}}class $t extends zt{constructor(t,s){super(t,s),this.type=T.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.circleIndexStart=i[e++],this.circleIndexCount=i[e++],this.bufferDataOffset=e}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.memoryEstimate??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=c(this.vao)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++],r=J.createVertex(t,U.STATIC_DRAW,new Int32Array(h.buffer,4*i,n));i+=n;const o=e[i++],a=J.createIndex(t,U.STATIC_DRAW,new Uint32Array(e.buffer,4*i,o));i+=o;const c=this.layer.circleMaterial;this.vao=new X(t,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:r},a)}}class Vt extends st{constructor(t,s,i,e,h,n,r,o=null){super(t,s,i,e,h,n,4096,4096),this.styleRepository=r,this._memCache=o,this.type="vector-tile",this._referenced=0,this._hasSymbolBuckets=!1,this._memoryUsedByLayerData=0,this.layerData=new Map,this.layerCount=0,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.invalidating=!1,this.parentTile=null,this.childrenTiles=new Set,this._processed=!1,this._referenced=1,this.id=t.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<Y}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<Y)}get wasRequested(){return"errored"===this.status||"loaded"===this.status||"reloading"===this.status}setData(t){this.changeDataImpl(t),this.requestRender(),this.ready(),this.invalidating=!1,this._processed=!0}deleteLayerData(t){let s=!1;for(const i of t)if(this.layerData.has(i)){const t=this.layerData.get(i);this._memoryUsedByLayerData-=t.memoryUsed,t.type===T.SYMBOL&&this.symbols.has(i)&&(this.symbols.delete(i),s=!0),t.destroy(),this.layerData.delete(i),this.layerCount--}this._memCache?.updateSize(this.key.id,this,this._memoryUsedByLayerData),s&&this.emit("symbols-changed"),this.requestRender()}processed(){return this._processed}hasData(){return this.layerCount>0}dispose(){"unloaded"!==this.status&&(Kt.delete(this),Vt._destroyRenderBuckets(this.layerData),this.layerData=null,this.layerCount=0,this._memoryUsedByLayerData=0,this.destroy(),this.status="unloaded")}release(){return 0==--this._referenced&&(this.dispose(),this.stage=null,!0)}retain(){++this._referenced}get referenced(){return this._referenced}get memoryUsed(){return this._memoryUsedByLayerData+256}changeDataImpl(t){let s=!1;if(t){const{bucketsWithData:i,emptyBuckets:e}=t,h=this._createRenderBuckets(i);if(e&&e.byteLength>0){const t=new Uint32Array(e);for(const s of t)this._deleteLayerData(s)}for(const[t,i]of h)this._deleteLayerData(t),i.type===T.SYMBOL&&(this.symbols.set(t,i.symbols),s=!0),this._memoryUsedByLayerData+=i.memoryUsed,this.layerData.set(t,i),this.layerCount++;this._memCache?.updateSize(this.key.id,this,this.memoryUsed)}this._hasSymbolBuckets=!1;for(const[t,s]of this.layerData)s.type===T.SYMBOL&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed")}attachWithContext(t){this.stage={context:t,trashDisplayObject(t){t.processDetach()},untrashDisplayObject:()=>!1}}setTransform(t){super.setTransform(t);const s=this.resolution/(t.resolution*t.pixelRatio),i=this.width/this.rangeX*s,e=this.height/this.rangeY*s,h=[0,0];t.toScreen(h,[this.x,this.y]);const n=this.transforms.tileUnitsToPixels;K(n),H(n,n,h),W(n,n,Math.PI*t.rotation/180),G(n,n,[i,e,1])}_createTransforms(){return{dvs:Q(),tileMat3:Q(),tileUnitsToPixels:Q()}}static _destroyRenderBuckets(t){if(!t)return;const s=new Set;t.forEach((t=>{s.has(t)||(t.destroy(),s.add(t))})),t.clear()}_createRenderBuckets(t){const s=new Map,i=new Map;for(const e of t){const t=this._deserializeBucket(e,i);for(const i of t.layerUIDs)s.set(i,t)}return s}_deserializeBucket(t,s){let i=s.get(t);if(i)return i;switch(new Uint32Array(t)[0]){case T.FILL:i=new Bt(t,this.styleRepository);break;case T.LINE:i=new qt(t,this.styleRepository);break;case T.SYMBOL:i=new Nt(t,this.styleRepository,this);break;case T.CIRCLE:i=new $t(t,this.styleRepository)}return s.set(t,i),i}_deleteLayerData(t){if(!this.layerData.has(t))return;const s=this.layerData.get(t);this._memoryUsedByLayerData-=s.memoryUsed,s.destroy(),this.layerData.delete(t),this.layerCount--}}const Kt=new Map;function Ht(t,s,i,e,h,n){const{iconRotationAlignment:r,textRotationAlignment:o,iconTranslate:a,iconTranslateAnchor:c,textTranslate:l,textTranslateAnchor:f}=e;let u=0;for(const e of t.colliders){const[t,p]=0===e.partIndex?a:l,d=0===e.partIndex?c:f,m=e.minLod<=n&&n<=e.maxLod;u+=m?0:1,e.enabled=m,e.xScreen=e.xTile*h[0]+e.yTile*h[3]+h[6],e.yScreen=e.xTile*h[1]+e.yTile*h[4]+h[7],d===et.MAP?(e.xScreen+=i*t-s*p,e.yScreen+=s*t+i*p):(e.xScreen+=t,e.yScreen+=p),ht.VIEWPORT===(0===e.partIndex?r:o)?(e.dxScreen=e.dxPixels,e.dyScreen=e.dyPixels):(e.dxScreen=i*(e.dxPixels+e.width/2)-s*(e.dyPixels+e.height/2)-e.width/2,e.dyScreen=s*(e.dxPixels+e.width/2)+i*(e.dyPixels+e.height/2)-e.height/2)}t.colliders.length>0&&u===t.colliders.length&&(t.unique.show=!1)}class Wt{constructor(t,s,i,e,h,n){this._symbols=t,this._styleRepository=e,this._zoom=h,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new Ct(s,i,Z),this._si=Math.sin(Math.PI*n/180),this._co=Math.cos(Math.PI*n/180);for(const s of t)for(const t of s.symbols)this._allNeededMatrices.has(t.tile)||this._allNeededMatrices.set(t.tile,E(t.tile.transforms.tileUnitsToPixels))}work(t){const s=this._gridIndex;function i(t){const i=t.xScreen+t.dxScreen,e=t.yScreen+t.dyScreen,h=i+t.width,n=e+t.height,[r,o,a,c]=s.getCellSpan(i,e,h,n);for(let t=o;t<=c;t++)for(let o=r;o<=a;o++){const r=s.cells[t][o];for(const t of r){const s=t.xScreen+t.dxScreen,r=t.yScreen+t.dyScreen,o=s+t.width,a=r+t.height;if(!(h<s||i>o||n<r||e>a))return!0}}return!1}const e=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const s=this._symbols[this._currentLayerCursor],h=this._getProperties(s.styleLayerUID);for(;this._currentSymbolCursor<s.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-e>t)return!1;const n=s.symbols[this._currentSymbolCursor];if(!n.unique.show)continue;Ht(n,this._si,this._co,h,this._allNeededMatrices.get(n.tile),this._zoom);const r=n.unique;if(!r.show)continue;const{iconAllowOverlap:o,iconIgnorePlacement:a,textAllowOverlap:c,textIgnorePlacement:l}=h;for(const t of n.colliders){if(!t.enabled)continue;const s=r.parts[t.partIndex];if(!s.show)continue;!(t.partIndex?c:o)&&i(t)&&(t.hard?r.show=!1:s.show=!1)}if(r.show)for(const t of n.colliders){if(!t.enabled)continue;if(t.partIndex?l:a)continue;if(!r.parts[t.partIndex].show)continue;const s=t.xScreen+t.dxScreen,i=t.yScreen+t.dyScreen,e=s+t.width,h=i+t.height,[n,o,c,f]=this._gridIndex.getCellSpan(s,i,e,h);for(let s=o;s<=f;s++)for(let i=n;i<=c;i++){this._gridIndex.cells[s][i].push(t)}}}}return!0}_getProperties(t){const s=this._styleProps.get(t);if(s)return s;const i=this._zoom,e=this._styleRepository.getStyleLayerByUID(t),h=e.getLayoutValue("symbol-placement",i)!==it.POINT;let n=e.getLayoutValue("icon-rotation-alignment",i);n===ht.AUTO&&(n=h?ht.MAP:ht.VIEWPORT);let r=e.getLayoutValue("text-rotation-alignment",i);r===ht.AUTO&&(r=h?ht.MAP:ht.VIEWPORT);const o=e.getPaintValue("icon-translate",i),a=e.getPaintValue("icon-translate-anchor",i),c=e.getPaintValue("text-translate",i),l=e.getPaintValue("text-translate-anchor",i),f={iconAllowOverlap:e.getLayoutValue("icon-allow-overlap",i),iconIgnorePlacement:e.getLayoutValue("icon-ignore-placement",i),textAllowOverlap:e.getLayoutValue("text-allow-overlap",i),textIgnorePlacement:e.getLayoutValue("text-ignore-placement",i),iconRotationAlignment:n,textRotationAlignment:r,iconTranslateAnchor:a,iconTranslate:o,textTranslateAnchor:l,textTranslate:c};return this._styleProps.set(t,f),f}}function Gt(t,s){if(t.priority-s.priority)return t.priority-s.priority;const i=t.tile.key,e=s.tile.key;return i.world-e.world?i.world-e.world:i.level-e.level?i.level-e.level:i.row-e.row?i.row-e.row:i.col-e.col?i.col-e.col:t.xTile-s.xTile?t.xTile-s.xTile:t.yTile-s.yTile}class Qt{get running(){return this._running}constructor(t,s,i,e,h,n){this._visibleTiles=t,this._symbolRepository=s,this._createCollisionJob=i,this._assignTileSymbolsOpacity=e,this._symbolLayerSorter=h,this._isLayerVisible=n,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(t,s){this._screenWidth===t&&this._screenHeight===s||this.restart(),this._screenWidth=t,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(t){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(t))return!1;if(this._selectionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(t))return!1;if(this._collisionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(t))return!1;if(this._opacityJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}return this._running=!1,!0}_createSelectionJob(){const t=this._symbolRepository.uniqueSymbols;for(let s=0;s<t.length;s++){const i=t[s];for(let t=0;t<i.uniqueSymbols.length;t++){const s=i.uniqueSymbols[t];for(const t of s.tileSymbols)t.selectedForRendering=!1}}const s=[];let i=0,e=0;const h=this._isLayerVisible;function n(n){let r;const o=performance.now();for(;e<t.length;e++,i=0){const a=t[e],c=a.styleLayerUID;if(!h(c)){s[e]||(s[e]={styleLayerUID:c,symbols:[]});continue}s[e]=s[e]||{styleLayerUID:c,symbols:[]};const l=s[e];for(;i<a.uniqueSymbols.length;i++){if(r=a.uniqueSymbols[i],i%100==99&&performance.now()-o>n)return!1;let t=null,s=!1,e=!1;for(const i of r.tileSymbols)if(!e||!s){const h=i.tile;(!t||h.isCoverage||h.neededForCoverage&&!s)&&(t=i,(h.neededForCoverage||h.isCoverage)&&(e=!0),h.isCoverage&&(s=!0))}if(t.selectedForRendering=!0,e){l.symbols.push(t),r.show=!0;for(const t of r.parts)t.show=!0}else r.show=!1}}for(const t of s)t.symbols.sort(Gt);return!0}const r=this._symbolLayerSorter;return{work:n,get sortedSymbols(){return s.sort(r)}}}_createOpacityJob(){const t=this._assignTileSymbolsOpacity,s=this._visibleTiles;let i=0;function e(s,i){const h=s.symbols;for(const[t,s]of h)Et(s,i);t(s,i);for(const t of s.childrenTiles)e(t,i)}return{work(t){const h=performance.now();for(;i<s.length;i++){if(performance.now()-h>t)return!1;const n=s[i];if(null!=n.parentTile)continue;e(n,performance.now())}return!0}}}}function Et(t,s){for(const i of t){const t=i.unique;for(const i of t.parts){const e=i.targetOpacity>.5?1:-1;i.startOpacity+=e*((s-i.startTime)/Y),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=s,i.targetOpacity=t.show&&i.show?1:0}}}const Jt=32,Xt=8,Yt=64;class Zt{constructor(t,s,i){this.tileCoordRange=t,this._visibleTiles=s,this._createUnique=i,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return null==this._uniqueSymbolLayerArray&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(t,s){this._uniqueSymbolLayerArray=null;let i=this._tiles.get(t.id);i||(i={symbols:new Map},this._tiles.set(t.id,i));const e=new Map;if(s)for(const t of s)i.symbols.has(t)&&(e.set(t,i.symbols.get(t)),i.symbols.delete(t));else for(const[s,h]of t.layerData)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e);const h=t.symbols,n=new Map;for(const[t,s]of h){let e=s.length;if(e>=Jt){let h=this.tileCoordRange;do{h/=2,e/=4}while(e>Xt&&h>Yt);const r=new Ct(this.tileCoordRange,this.tileCoordRange,h);n.set(t,{flat:s,index:r}),i.symbols.set(t,{flat:s,index:r});for(const t of s)r.getCell(t.xTile,t.yTile).push(t)}else n.set(t,{flat:s}),i.symbols.set(t,{flat:s})}this._addSymbols(t.key,h)}deleteStyleLayers(t){this._uniqueSymbolLayerArray=null;for(const[s,i]of this._tiles){const e=new Map;for(const s of t)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e),0===i.symbols.size&&this._tiles.delete(s)}}removeTile(t){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(t.id);if(!s)return;const i=new Map;for(const[e,h]of t.symbols)s.symbols.has(e)&&(i.set(e,s.symbols.get(e)),s.symbols.delete(e));this._removeSymbols(i),0===s.symbols.size&&this._tiles.delete(t.id)}_removeSymbols(t){for(const[s,{flat:i}]of t)for(const t of i){const i=t.unique,e=i.tileSymbols,h=e.length-1;for(let s=0;s<h;s++)if(e[s]===t){e[s]=e[h];break}if(e.length=h,0===h){const t=this._uniqueSymbolsReferences.get(s);t.delete(i),0===t.size&&this._uniqueSymbolsReferences.delete(s)}t.unique=null}}_addSymbols(t,s){if(0===s.size)return;const i=this._visibleTiles;for(const e of i)e.parentTile||e.key.world!==t.world||e.key.level===t.level&&!e.key.equals(t)||this._matchSymbols(e,t,s);for(const[t,i]of s)for(const s of i)if(null==s.unique){const i=this._createUnique();s.unique=i,i.tileSymbols.push(s);let e=this._uniqueSymbolsReferences.get(t);e||(e=new Set,this._uniqueSymbolsReferences.set(t,e)),e.add(i)}}_matchSymbols(t,s,i){if(t.key.level>s.level){const i=t.key.level-s.level;if(t.key.row>>i!==s.row||t.key.col>>i!==s.col)return}if(s.level>t.key.level){const i=s.level-t.key.level;if(s.row>>i!==t.key.row||s.col>>i!==t.key.col)return}if(s.equals(t.key)){for(const e of t.childrenTiles)this._matchSymbols(e,s,i);return}const e=new Map;for(const[h,n]of i){const i=[];for(const e of n){const h=Rt(this.tileCoordRange,e.xTile,s.level,s.col,t.key.level,t.key.col),n=Rt(this.tileCoordRange,e.yTile,s.level,s.row,t.key.level,t.key.row);h>=0&&h<this.tileCoordRange&&n>=0&&n<this.tileCoordRange&&i.push({symbol:e,xTransformed:h,yTransformed:n})}const r=[],o=t.key.level<s.level?1:1<<t.key.level-s.level,a=this._tiles.get(t.id).symbols.get(h);if(a){const t=a.flat;for(const s of i){let i,e=!1;const h=s.xTransformed,n=s.yTransformed;i=null!=a.index?a.index.getCell(h,n):t;const c=s.symbol,l=c.hash;for(const t of i)if(l===t.hash&&Math.abs(h-t.xTile)<=o&&Math.abs(n-t.yTile)<=o){const s=t.unique;c.unique=s,s.tileSymbols.push(c),e=!0;break}e||r.push(c)}}r.length>0&&e.set(h,r)}for(const i of t.childrenTiles)this._matchSymbols(i,s,e)}_createUniqueSymbolLayerArray(){const t=this._uniqueSymbolsReferences,s=new Array(t.size);let i,e=0;for(const[h,n]of t){const t=new Array(n.size);i=0;for(const s of n)t[i++]=s;s[e]={styleLayerUID:h,uniqueSymbols:t},e++}return s}}const ts=.5,ss=1e-6;class is extends f{constructor(t,s){super(),this.styleRepository=t,this._tileToHandle=new Map,this._viewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._declutterViewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._completed=!1,this._symbolRepository=new Zt(4096,s,(()=>new Pt)),this._symbolDeclutterer=new Qt(s,this._symbolRepository,((t,s,i)=>new Wt(t,s,i,this.styleRepository,this._zoom,this._viewState.rotation)),((t,s)=>{t.allSymbolsFadingOut=!0,t.lastOpacityUpdate=s,Ft(t,s,!0),t.decluttered=!0,t.requestRender()}),((t,s)=>this.styleRepository.getStyleLayerByUID(t.styleLayerUID).z-this.styleRepository.getStyleLayerByUID(s.styleLayerUID).z),(t=>{const s=this.styleRepository.getStyleLayerByUID(t);if(this._zoom+ss<s.minzoom||this._zoom-ss>=s.maxzoom)return!1;const i=s.getLayoutProperty("visibility");return!i||i.getValue()!==nt.NONE}))}addTile(t){t.decluttered=!1,this._tileToHandle.set(t,t.on("symbols-changed",(()=>{this._symbolRepository.add(t),this.restartDeclutter()}))),this._symbolRepository.add(t),this.restartDeclutter()}removeTile(t){const s=this._tileToHandle.get(t);s&&(this._symbolRepository.removeTile(t),this.restartDeclutter(),s.remove(),this._tileToHandle.delete(t))}update(t,s){return this._zoom=t,this._viewState={scale:s.scale,rotation:s.rotation,center:[s.center[0],s.center[1]],size:[s.size[0],s.size[1]]},this._continueDeclutter(),this._completed}restartDeclutter(){this._completed=!1,this._symbolDeclutterer.restart(),this._notifyUnstable()}clear(){this._completed=!1,this._symbolRepository=null,this._symbolDeclutterer.restart(),this._tileToHandle.forEach((t=>t.remove())),this._tileToHandle.clear()}get stale(){return this._zoom!==this._declutterZoom||this._viewState.size[0]!==this._declutterViewState.size[0]||this._viewState.size[1]!==this._declutterViewState.size[1]||this._viewState.scale!==this._declutterViewState.scale||this._viewState.rotation!==this._declutterViewState.rotation}deleteStyleLayers(t){this._symbolRepository.deleteStyleLayers(t)}_continueDeclutter(){this._completed&&!this.stale||(this._symbolDeclutterer.running||(this._declutterZoom=this._zoom,this._declutterViewState.center[0]=this._viewState.center[0],this._declutterViewState.center[1]=this._viewState.center[1],this._declutterViewState.rotation=this._viewState.rotation,this._declutterViewState.scale=this._viewState.scale,this._declutterViewState.size[0]=this._viewState.size[0],this._declutterViewState.size[1]=this._viewState.size[1],this._symbolDeclutterer.restart()),this._symbolDeclutterer.setScreenSize(this._viewState.size[0],this._viewState.size[1]),this._completed=this._symbolDeclutterer.continue(tt),this._completed&&this._scheduleNotifyStable())}_scheduleNotifyStable(){null!=this._stableNotificationHandle&&clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=setTimeout((()=>{this._stableNotificationHandle=null,this.emit("fade-complete")}),(1+ts)*Y)}_notifyUnstable(){null!=this._stableNotificationHandle&&(clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=null),this.emit("fade-start")}}class es extends st{_createTransforms(){return{dvs:Q(),tileMat3:Q()}}}const hs=1e-6;function ns(t,s){if(t){const i=t.getLayoutProperty("visibility");if(!i||i.getValue()!==nt.NONE&&(void 0===t.minzoom||t.minzoom<s+hs)&&(void 0===t.maxzoom||t.maxzoom>=s-hs))return!0}return!1}class rs extends at{constructor(t){super(t),this._backgroundTiles=[],this._pointToCallbacks=new Map}destroy(){this.removeAllChildren(),this._spriteMosaic?.dispose(),this._spriteMosaic=null,this._glyphMosaic?.dispose(),this._glyphMosaic=null,null!=this._symbolFader&&(this._symbolFader.clear(),this._symbolFader=null),this._styleRepository=null,this._backgroundTiles=[],this._pointToCallbacks.clear()}setStyleResources(t,s,i){if(this._spriteMosaic=t,this._glyphMosaic=s,this._styleRepository=i,null==this._symbolFader){const t=new is(this._styleRepository,this.children);t.on("fade-start",(()=>{this.emit("fade-start"),this.requestRender()})),t.on("fade-complete",(()=>{this.emit("fade-complete"),this.requestRender()})),this._symbolFader=t}this._symbolFader.styleRepository=i}setSpriteMosaic(t){this._spriteMosaic?.dispose(),this._spriteMosaic=t}deleteStyleLayers(t){null!=this._symbolFader&&this._symbolFader.deleteStyleLayers(t)}async hitTest(t){const s=u();return this._pointToCallbacks.set(t,s),this.requestRender(),s.promise}enterTileInvalidation(){for(const t of this.children)t.invalidating=!0}createRenderParams(t){return{...super.createRenderParams(t),renderPass:null,styleLayer:null,styleLayerUID:-1,glyphMosaic:this._glyphMosaic,spriteMosaic:this._spriteMosaic,hasClipping:!!this._clippingInfos}}doRender(t){!this.visible||t.drawPhase!==ot.MAP&&t.drawPhase!==ot.DEBUG||void 0===this._spriteMosaic||super.doRender(t)}addChild(t){return super.addChild(t),null!=this._symbolFader?this._symbolFader.addTile(t):t.decluttered=!0,this.requestRender(),t}removeChild(t){return null!=this._symbolFader&&this._symbolFader.removeTile(t),this.requestRender(),super.removeChild(t)}renderChildren(t){const{drawPhase:s}=t;if(s!==ot.DEBUG){if(this._doRender(t),this._pointToCallbacks.size>0){t.drawPhase=ot.HITTEST;const i=t.painter.effects.hittestVTL;i.bind(t),this._doRender(t),i.draw(t,this._pointToCallbacks),i.unbind(t),t.drawPhase=s}}else super.renderChildren(t)}removeAllChildren(){for(let t=0;t<this.children.length;t++){const s=this.children[t];null!=this._symbolFader&&this._symbolFader.removeTile(s),s.dispose()}super.removeAllChildren()}getStencilTarget(){return this.children.filter((t=>t.neededForCoverage&&t.hasData()))}restartDeclutter(){null!=this._symbolFader&&this._symbolFader.restartDeclutter()}_doRender(t){const{context:s}=t,i=this._styleRepository;if(!i)return;const e=i.layers;let h=!0;t.drawPhase===ot.HITTEST&&(h=!1),i.backgroundBucketIds.length>0&&(t.renderPass="background",this._renderBackgroundLayers(t,i.backgroundBucketIds)),super.renderChildren(t),t.drawPhase===ot.MAP&&this._fade(t.displayLevel,t.state);const n=this.children.filter((t=>t.visible&&t.hasData()));if(!n||0===n.length)return s.bindVAO(),s.setStencilTestEnabled(!0),void s.setBlendingEnabled(!0);for(const t of n)t.triangleCount=0;s.setStencilWriteMask(0),s.setColorMask(!0,!0,!0,!0),s.setStencilOp(P.KEEP,P.KEEP,P.REPLACE),s.setStencilTestEnabled(!0),s.setBlendingEnabled(!1),s.setDepthTestEnabled(!0),s.setDepthWriteEnabled(!0),s.setDepthFunction(R.LEQUAL),s.setClearDepth(1),s.clear(s.gl.DEPTH_BUFFER_BIT),t.renderPass="opaque";for(let s=e.length-1;s>=0;s--)this._renderStyleLayer(e[s],t,n);s.setDepthWriteEnabled(!1),s.setBlendingEnabled(h),s.setBlendFunctionSeparate(C.ONE,C.ONE_MINUS_SRC_ALPHA,C.ONE,C.ONE_MINUS_SRC_ALPHA),t.renderPass="translucent";for(let s=0;s<e.length;s++)this._renderStyleLayer(e[s],t,n);s.bindVAO(),s.setStencilTestEnabled(!0),s.setBlendingEnabled(!0)}_fade(t,s){null!=this._symbolFader&&(this._symbolFader.update(t,s)||this.requestRender())}_renderStyleLayer(t,s,i){const{painter:e,renderPass:h}=s;if(void 0===t)return;const n=t.getLayoutProperty("visibility");if(n&&n.getValue()===nt.NONE)return;let r;switch(t.type){case rt.BACKGROUND:return;case rt.FILL:if("opaque"!==h&&"translucent"!==s.renderPass)return;r="vtlFill";break;case rt.LINE:if("translucent"!==h)return;r="vtlLine";break;case rt.CIRCLE:if("translucent"!==h)return;r="vtlCircle";break;case rt.SYMBOL:if("translucent"!==h)return;r="vtlSymbol"}if(i=t.type===rt.SYMBOL?i.filter((t=>t.decluttered)):i.filter((t=>t.neededForCoverage)),"vtlSymbol"!==r){const e=s.displayLevel;if(0===i.length||void 0!==t.minzoom&&t.minzoom>=e+hs||void 0!==t.maxzoom&&t.maxzoom<e-hs)return}const o=t.uid;s.styleLayerUID=o,s.styleLayer=t;for(const t of i)if(t.layerData.has(o)){e.renderObjects(s,i,r);break}}_renderBackgroundLayers(t,s){const{context:i,displayLevel:e,painter:h,state:n}=t,r=this._styleRepository;let o=!1;for(const t of s){if(r.getLayerById(t).type===rt.BACKGROUND&&ns(r.getLayerById(t),e)){o=!0;break}}if(!o)return;const a=this._tileInfoView.getTileCoverage(t.state,0,!0,"smallest"),{spans:c,lodInfo:l}=a,{level:f}=l,u=p(),d=[];if(this._renderPasses){const s=this._renderPasses[0];null!=this._clippingInfos&&(s.brushes[0].prepareState(t),s.brushes[0].drawMany(t,this._clippingInfos))}const m=this._backgroundTiles;let y,w=0;for(const{row:t,colFrom:s,colTo:i}of c)for(let e=s;e<=i;e++){if(w<m.length)y=m[w],y.key.set(f,t,l.normalizeCol(e),l.getWorldForColumn(e)),this._tileInfoView.getTileBounds(u,y.key,!1),y.x=u[0],y.y=u[3],y.resolution=this._tileInfoView.getTileResolution(f);else{const s=new N(f,t,l.normalizeCol(e),l.getWorldForColumn(e)),i=this._tileInfoView.getTileBounds(p(),s),h=this._tileInfoView.getTileResolution(f);y=new es(s,h,i[0],i[3],512,512,4096,4096),m.push(y)}y.setTransform(n),d.push(y),w++}i.setStencilWriteMask(0),i.setColorMask(!0,!0,!0,!0),i.setStencilOp(P.KEEP,P.KEEP,P.REPLACE),i.setStencilFunction(R.EQUAL,0,255);let g=!0;t.drawPhase===ot.HITTEST&&(g=!1),i.setStencilTestEnabled(g);for(const i of s){const s=r.getLayerById(i);s.type===rt.BACKGROUND&&ns(s,e)&&(t.styleLayerUID=s.uid,t.styleLayer=s,h.renderObjects(t,d,"vtlBackground"))}$.pool.release(a)}}const os={geometry:[new pt("a_PositionAndFlags",3,F.SHORT,0,6)]},as=new Map;as.set("a_PositionAndFlags",0);const cs={vsPath:"debug/overlay",fsPath:"debug/overlay",attributes:as};class ls extends ut{constructor(t){super(),this._conf=t}static makeFlags(t,s){return t|s<<2}_createTransforms(){return{dvs:Q()}}doRender(t){this._updateTransforms(t),this._ensureResources(t);const{context:s}=t;s.useProgram(this._program),this._program.setUniformMatrix3fv("u_dvsMat3",this.transforms.dvs),this._program.setUniform4fv("u_colors",this._conf.getColors(t)),this._program.setUniform1fv("u_opacities",this._conf.getOpacities(t));const{vertexData:i,indexData:e}=this._conf.getMesh(t);this._vertexBuffer.setData(i),this._indexBuffer.setData(e),s.bindVAO(this._vertexArray),s.setBlendingEnabled(!0),s.setBlendFunction(C.ONE,C.ONE_MINUS_SRC_ALPHA),s.setDepthTestEnabled(!1),s.setStencilTestEnabled(!1),s.setColorMask(!0,!0,!0,!0),s.drawElements(L.TRIANGLES,e.length,F.UNSIGNED_INT,0)}onDetach(){this._vertexArray=c(this._vertexArray)}_updateTransforms(t){K(this.transforms.dvs),H(this.transforms.dvs,this.transforms.dvs,[-1,1]),G(this.transforms.dvs,this.transforms.dvs,[2/t.state.size[0],-2/t.state.size[1],1])}_ensureResources(t){const{context:s}=t;this._program||(this._program=t.painter.materialManager.getProgram(cs)),this._vertexBuffer||(this._vertexBuffer=J.createVertex(s,U.STREAM_DRAW)),this._indexBuffer||(this._indexBuffer=J.createIndex(s,U.STREAM_DRAW)),this._vertexArray||(this._vertexArray=new X(s,as,os,{geometry:this._vertexBuffer},this._indexBuffer))}}class fs extends V{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(t){const s=N.pool.acquire(t),i=0===s.level?null:N.getId(s.level-1,s.row>>1,s.col>>1,s.world);return N.pool.release(s),i}getTileCoverage(t,s,i=!0,e){const h=super.getTileCoverage(t,s,i,e);if(!h)return h;const n=1<<h.lodInfo.level;return h.spans=h.spans.filter((t=>t.row>=0&&t.row<n)),h}scaleToLevel(t){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[t])return this._levelByScale[t];{const s=this._fullCacheLodInfos;if(t>s[0].scale)return s[0].level;let i,e;for(let h=0;h<s.length-1;h++)if(e=s[h+1],t>e.scale)return i=s[h],i.level+(i.scale-t)/(i.scale-e.scale);return s[s.length-1].level}}_initializeFullCacheLODs(t){let s;if(0===t[0].level)s=t.map((t=>({level:t.level,resolution:t.resolution,scale:t.scale})));else{const t=this.tileInfo.size[0],i=this.tileInfo.spatialReference;s=dt.create({size:t,spatialReference:i}).lods.map((t=>({level:t.level,resolution:t.resolution,scale:t.scale})))}for(let t=0;t<s.length;t++)this._levelByScale[s[t].scale]=s[t].level;this._fullCacheLodInfos=s}}let us=class extends(lt(ft)){constructor(){super(...arguments),this._styleChanges=[],this._fetchQueue=null,this._parseQueue=null,this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._collisionOverlay=null,this.fading=!1,this._getCollidersMesh=t=>{const{pixelRatio:s}=t.state;let i=0;const e=[],h=[];for(const t of this._vectorTileContainer.children)if(t.symbols)for(const[n,r]of t.symbols)for(const t of r)for(const n of t.colliders){const r=(n.xScreen+n.dxScreen)*s,o=(n.yScreen+n.dyScreen)*s,a=n.width*s,c=n.height*s,l=t.unique.parts[n.partIndex].targetOpacity>.5;if(!l&&"all"!==this.layer.showCollisionBoxes)continue;const f=3,u=1,p=3,d=0,m=l?2:0,y=l?3:0,w=ls.makeFlags(m,y);e.push(r,o,w,r+a,o,w,r,o+c,w,r+a,o+c,w),h.push(i,i+1,i+2,i+1,i+3,i+2),i+=4;const g=l?f:u,b=l?p:d,M=ls.makeFlags(g,b);e.push(r,o,M,r+a,o,M,r,o+1,M,r+a,o+1,M),h.push(i,i+1,i+2,i+1,i+3,i+2),i+=4,e.push(r,o+c-1,M,r+a,o+c-1,M,r,o+c,M,r+a,o+c,M),h.push(i,i+1,i+2,i+1,i+3,i+2),i+=4,e.push(r,o,M,r+1,o,M,r,o+c,M,r+1,o+c,M),h.push(i,i+1,i+2,i+1,i+3,i+2),i+=4,e.push(r+a-1,o,M,r+a,o,M,r+a-1,o+c,M,r+a,o+c,M),h.push(i,i+1,i+2,i+1,i+3,i+2),i+=4}return{vertexData:new Int16Array(e),indexData:new Uint32Array(h)}},this._getCollidersColors=()=>[1,.5,0,1,1,0,0,1,0,1,.5,1,0,.5,0,1],this._getCollidersOpacities=()=>[.05,.01,.15,.2]}async hitTest(t,s){if(!this._tileHandlerPromise)return null;await this._tileHandlerPromise;const i=await this._vectorTileContainer.hitTest(s);if(!i||0===i.length)return null;const e=i[0]-1,h=this._styleRepository,n=h.getStyleLayerByUID(e);if(!n)return null;const r=h.getStyleLayerIndex(n.id);return[{type:"graphic",mapPoint:t,layer:this.layer,graphic:new d({attributes:{layerId:r,layerName:n.id,layerUID:e},layer:this.layer,sourceLayer:this.layer})}]}update(t){if(this._tileHandlerPromise&&this._isTileHandlerReady)return t.pixelRatio!==this._tileHandler.devicePixelRatio?(this._start(),void(this._tileHandler.devicePixelRatio=t.pixelRatio)):void(this._styleChanges.length>0?this._tileHandlerPromise=this._applyStyleChanges():(this._fetchQueue.pause(),this._parseQueue.pause(),this._fetchQueue.state=t.state,this._parseQueue.state=t.state,this._tileManager.update(t)||this.requestUpdate(),this._parseQueue.resume(),this._fetchQueue.resume()))}attach(){const{style:t}=this.layer.currentStyleInfo;this._styleRepository=new ct(t),this._tileInfoView=new fs(this.layer.tileInfo,this.layer.fullExtent),this._vectorTileContainer=new rs(this._tileInfoView),this._tileHandler=new At(this.layer,this._styleRepository,window.devicePixelRatio||1),this.container.addChild(this._vectorTileContainer),this._start(),this.addAttachHandles([this._vectorTileContainer.on("fade-start",(()=>{this.fading=!0,this.notifyChange("updating"),this.requestUpdate()})),this._vectorTileContainer.on("fade-complete",(()=>{this._collisionOverlay?.requestRender(),this.fading=!1,this.notifyChange("updating"),this.requestUpdate()})),m((()=>this.layer.showCollisionBoxes),(t=>{"none"!==t?this._collisionOverlay||(this._collisionOverlay=new ls({getMesh:this._getCollidersMesh,getColors:this._getCollidersColors,getOpacities:this._getCollidersOpacities}),this.container.addChild(this._collisionOverlay)):this._collisionOverlay&&(this.container.removeChild(this._collisionOverlay),this._collisionOverlay=null),this.container.requestRender()}),y),this.layer.on("paint-change",(t=>{if(t.isDataDriven)this._styleChanges.push({type:x.PAINTER_CHANGED,data:t}),this.notifyChange("updating"),this.requestUpdate();else{const s=this._styleRepository,i=s.getLayerById(t.layer);if(!i)return;const e=i.type===rt.SYMBOL;s.setPaintProperties(t.layer,t.paint),e&&this._vectorTileContainer.restartDeclutter(),this._vectorTileContainer.requestRender()}})),this.layer.on("layout-change",(t=>{const s=this._styleRepository,i=s.getLayerById(t.layer);if(!i)return;const e=w(i.layout,t.layout);if(null!=e){if(g(e,"visibility")&&1===ps(e))return s.setLayoutProperties(t.layer,t.layout),i.type===rt.SYMBOL&&this._vectorTileContainer.restartDeclutter(),void this._vectorTileContainer.requestRender();this._styleChanges.push({type:x.LAYOUT_CHANGED,data:t}),this.notifyChange("updating"),this.requestUpdate()}})),this.layer.on("style-layer-visibility-change",(t=>{const s=this._styleRepository,i=s.getLayerById(t.layer);i&&(s.setStyleLayerVisibility(t.layer,t.visibility),i.type===rt.SYMBOL&&this._vectorTileContainer.restartDeclutter(),this._vectorTileContainer.requestRender())})),this.layer.on("style-layer-change",(t=>{this._styleChanges.push({type:x.LAYER_CHANGED,data:t}),this.notifyChange("updating"),this.requestUpdate()})),this.layer.on("delete-style-layer",(t=>{this._styleChanges.push({type:x.LAYER_REMOVED,data:t}),this.notifyChange("updating"),this.requestUpdate()})),this.layer.on("load-style",(()=>this._loadStyle())),this.layer.on("spriteSource-change",(t=>{this._newSpriteSource=t.spriteSource,this._styleChanges.push({type:x.SPRITES_CHANGED,data:null});const s=this._styleRepository.layers;for(const t of s)switch(t.type){case rt.SYMBOL:t.getLayoutProperty("icon-image")&&this._styleChanges.push({type:x.LAYOUT_CHANGED,data:{layer:t.id,layout:t.layout}});break;case rt.LINE:t.getPaintProperty("line-pattern")&&this._styleChanges.push({type:x.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}});break;case rt.FILL:t.getLayoutProperty("fill-pattern")&&this._styleChanges.push({type:x.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}})}this.notifyChange("updating"),this.requestUpdate()}))])}detach(){this._stop(),this.container.removeAllChildren(),this._vectorTileContainer=b(this._vectorTileContainer),this._tileHandler=b(this._tileHandler)}moveStart(){this.requestUpdate()}viewChange(){this.requestUpdate()}moveEnd(){this._collisionOverlay&&this._vectorTileContainer.restartDeclutter(),this.requestUpdate()}supportsSpatialReference(t){return M(this.layer.tileInfo?.spatialReference,t)}canResume(){let t=super.canResume();const{currentStyleInfo:s}=this.layer;if(t&&s?.layerDefinition){const i=this.view.scale,{minScale:e,maxScale:h}=s.layerDefinition;s&&s.layerDefinition&&(e&&e<i&&(t=!1),h&&h>i&&(t=!1))}return t}isUpdating(){const t=this._vectorTileContainer.children;return!this._isTileHandlerReady||!this._fetchQueue||!this._parseQueue||this._fetchQueue.updating||this._parseQueue.updating||t.length>0&&t.some((t=>t.invalidating))||this.fading}acquireTile(t){const s=this._createVectorTile(t);return this._tileHandlerPromise?.then((()=>{this._fetchQueue.push(s.key).then((t=>this._parseQueue.push({key:s.key,data:t}))).then((t=>{s.once("attach",(()=>this.requestUpdate())),s.setData(t),this.requestUpdate(),this.notifyChange("updating")})).catch((t=>{this.notifyChange("updating"),r(t)||j.getLogger(this).error(t)}))})),s}releaseTile(t){const s=t.key.id;this._fetchQueue.abort(s),this._parseQueue.abort(s),this.requestUpdate()}_start(){if(this._stop(),this._tileManager=new Dt({acquireTile:t=>this.acquireTile(t),releaseTile:t=>this.releaseTile(t),tileInfoView:this._tileInfoView},this._vectorTileContainer),!this.layer.currentStyleInfo)return;const t=new AbortController,s=this._tileHandler.start({signal:t.signal}).then((()=>{this._fetchQueue=new mt({tileInfoView:this._tileInfoView,process:(t,s)=>this._getTileData(t,s),concurrency:15}),this._parseQueue=new mt({tileInfoView:this._tileInfoView,process:(t,s)=>this._parseTileData(t,s),concurrency:8}),this.requestUpdate(),this._isTileHandlerReady=!0}));this._tileHandler.spriteMosaic.then((t=>{this._vectorTileContainer.setStyleResources(t,this._tileHandler.glyphMosaic,this._styleRepository),this.requestUpdate()})),this._tileHandlerAbortController=t,this._tileHandlerPromise=s}_stop(){if(!this._tileHandlerAbortController||!this._vectorTileContainer)return;const t=this._tileHandlerAbortController;t&&t.abort(),this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._fetchQueue=b(this._fetchQueue),this._parseQueue=b(this._parseQueue),this._tileManager=b(this._tileManager),this._vectorTileContainer.removeAllChildren()}async _getTileData(t,s){const i=await this._tileHandler.fetchTileData(t,s);return this.notifyChange("updating"),i}async _parseTileData(t,s){return this._tileHandler.parseTileData(t,s)}async _applyStyleChanges(){this._isTileHandlerReady=!1,this._fetchQueue.pause(),this._parseQueue.pause(),this._fetchQueue.clear(),this._parseQueue.clear(),this._tileManager.clearCache();const t=this._styleChanges;try{await this._tileHandler.updateStyle(t)}catch(t){j.getLogger(this).error("error applying vector-tiles style update",t.message),this._fetchQueue.resume(),this._parseQueue.resume(),this._isTileHandlerReady=!0}const s=this._styleRepository,i=[];t.forEach((t=>{if(t.type!==x.LAYER_REMOVED)return;const e=t.data,h=s.getLayerById(e.layer);h&&i.push(h.uid)}));const e=[];let h;t.forEach((t=>{const i=t.type,n=t.data;switch(i){case x.PAINTER_CHANGED:s.setPaintProperties(n.layer,n.paint),h=n.layer;break;case x.LAYOUT_CHANGED:s.setLayoutProperties(n.layer,n.layout),h=n.layer;break;case x.LAYER_REMOVED:return void s.deleteStyleLayer(n.layer);case x.LAYER_CHANGED:s.setStyleLayer(n.layer,n.index),h=n.layer.id;break;case x.SPRITES_CHANGED:this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(this._newSpriteSource)),this._newSpriteSource=null,h=null}const r=s.getLayerById(h);r&&e.push(r.uid)}));const n=this._vectorTileContainer.children;if(i.length>0){this._vectorTileContainer.deleteStyleLayers(i);for(const t of n)t.deleteLayerData(i)}if(this._fetchQueue.resume(),this._parseQueue.resume(),e.length>0){const t=[];for(const s of n){const i=this._fetchQueue.push(s.key).then((t=>this._parseQueue.push({key:s.key,data:t,styleLayerUIDs:e}))).then((t=>s.setData(t)));t.push(i)}await Promise.all(t)}this._styleChanges=[],this._isTileHandlerReady=!0,this.notifyChange("updating"),this.requestUpdate()}async _loadStyle(){const{style:t}=this.layer.currentStyleInfo,s=v(t);this._isTileHandlerReady=!1,this._fetchQueue.pause(),this._parseQueue.pause(),this._fetchQueue.clear(),this._parseQueue.clear(),this.notifyChange("updating"),this._styleRepository=new ct(s),this._vectorTileContainer.destroy(),this._tileManager.clear(),this._tileHandlerAbortController.abort(),this._tileHandlerAbortController=new AbortController;const{signal:i}=this._tileHandlerAbortController;try{this._tileHandlerPromise=this._tileHandler.setStyle(this._styleRepository,s),await this._tileHandlerPromise}catch(t){if(!r(t))throw t}if(i.aborted)return this._fetchQueue.resume(),this._parseQueue.resume(),this._isTileHandlerReady=!0,this.notifyChange("updating"),void this.requestUpdate();const e=await this._tileHandler.spriteMosaic;this._vectorTileContainer.setStyleResources(e,this._tileHandler.glyphMosaic,this._styleRepository),this._fetchQueue.resume(),this._parseQueue.resume(),this._isTileHandlerReady=!0,this.notifyChange("updating"),this.requestUpdate()}_createVectorTile(t){const s=this._tileInfoView.getTileBounds(p(),t),i=this._tileInfoView.getTileResolution(t.level);return new Vt(t,i,s[0],s[3],512,512,this._styleRepository)}};function ps(t){if(null==t)return 0;switch(t.type){case"partial":return Object.keys(t.diff).length;case"complete":return Math.max(Object.keys(t.oldValue).length,Object.keys(t.newValue).length);case"collection":return Object.keys(t.added).length+Object.keys(t.changed).length+Object.keys(t.removed).length}}A([S()],us.prototype,"_fetchQueue",void 0),A([S()],us.prototype,"_parseQueue",void 0),A([S()],us.prototype,"_isTileHandlerReady",void 0),A([S()],us.prototype,"fading",void 0),us=A([_("esri.views.2d.layers.VectorTileLayerView2D")],us);const ds=us;export default ds;
//# sourceMappingURL=p-816bedd1.js.map