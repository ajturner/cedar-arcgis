import{P as t,k as e,n as s,f8 as r,f9 as i,v as n,aT as o,aA as a,ck as c}from"./p-98455486.js";import{b as l}from"./p-2b6b8db8.js";import{p}from"./p-69ec1c26.js";import{S as h}from"./p-7dc0ec82.js";import{o as u,b as f,E as d,n as m,x as y}from"./p-eda79132.js";import{p as b}from"./p-af9baf30.js";import"./p-50b034e8.js";import"./p-e6a64715.js";import"./p-6bb7b693.js";import"./p-0e94eaa4.js";import"./p-ecc7ed03.js";import"./p-220b11a0.js";import"./p-1abe3c64.js";import"./p-4cbc7b66.js";import"./p-3a9bb31c.js";import"./p-f5452a6b.js";import"./p-8b2bb530.js";import"./p-9a4094ba.js";import"./p-9f1a0adc.js";import"./p-2d1dac84.js";import"./p-de65627f.js";import"./p-0d2202fd.js";import"./p-f33b44a5.js";import"./p-a3c11f30.js";import"./p-13e550f5.js";import"./p-795f7c81.js";import"./p-5977fcaf.js";import"./p-eeca6bc1.js";import"./p-38e70926.js";import"./p-21ae9bf7.js";import"./p-aedab47c.js";class j{constructor(t){this._remoteClient=t,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,s){const r=this._resourceMap,i=r.get(e);if(i)return i;let n=this._inFlightResourceMap.get(e);if(n)return n;try{n=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...s}),this._inFlightResourceMap.set(e,n),n.then((t=>(this._inFlightResourceMap.delete(e),r.set(e,t),t)))}catch(e){return t(e)?null:{width:0,height:0}}return n}getResource(t){return this._resourceMap.get(t)??null}loadFont(t){return Promise.resolve(null)}}function g(t,e){return(!t.minScale||t.minScale>=e)&&(!t.maxScale||t.maxScale<=e)}function w(t){const e=t.message,s={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const t in e.data){const r=t,i=e.data[r];if(s.message.data[r]=null,null!=i){const t=i.stride,e=i.indices.slice(0),n=i.vertices.slice(0),o=i.records.slice(0),c={stride:t,indices:e,vertices:n,records:o,metrics:a(i.metrics,(t=>t.slice(0)))};s.transferList.push(e,n,o),s.message.data[r]=c}}return s}let T=class extends b{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new j(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach((e=>{e.forEach(t)}))}async update(t,e){const s=e.schema.processors[0];if("symbol"!==s.type)return;const n=r(this._schema,s);(i(n,"mesh")||i(n,"target"))&&(t.mesh=!0,t.why?.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,s,r){return n(r),this._onTileData(t,e,s,r)}onTileClear(t,e){const s={clear:!0,end:e};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:s})}onTileError(t,e,s){const r=s.signal,i={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:r})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach((t=>{for(const s of t)s.message.tileKey===e.id&&this._updateTileMesh("append",e,w(s),[],!1,!1,null)}))}_addBufferData(t,e){this._bufferData.has(t)||this._bufferData.set(t,[]),this._bufferData.get(t)?.push(w(e))}_createFactory(t){const{geometryType:e,objectIdField:s,fields:r}=this.service,i=(t,e)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",t,e),n={geometryType:e,fields:r,spatialReference:o.fromJSON(this.spatialReference)},c=new y(i,this.tileStore.tileScheme.tileInfo),{matcher:l,aggregateMatcher:p}=t.mesh;return this._store=c,this._matchers.feature=u(l,c,n,this._resourceManagerProxy),this._matchers.aggregate=a(p,(t=>u(t,c,n,this._resourceManagerProxy))),new f(e,s,c)}async _onTileData(t,e,s,r){n(r);const{type:i,addOrUpdate:o,remove:a,clear:c,end:l}=e,p=!!this._schema.mesh.sortKey;if(!o){const e={type:i,addOrUpdate:null,remove:a,clear:c,end:l,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:e},r)}const h=this._processFeatures(t,o,s,r,e.status?.version);try{const s=await h;if(null==s){const e={type:i,addOrUpdate:null,remove:a,clear:c,end:l,sort:p};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:e},r)}const n=[];for(const e of s){let s=!1;const r=e.message.bufferIds,i=t.key.id,o=e.message.tileKey;if(i!==o&&null!=r){if(!this.tileStore.get(o)){this._addBufferData(i,e),n.push(e);continue}let t=this._bufferIds.get(o);t||(t=new Set,this._bufferIds.set(o,t));const a=Array.from(r);for(const e of a){if(t.has(e)){s=!0;break}t.add(e)}}s||(this._addBufferData(i,e),n.push(e))}await Promise.all(n.map((s=>{const n=t.key.id===s.message.tileKey,o=n?e.remove:[],a=n&&e.end;return this._updateTileMesh(i,t,s,o,a,!!e.clear,r.signal)})))}catch(e){this._handleError(t,e,r)}}async _updateTileMesh(t,e,s,r,i,o,c){const l=t,p=s.message.tileKey,h=!!this._schema.mesh.sortKey;p!==e.key.id&&(i=!1);const u={type:l,addOrUpdate:a(s,(t=>t.message)),remove:r,clear:o,end:i,sort:h},f={transferList:a(s,(t=>t.transferList))||[]||[],signal:c};return n(f),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:p,data:u},f)}async _processFeatures(t,e,s,r,i){if(null==e||!e.hasFeatures)return null;const o={transform:t.transform,hasZ:!1,hasM:!1},a=this._factory,c={viewingMode:"",scale:t.scale},l=await this._matchers.feature,p=await this._matchers.aggregate;n(r);const h=this._getLabelInfos(t,e);return await a.analyze(e.getCursor(),this._resourceManagerProxy,l,p,o,c),n(r),this._writeFeatureSet(t,e,o,h,a,s,i)}_writeFeatureSet(t,e,s,r,i,n,o){const a=e.getSize(),c=this._schema.mesh.matcher.symbologyType,l=new d(t.key.id,{features:a,records:a,metrics:0},c,n,c!==h.HEATMAP,o),p={viewingMode:"",scale:t.scale},u=e.getCursor();for(;u.next();)try{const e=u.getDisplayId(),n=null!=r?r.get(e):null;i.writeCursor(l,u,s,p,t.level,n,this._resourceManagerProxy)}catch(t){}const f=t.tileInfoView.tileInfo.isWrappable;return l.serialize(f)}_handleError(e,s,r){if(!t(s)){const t={tileKey:e.id,error:s.message};return this.remoteClient.invoke("tileRenderer.onTileError",t,{signal:r.signal})}return Promise.resolve()}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(null==e)return null;if("subtype"===e.type){const s={type:"subtype",classes:{}};let r=!1;for(const i in e.classes){const n=e.classes[i].filter((e=>g(e,t.scale)));r=r||!!n.length,s.classes[i]=n}return r?s:null}const s=e.classes.filter((e=>g(e,t.scale)));return s.length?{type:"simple",classes:s}:null}_getLabels(t,e){if("subtype"===e.type){const s=this.service.subtypeField,r=c(s,"Expected to find subtype Field"),i=t.readAttribute(r);return null==i?[]:e.classes[i]??[]}return e.classes}_getLabelInfos(t,e){const s=this._getLabelingSchemaForScale(t);if(null==s)return null;const r=new Map,i=e.getCursor();for(;i.next();){const t=i.getDisplayId(),e=[],n=p(t),o=n&&1!==i.readAttribute("cluster_count")?"aggregate":"feature",a=this._getLabels(i,s);for(const s of a){if(s.target!==o)continue;const r=i.getStorage(),a=n&&"feature"===o?r.getComputedStringAtIndex(i.readAttribute("referenceId"),s.fieldIndex):r.getComputedStringAtIndex(t,s.fieldIndex);if(!a)continue;const c=l(a.toString()),p=c[0],h=c[1];this._store.getMosaicItem(s.symbol,m(p)).then((t=>{e[s.index]={glyphs:t.glyphMosaicItems??[],rtl:h,index:s.index}}))}r.set(t,e)}return r}};T=e([s("esri.views.2d.layers.features.processors.SymbolProcessor")],T);const M=T;export default M;
//# sourceMappingURL=p-e7b88005.js.map