import{aG as e,s as r,df as a,dg as t,bP as n,dh as l}from"./p-98455486.js";import{t as s,r as u}from"./p-3521d9f7.js";import{a as o}from"./p-e16f42c4.js";const c={FeatureLayer:!0,SceneLayer:!0};async function i(e){const r=e.properties?.customParameters,a=await f(e.url,r),t={...e.properties,url:e.url};if(!a.sublayerIds)return null!=a.layerOrTableId&&(t.layerId=a.layerOrTableId,t.sourceJSON=a.sourceJSON),new a.Constructor(t);const n=new((await import("./p-eb18799f.js")).default)({title:a.parsedUrl.title});return y(n,a,t),n}function m(e,r){return e?e.find((e=>e.id===r)):null}function y(e,r,a){function t(e,t){const n={...a,layerId:e,sublayerTitleMode:"service-name"};return null!=t&&(n.sourceJSON=t),new r.Constructor(n)}r.sublayerIds.forEach((a=>{const n=t(a,m(r.sublayerInfos,a));e.add(n)})),r.tableIds.forEach((a=>{const n=t(a,m(r.tableInfos,a));e.tables.add(n)}))}async function f(a,t){let n=e(a);if(null==n&&(n=await S(a,t)),null==n)throw new r("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:a});const{serverType:u,sublayer:o}=n;let i;const m={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(u){case"MapServer":if(null!=o)i="FeatureLayer";else{i=await w(a,t)?"TileLayer":"MapImageLayer"}break;case"ImageServer":{const e=await s(a,{customParameters:t}),{tileInfo:r,cacheType:n}=e;i=r?"LERC"!==r?.format?.toUpperCase()||n&&"elevation"!==n.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const e=await s(n.url.path,{customParameters:t});if(i="SceneLayer",e){const r=e?.layers;if("Voxel"===e?.layerType)i="VoxelLayer";else if(r?.length){const e=r[0]?.layerType;null!=e&&null!=l[e]&&(i=l[e])}}break}default:i=m[u]}const y="FeatureServer"===u,f={parsedUrl:n,Constructor:null,layerOrTableId:y?o:void 0,sublayerIds:null,tableIds:null};if(c[i]&&null==o){const e=await d(a,u,t);y&&(f.sublayerInfos=e.layerInfos,f.tableInfos=e.tableInfos);1!==e.layerIds.length+e.tableIds.length?(f.sublayerIds=e.layerIds,f.tableIds=e.tableIds):y&&(f.layerOrTableId=e.layerIds[0]??e.tableIds[0],f.sourceJSON=e.layerInfos?.[0]??e.tableInfos?.[0])}return f.Constructor=await p(i),f}async function S(e,r){const l=await s(e,{customParameters:r});let u=null,o=null;const c=l.type;if("Feature Layer"===c||"Table"===c?(u="FeatureServer",o=l.id??null):"indexedVector"===c?u="VectorTileServer":l.hasOwnProperty("mapName")?u="MapServer":l.hasOwnProperty("bandCount")&&l.hasOwnProperty("pixelSizeX")?u="ImageServer":l.hasOwnProperty("maxRecordCount")&&l.hasOwnProperty("allowGeometryUpdates")?u="FeatureServer":l.hasOwnProperty("streamUrls")?u="StreamServer":v(l)?(u="SceneServer",o=l.id):l.hasOwnProperty("layers")&&v(l.layers?.[0])&&(u="SceneServer"),!u)return null;const i=null!=o?a(e):null;return{title:null!=i&&l.name||t(e),serverType:u,sublayer:o,url:{path:null!=i?i.serviceUrl:n(e).path}}}function v(e){return null!=e&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}async function d(e,r,a){let t,n=!1;if("FeatureServer"===r){const r=await u(e,{customParameters:a});n=!!r.layersJSON,t=r.layersJSON||r.serviceJSON}else t=await s(e,{customParameters:a});const l=t?.layers,o=t?.tables;return{layerIds:l?.map((e=>e.id)).reverse()||[],tableIds:o?.map((e=>e.id)).reverse()||[],layerInfos:n?l:[],tableInfos:n?o:[]}}async function p(e){return(0,o[e])()}async function w(e,r){return(await s(e,{customParameters:r})).tileInfo}export{i as fromUrl};
//# sourceMappingURL=p-99fbcdfc.js.map