class t{constructor(t=[],s=[],i=!1){this.lengths=t??[],this.coords=s??[],this.hasIndeterminateRingOrder=i}static fromRect(s){const[i,h,e,n]=s,r=e-i,o=n-h;return new t([5],[i,h,r,0,0,o,-r,0,0,-o])}get isPoint(){return 0===this.lengths.length}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce(((t,s)=>t+s))}forEachVertex(t){let s=0;this.lengths.length||t(this.coords[0],this.coords[1]);for(let i=0;i<this.lengths.length;i++){const h=this.lengths[i];for(let i=0;i<h;i++){t(this.coords[2*(i+s)],this.coords[2*(i+s)+1])}s+=h}}clone(s){return s?(s.set(this.coords),new t(this.lengths.slice(),s,this.hasIndeterminateRingOrder)):new t(this.lengths.slice(),this.coords.slice(),this.hasIndeterminateRingOrder)}}class s{constructor(t=null,s={},i,h){this.geometry=t,this.attributes=s,this.centroid=i,this.objectId=h,this.displayId=0,this.geohashX=0,this.geohashY=0}weakClone(){const t=new s(this.geometry,this.attributes,this.centroid,this.objectId);return t.displayId=this.displayId,t.geohashX=this.geohashX,t.geohashY=this.geohashY,t}}function i(t){return!(null==t.geometry||!t.geometry.coords||!t.geometry.coords.length)}class h extends s{}export{s as a,h as e,i as s,t};
//# sourceMappingURL=p-e6a64715.js.map