import{ao as t,aj as s,ay as i,bU as h,as as n,at as r,aZ as e,aw as o,b2 as a,bV as u,bM as c,aT as l,ag as f,G as M,a2 as m,h as d}from"./p-b54724b6.js";import{e as g}from"./p-cae2235f.js";import{f as p}from"./p-9a4094ba.js";class w{constructor(t,s){this.item=t,this.controller=s,this.promise=null}}class v{constructor(s){this._deferreds=new Map,this._controllers=new Map,this._processingItems=new Map,this._isPaused=!1,this._schedule=null,this._task=null,this.concurrency=1,s.concurrency&&(this.concurrency=s.concurrency),this._queue=new t(s.peeker),this.process=s.process;const i=s.scheduler;s.priority&&i&&(this._task=i.registerTask(s.priority,this))}destroy(){this.clear(),this._schedule=s(this._schedule),this._task=s(this._task)}get length(){return this._processingItems.size+this._queue.length}abort(t){const s=this._controllers.get(t);s&&s.abort()}clear(){this._queue.clear();const t=[];this._controllers.forEach((s=>t.push(s))),this._controllers.clear(),t.forEach((t=>t.abort())),this._processingItems.clear(),this._cancelNext()}forEach(t){this._deferreds.forEach(((s,i)=>t(i)))}get(t){const s=this._deferreds.get(t);return s?s.promise:void 0}isOngoing(t){return this._processingItems.has(t)}has(t){return this._deferreds.has(t)}pause(){this._isPaused||(this._isPaused=!0,this._cancelNext())}push(t,s){const r=this.get(t);if(r)return r;const e=new AbortController;let a=null;s&&(a=i(s,(()=>e.abort())));const u=()=>{const s=this._processingItems.get(t);s&&s.controller.abort(),c(),f.reject(o())},c=()=>{l.remove(),null!=a&&a.remove(),this._deferreds.delete(t),this._controllers.delete(t),this._queue.remove(t),this._processingItems.delete(t),this._scheduleNext()},l=h(e.signal,u),f=n();return this._deferreds.set(t,f),this._controllers.set(t,e),f.promise.then(c,c),this._queue.push(t),this._scheduleNext(),f.promise}last(){return this._queue.last()}peek(){return this._queue.peek()}popLast(){return this._queue.popLast()}reset(){const t=[];this._processingItems.forEach((s=>t.push(s))),this._processingItems.clear();for(const s of t)this._queue.push(s.item),s.controller.abort();this._scheduleNext()}resume(){this._isPaused&&(this._isPaused=!1,this._scheduleNext())}takeAll(){const t=[];for(;this._queue.length;)t.push(this._queue.pop());return this.clear(),t}get running(){return!this._isPaused&&this._queue.length>0&&this._processingItems.size<this.concurrency}runTask(t){for(;!t.done&&this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop()),t.madeProgress()}_scheduleNext(){this._task||this._isPaused||this._schedule||(this._schedule=r((()=>{this._schedule=null,this._next()})))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(t,s){this._canProcessFulfillment(t)&&(this._scheduleNext(),this._deferreds.get(t.item).resolve(s))}_processError(t,s){this._canProcessFulfillment(t)&&(this._scheduleNext(),this._deferreds.get(t.item).reject(s))}_canProcessFulfillment(t){return!!this._deferreds.get(t.item)&&this._processingItems.get(t.item)===t}_process(t){if(null==t)return;let s;const i=new AbortController,h=new w(t,i);this._processingItems.set(t,h);try{s=this.process(t,i.signal)}catch(t){this._processError(h,t)}e(s)?(h.promise=s,s.then((t=>this._processResult(h,t)),(t=>this._processError(h,t)))):this._processResult(h,s)}get test(){return{update:t=>this.runTask(t)}}}function x(t,s){return[t,s]}function b(t,s,i){return t[0]=s,t[1]=i,t}function _(t,s,i,h,n){return t[0]=s,t[1]=i,t[2]=h,t[3]=n,t}const F=new g("0/0/0/0");class T{static create(t,s,i=null){const h=a(t.spatialReference),n=s.origin||x(t.origin.x,t.origin.y),r=x(t.size[0]*s.resolution,t.size[1]*s.resolution),e=x(-1/0,-1/0),o=x(1/0,1/0),u=x(1/0,1/0);null!=i&&(b(e,Math.max(0,Math.floor((i.xmin-n[0])/r[0])),Math.max(0,Math.floor((n[1]-i.ymax)/r[1]))),b(o,Math.max(0,Math.floor((i.xmax-n[0])/r[0])),Math.max(0,Math.floor((n[1]-i.ymin)/r[1]))),b(u,o[0]-e[0]+1,o[1]-e[1]+1));const{cols:c,rows:l}=s;let f,M,m,d;return!i&&c&&l&&(b(e,c[0],l[0]),b(o,c[1],l[1]),b(u,c[1]-c[0]+1,l[1]-l[0]+1)),t.isWrappable?(f=x(Math.ceil(Math.round((h.valid[1]-h.valid[0])/s.resolution)/t.size[0]),u[1]),M=x(Math.floor((h.origin[0]-n[0])/r[0]),e[1]),m=x(f[0]+M[0]-1,o[1]),d=!0):(M=e,m=o,f=u,d=!1),new T(s.level,s.resolution,s.scale,n,e,o,u,r,M,m,f,d)}constructor(t,s,i,h,n,r,e,o,a,u,c,l){this.level=t,this.resolution=s,this.scale=i,this.origin=h,this.first=n,this.last=r,this.size=e,this.norm=o,this.worldStart=a,this.worldEnd=u,this.worldSize=c,this.wrap=l}normalizeCol(t){if(!this.wrap)return t;const s=this.worldSize[0];return t<0?s-1-Math.abs((t+1)%s):t%s}denormalizeCol(t,s){return this.wrap?this.worldSize[0]*s+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,s,i=!1){F.set(s);const h=i?F.col:this.denormalizeCol(F.col,F.world),n=F.row;return _(t,this.getXForColumn(h),this.getYForRow(n+1),this.getXForColumn(h+1),this.getYForRow(n)),t}getTileCoords(t,s,i=!1){F.set(s);const h=i?F.col:this.denormalizeCol(F.col,F.world);return Array.isArray(t)?b(t,this.getXForColumn(h),this.getYForRow(F.row)):(t.x=this.getXForColumn(h),t.y=this.getYForRow(F.row)),t}}class C{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,s){const{spans:i,lodInfo:h}=this,{level:n}=h;if(0!==i.length)for(const{row:r,colFrom:e,colTo:o}of i)for(let i=e;i<=o;i++)t.call(s,n,r,h.normalizeCol(i),h.getWorldForColumn(i))}}C.pool=new u(C);class S{constructor(t,s,i){this.row=t,this.colFrom=s,this.colTo=i}}const X=new g("0/0/0/0");class Y{static create(t,s){t[1]>s[1]&&([t,s]=[s,t]);const[i,h]=t,[n,r]=s,e=n-i,o=r-h,a=0!==o?e/o:0,u=(Math.ceil(h)-h)*a,c=(Math.floor(h)-h)*a;return new Y(i,Math.floor(h),Math.ceil(r),a,e<0?u:c,e<0?c:u,e<0?n:i,e<0?i:n)}constructor(t,s,i,h,n,r,e,o){this.x=t,this.ymin=s,this.ymax=i,this.invM=h,this.leftAdjust=n,this.rightAdjust=r,this.leftBound=e,this.rightBound=o}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const y=[[0,0],[0,0],[0,0],[0,0]],I=1e-6;class R{constructor(t,s=null,i=t.lods[0].level,h=t.lods[t.lods.length-1].level){this.tileInfo=t,this.fullExtent=s,this.scales=[],this._infoByScale={},this._infoByLevel={};const n=t.lods.filter((t=>t.level>=i&&t.level<=h));this.minScale=n[0].scale,this.maxScale=n[n.length-1].scale;const r=this._lodInfos=n.map((i=>T.create(t,i,s)));n.forEach(((t,s)=>{this._infoByLevel[t.level]=r[s],this._infoByScale[t.scale]=r[s],this.scales[s]=t.scale}),this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel["number"==typeof t?t:t.level]}getTileBounds(t,s,i=!1){X.set(s);const h=this._infoByLevel[X.level];return h?h.getTileBounds(t,X,i):t}getTileCoords(t,s,i=!1){X.set(s);const h=this._infoByLevel[X.level];return h?h.getTileCoords(t,X,i):t}getTileCoverage(t,s=192,i=!0,h="closest"){if(!i&&(t.scale>this.minScale||t.scale<this.maxScale))return null;const n="closest"===h?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),r=C.pool.acquire(n),e=this._wrap;let o,a,u,c=1/0,l=-1/0;const f=r.spans;y[0][0]=y[0][1]=y[1][1]=y[3][0]=-s,y[1][0]=y[2][0]=t.size[0]+s,y[2][1]=y[3][1]=t.size[1]+s;for(const s of y)t.toMap(s,s),s[0]=n.getColumnForX(s[0]),s[1]=n.getRowForY(s[1]);const M=[];let m=3;for(let t=0;t<4;t++){if(y[t][1]===y[m][1]){m=t;continue}const s=Y.create(y[t],y[m]);c=Math.min(s.ymin,c),l=Math.max(s.ymax,l),void 0===M[s.ymin]&&(M[s.ymin]=[]),M[s.ymin].push(s),m=t}if(null==c||null==l||l-c>100)return null;let d=[];for(o=c;o<l;){null!=M[o]&&(d=d.concat(M[o])),a=1/0,u=-1/0;for(let t=d.length-1;t>=0;t--){const s=d[t];a=Math.min(a,s.getLeftCol()),u=Math.max(u,s.getRightCol())}if(a=Math.floor(a),u=Math.floor(u),o>=n.first[1]&&o<=n.last[1])if(e)if(n.size[0]<n.worldSize[0]){const t=Math.floor(u/n.worldSize[0]);for(let s=Math.floor(a/n.worldSize[0]);s<=t;s++)f.push(new S(o,Math.max(n.getFirstColumnForWorld(s),a),Math.min(n.getLastColumnForWorld(s),u)))}else f.push(new S(o,a,u));else a>n.last[0]||u<n.first[0]||(a=Math.max(a,n.first[0]),u=Math.min(u,n.last[0]),f.push(new S(o,a,u)));o+=1;for(let t=d.length-1;t>=0;t--){const s=d[t];s.ymax>=o?s.incrRow():d.splice(t,1)}}return r}getTileParentId(t){X.set(t);const s=this._infoByLevel[X.level],i=this._lodInfos.indexOf(s)-1;return i<0?null:(this._getTileIdAtLOD(X,this._lodInfos[i],X),X.id)}getTileResolution(t){const s=this._infoByLevel["object"==typeof t?t.level:t];return s?s.resolution:-1}getTileScale(t){const s=this._infoByLevel[t.level];return s?s.scale:-1}intersects(t,s){X.set(s);const i=this._infoByLevel[X.level],h=t.lodInfo;if(h.resolution>i.resolution){this._getTileIdAtLOD(X,h,X);const s=h.denormalizeCol(X.col,X.world);for(const i of t.spans)if(i.row===X.row&&i.colFrom<=s&&i.colTo>=s)return!0}if(h.resolution<i.resolution){const[s,n,r,e]=t.spans.reduce(((t,s)=>(t[0]=Math.min(t[0],s.row),t[1]=Math.max(t[1],s.row),t[2]=Math.min(t[2],s.colFrom),t[3]=Math.max(t[3],s.colTo),t)),[1/0,-1/0,1/0,-1/0]),o=i.denormalizeCol(X.col,X.world),a=h.getColumnForX(i.getXForColumn(o)),u=h.getRowForY(i.getYForRow(X.row)),c=h.getColumnForX(i.getXForColumn(o+1))-1,l=h.getRowForY(i.getYForRow(X.row+1))-1;return!(a>e||c<r||u>n||l<s)}const n=h.denormalizeCol(X.col,X.world);return t.spans.some((t=>t.row===X.row&&t.colFrom<=n&&t.colTo>=n))}normalizeBounds(t,s,i){if(t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],this._wrap){const s=a(this.tileInfo.spatialReference),h=-i*(s.valid[1]-s.valid[0]);t[0]+=h,t[2]+=h}return t}getSmallestInfoForScale(t){const s=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>s[0])return this._infoByScale[s[0]];for(let i=1;i<s.length-1;i++)if(t>s[i]+I)return this._infoByScale[s[i-1]];return this._infoByScale[s[s.length-1]]}getClosestInfoForScale(t){const s=this.scales;return this._infoByScale[t]||(t=s.reduce(((s,i)=>Math.abs(i-t)<Math.abs(s-t)?i:s),s[0])),this._infoByScale[t]}scaleToLevel(t){const s=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let i=s.length-1;i>=0;i--)if(t<s[i]){if(i===s.length-1)return this._infoByScale[s[s.length-1]].level;return this._infoByScale[s[i]].level+(s[i]-t)/(s[i]-s[i+1])}return this._infoByScale[s[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,s,i){const h=this._infoByLevel[i.level];return t.set(i),s.resolution<h.resolution?null:(s.resolution===h.resolution||(t.level=s.level,t.col=Math.floor(i.col*h.resolution/s.resolution+.01),t.row=Math.floor(i.row*h.resolution/s.resolution+.01)),t)}}function L(t,s){if(!(this instanceof L))return new L(t,s);this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),s&&("function"==typeof s?this.toBBox=s:this._initFormat(s)),this.clear()}function A(t,s,i){if(!i)return s.indexOf(t);for(var h=0;h<s.length;h++)if(i(t,s[h]))return h;return-1}function B(t,s){j(t,0,t.children.length,s,t)}function j(t,s,i,h,n){n||(n=V(null)),n.minX=1/0,n.minY=1/0,n.maxX=-1/0,n.maxY=-1/0;for(var r,e=s;e<i;e++)r=t.children[e],P(n,t.leaf?h(r):r);return n}function P(t,s){return t.minX=Math.min(t.minX,s.minX),t.minY=Math.min(t.minY,s.minY),t.maxX=Math.max(t.maxX,s.maxX),t.maxY=Math.max(t.maxY,s.maxY),t}function O(t,s){return t.minX-s.minX}function z(t,s){return t.minY-s.minY}function N(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function k(t){return t.maxX-t.minX+(t.maxY-t.minY)}function D(t,s){return(Math.max(s.maxX,t.maxX)-Math.min(s.minX,t.minX))*(Math.max(s.maxY,t.maxY)-Math.min(s.minY,t.minY))}function E(t,s){var i=Math.max(t.minX,s.minX),h=Math.max(t.minY,s.minY),n=Math.min(t.maxX,s.maxX),r=Math.min(t.maxY,s.maxY);return Math.max(0,n-i)*Math.max(0,r-h)}function W(t,s){return t.minX<=s.minX&&t.minY<=s.minY&&s.maxX<=t.maxX&&s.maxY<=t.maxY}function J(t,s){return s.minX<=t.maxX&&s.minY<=t.maxY&&s.maxX>=t.minX&&s.maxY>=t.minY}function V(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function Z(t,s,i,h,n){for(var r,e=[s,i];e.length;)(i=e.pop())-(s=e.pop())<=h||(r=s+Math.ceil((i-s)/h/2)*h,p(t,r,s,i,n),e.push(s,r,r,i))}L.prototype={all:function(){return this._all(this.data,[])},search:function(t){var s=this.data,i=[],h=this.toBBox;if(!J(t,s))return i;for(var n,r,e,o,a=[];s;){for(n=0,r=s.children.length;n<r;n++)e=s.children[n],J(t,o=s.leaf?h(e):e)&&(s.leaf?i.push(e):W(t,o)?this._all(e,i):a.push(e));s=a.pop()}return i},collides:function(t){var s=this.data,i=this.toBBox;if(!J(t,s))return!1;for(var h,n,r,e,o=[];s;){for(h=0,n=s.children.length;h<n;h++)if(r=s.children[h],J(t,e=s.leaf?i(r):r)){if(s.leaf||W(t,e))return!0;o.push(r)}s=o.pop()}return!1},load:function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var s=0,i=t.length;s<i;s++)this.insert(t[s]);return this}var h=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===h.height)this._splitRoot(this.data,h);else{if(this.data.height<h.height){var n=this.data;this.data=h,h=n}this._insert(h,this.data.height-h.height-1,!0)}else this.data=h;return this},insert:function(t){return t&&this._insert(t,this.data.height-1),this},clear:function(){return this.data=V([]),this},remove:function(t,s){if(!t)return this;for(var i,h,n,r,e=this.data,o=this.toBBox(t),a=[],u=[];e||a.length;){if(e||(e=a.pop(),h=a[a.length-1],i=u.pop(),r=!0),e.leaf&&-1!==(n=A(t,e.children,s)))return e.children.splice(n,1),a.push(e),this._condense(a),this;r||e.leaf||!W(e,o)?h?(i++,e=h.children[i],r=!1):e=null:(a.push(e),u.push(i),i=0,h=e,e=e.children[0])}return this},toBBox:function(t){return t},compareMinX:O,compareMinY:z,toJSON:function(){return this.data},fromJSON:function(t){return this.data=t,this},_all:function(t,s){for(var i=[];t;)t.leaf?s.push.apply(s,t.children):i.push.apply(i,t.children),t=i.pop();return s},_build:function(t,s,i,h){var n,r=i-s+1,e=this._maxEntries;if(r<=e)return B(n=V(t.slice(s,i+1)),this.toBBox),n;h||(h=Math.ceil(Math.log(r)/Math.log(e)),e=Math.ceil(r/Math.pow(e,h-1))),(n=V([])).leaf=!1,n.height=h;var o,a,u,c,l=Math.ceil(r/e),f=l*Math.ceil(Math.sqrt(e));for(Z(t,s,i,f,this.compareMinX),o=s;o<=i;o+=f)for(Z(t,o,u=Math.min(o+f-1,i),l,this.compareMinY),a=o;a<=u;a+=l)c=Math.min(a+l-1,u),n.children.push(this._build(t,a,c,h-1));return B(n,this.toBBox),n},_chooseSubtree:function(t,s,i,h){for(var n,r,e,o,a,u,c,l;h.push(s),!s.leaf&&h.length-1!==i;){for(c=l=1/0,n=0,r=s.children.length;n<r;n++)a=N(e=s.children[n]),(u=D(t,e)-a)<l?(l=u,c=a<c?a:c,o=e):u===l&&a<c&&(c=a,o=e);s=o||s.children[0]}return s},_insert:function(t,s,i){var h=this.toBBox,n=i?t:h(t),r=[],e=this._chooseSubtree(n,this.data,s,r);for(e.children.push(t),P(e,n);s>=0&&r[s].children.length>this._maxEntries;)this._split(r,s),s--;this._adjustParentBBoxes(n,r,s)},_split:function(t,s){var i=t[s],h=i.children.length,n=this._minEntries;this._chooseSplitAxis(i,n,h);var r=this._chooseSplitIndex(i,n,h),e=V(i.children.splice(r,i.children.length-r));e.height=i.height,e.leaf=i.leaf,B(i,this.toBBox),B(e,this.toBBox),s?t[s-1].children.push(e):this._splitRoot(i,e)},_splitRoot:function(t,s){this.data=V([t,s]),this.data.height=t.height+1,this.data.leaf=!1,B(this.data,this.toBBox)},_chooseSplitIndex:function(t,s,i){var h,n,r,e,o,a,u,c;for(a=u=1/0,h=s;h<=i-s;h++)e=E(n=j(t,0,h,this.toBBox),r=j(t,h,i,this.toBBox)),o=N(n)+N(r),e<a?(a=e,c=h,u=o<u?o:u):e===a&&o<u&&(u=o,c=h);return c},_chooseSplitAxis:function(t,s,i){var h=t.leaf?this.compareMinX:O,n=t.leaf?this.compareMinY:z;this._allDistMargin(t,s,i,h)<this._allDistMargin(t,s,i,n)&&t.children.sort(h)},_allDistMargin:function(t,s,i,h){t.children.sort(h);var n,r,e=this.toBBox,o=j(t,0,s,e),a=j(t,i-s,i,e),u=k(o)+k(a);for(n=s;n<i-s;n++)r=t.children[n],P(o,t.leaf?e(r):r),u+=k(o);for(n=i-s-1;n>=s;n--)r=t.children[n],P(a,t.leaf?e(r):r),u+=k(a);return u},_adjustParentBBoxes:function(t,s,i){for(var h=i;h>=0;h--)P(s[h],t)},_condense:function(t){for(var s,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(s=t[i-1].children).splice(s.indexOf(t[i]),1):this.clear():B(t[i],this.toBBox)},_initFormat:function(t){var s=["return a"," - b",";"];this.compareMinX=new Function("a","b",s.join(t[0])),this.compareMinY=new Function("a","b",s.join(t[1])),this.toBBox=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}};class q{constructor(t,s){this.key=new g(0,0,0,0),this.bounds=c(),this.objectIds=new Set,this.key.set(s);const i=t.getLODInfoAt(this.key);this.tileInfoView=t,this.tileInfoView.getTileBounds(this.bounds,this.key,!0),this.resolution=i.resolution,this.scale=i.scale,this.level=i.level}get id(){return this.key.id}get extent(){return l.fromBounds(this.bounds,this.tileInfoView.tileInfo.spatialReference)}get transform(){return{originPosition:"upperLeft",scale:[this.resolution,this.resolution],translate:[this.bounds[0],this.bounds[3]]}}createChildTiles(){const t=this.key.getChildKeys(),s=f.acquire();for(let i=0;i<t.length;i++)s[i]=new q(this.tileInfoView,t[i]);return s}getQuantizationParameters(){return M.fromJSON({mode:"view",originPosition:"upperLeft",tolerance:this.resolution,extent:{xmin:this.bounds[0],ymin:this.bounds[1],xmax:this.bounds[2],ymax:this.bounds[3],spatialReference:this.tileInfoView.tileInfo.spatialReference}})}}const G={added:[],removed:[]},Q=new Set,U=new g(0,0,0,0);class H extends m{constructor(t){super(),this._tiles=new Map,this._index=L(9,d("esri-csp-restrictions")?t=>({minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]}):[".bounds[0]",".bounds[1]",".bounds[2]",".bounds[3]"]),this.tiles=[],this.tileScheme=t}destroy(){this.clear()}clear(){this.tiles.length=0,this._tiles.clear(),this._index.clear()}has(t){return this._tiles.has(t)}get(t){return this._tiles.get(t)}boundsIntersections(t){return this._index.search({minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]})}updateTiles(t){const s={added:[],removed:[]};for(const i of t.added)if(!this.has(i)){const t=new q(this.tileScheme,i);this._tiles.set(i,t),this._index.insert(t),s.added.push(t)}for(const i of t.removed)if(this.has(i)){const t=this.get(i);this._tiles.delete(i),this._index.remove(t),s.removed.push(t)}this.tiles.length=0,this._tiles.forEach((t=>this.tiles.push(t))),(s.added.length||s.removed.length)&&this.emit("update",s)}setViewState(t){const s=this.tileScheme.getTileCoverage(t,0);if(!s)return;const{spans:i,lodInfo:h}=s,{level:n}=h;if(i.length>0)for(const{row:t,colFrom:s,colTo:r}of i)for(let i=s;i<=r;i++){const s=U.set(n,t,h.normalizeCol(i),h.getWorldForColumn(i)).id;if(Q.add(s),!this.has(s)){const t=new q(this.tileScheme,s);this._tiles.set(s,t),this._index.insert(t),this.tiles.push(t),G.added.push(t)}}for(let t=this.tiles.length-1;t>=0;t--){const s=this.tiles[t];Q.has(s.id)||(this._tiles.delete(s.id),this.tiles.splice(t,1),this._index.remove(s),G.removed.push(s))}(G.added.length||G.removed.length)&&this.emit("update",G),C.pool.release(s),Q.clear(),G.added.length=0,G.removed.length=0}}export{H as d,R as h,L as i,C as l,v as u};
//# sourceMappingURL=p-cd4a8b9a.js.map