import{cH as t,bJ as e,l as s,y as a,n as r,_ as n,bC as i,h as o,e as u,R as c,cI as l,cv as d,aT as h,aV as p,K as y,cr as f,s as m,aX as w,cJ as b,cK as g,cL as I,aK as F,cM as q,cN as S,b as j,aU as A,M as E,ab as R,k as x}from"./p-b54724b6.js";import{r as O}from"./p-8043ab9b.js";import{e as v}from"./p-cc24e5bd.js";import{m as _}from"./p-728b50df.js";import{r as J}from"./p-1cec84d0.js";import{A as N}from"./p-8a927e72.js";import{isFeatureIdentifierArrayWithGlobalId as T,isFeatureIdentifierArrayWithObjectId as C}from"./p-c3d1eaf6.js";import{o as M}from"./p-5525ea5e.js";import{x as P}from"./p-ac0dfd7c.js";import{m as $}from"./p-5abe9c67.js";import{s as D}from"./p-0856fe30.js";import"./p-a5e3ec2a.js";import"./p-80be55a5.js";import"./p-1b4a7439.js";import"./p-d77465bf.js";import"./p-b88ddb1e.js";import"./p-8dc3148c.js";import"./p-ca5fb53c.js";import"./p-e6a64715.js";import"./p-dc29c329.js";import"./p-d7fc78fa.js";import"./p-a3f0a5f3.js";function k(e){const{vertexSpace:s}=e;if(s.isRelative)return e.clone();const{anchor:a}=e,r=a.clone(),n=t(G,[-r.x,-r.y,-r.z]),i=new _({origin:[r.x,r.y,r.z]}),o=e.cloneWithVertexSpace(i),{position:u}=o.vertexAttributes;return o.vertexAttributes.position=J(new Float64Array(u.length),u,n),o.vertexAttributesChanged(),o}const G=v();const U=new e({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),V=new Set(["Feature Layer","Oriented Imagery Layer","Table"]),L=new e({Started:"published",Publishing:"publishing",Stopped:"unavailable"});let H=class extends n{constructor(){super(...arguments),this.type="feature-layer",this.refresh=i((async()=>{await this.load();const t=this.sourceJSON.editingInfo?.lastEditDate;if(null==t)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}const e=t!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:e,updates:e?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}})),this._ongoingAssetUploads=new Map}load(t){const e=null!=t?t.signal:null,s=this.layer.sourceJSON;return this.addResolvingPromise(this._fetchService(s,e)),Promise.resolve(this)}get queryTask(){const{capabilities:t,parsedUrl:e,dynamicDataSource:s,infoFor3D:a,gdbVersion:r,spatialReference:n,fieldsIndex:i}=this.layer,u=o("featurelayer-pbf")&&t?.query.supportsFormatPBF&&null==a,c=t?.operations?.supportsQueryAttachments??!1;return new P({url:e.path,pbfSupported:u,fieldsIndex:i,infoFor3D:a,dynamicDataSource:s,gdbVersion:r,sourceSpatialReference:n,queryAttachmentsSupported:c})}async addAttachment(t,e){await this.load();const s=t.attributes[this.layer.objectIdField],a=this.layer.parsedUrl.path+"/"+s+"/addAttachment",r=this._getLayerRequestOptions(),n=this._getFormDataForAttachment(e,r.query);try{const t=await u(a,{body:n});return this._createFeatureEditResult(t.data.addAttachmentResult)}catch(t){throw this._createAttachmentErrorResult(s,t)}}async updateAttachment(t,e,s){await this.load();const a=t.attributes[this.layer.objectIdField],r=this.layer.parsedUrl.path+"/"+a+"/updateAttachment",n=this._getLayerRequestOptions({query:{attachmentId:e}}),i=this._getFormDataForAttachment(s,n.query);try{const t=await u(r,{body:i});return this._createFeatureEditResult(t.data.updateAttachmentResult)}catch(t){throw this._createAttachmentErrorResult(a,t)}}async applyEdits(t,e){await this.load();const{layer:s}=this,a=s.infoFor3D,r=null!=a,n=r||(e?.globalIdUsed??!1),i=r?await this._uploadMeshesAndGetAssetMapEditsJSON(t):null,o=t.addFeatures?.map((t=>this._getFeatureJSON(t,a)))??[],h=(await Promise.all(o)).filter(c),p=t.updateFeatures?.map((t=>this._getFeatureJSON(t,a)))??[],y=(await Promise.all(p)).filter(c),f=this._getFeatureIds(t.deleteFeatures,n);l(h,y,s.spatialReference);const m=await this._getAttachmentEditsJSON(t),w=s.capabilities.editing.supportsAsyncApplyEdits&&r,b={gdbVersion:e?.gdbVersion||s.gdbVersion,rollbackOnFailure:e?.rollbackOnFailureEnabled,useGlobalIds:n,returnEditMoment:e?.returnEditMoment,usePreviousEditMoment:e?.usePreviousEditMoment,sessionId:e?.sessionId,async:w};e?.returnServiceEditsOption?(b.edits=JSON.stringify([{id:s.layerId,adds:h,updates:y,deletes:f,attachments:m,assetMaps:i}]),b.returnServiceEditsOption=U.toJSON(e?.returnServiceEditsOption),b.returnServiceEditsInSourceSR=e?.returnServiceEditsInSourceSR):(b.adds=h.length?JSON.stringify(h):null,b.updates=y.length?JSON.stringify(y):null,b.deletes=f.length?n?JSON.stringify(f):f.join(","):null,b.attachments=m&&JSON.stringify(m),b.assetMaps=null!=i?JSON.stringify(i):void 0);const g=this._getLayerRequestOptions({method:"post",query:b}),I=e?.returnServiceEditsOption?s.url:s.parsedUrl.path,F=w?await this._asyncApplyEdits(I+"/applyEdits",g):await u(I+"/applyEdits",g);if(!s.capabilities.operations?.supportsEditing&&s.effectiveCapabilities?.operations?.supportsEditing){const t=d?.findCredential(s.url);await(t?.refreshToken())}return this._createEditsResult(F)}async deleteAttachments(t,e){await this.load();const s=t.attributes[this.layer.objectIdField],a=this.layer.parsedUrl.path+"/"+s+"/deleteAttachments";try{return(await u(a,this._getLayerRequestOptions({query:{attachmentIds:e.join(",")},method:"post"}))).data.deleteAttachmentResults.map(this._createFeatureEditResult)}catch(t){throw this._createAttachmentErrorResult(s,t)}}fetchRecomputedExtents(t={}){const e=t.signal;return this.load({signal:e}).then((async()=>{const e=this._getLayerRequestOptions({...t,query:{returnUpdates:!0}}),{layerId:s,url:a}=this.layer,{data:r}=await u(`${a}/${s}`,e),{id:n,extent:i,fullExtent:o,timeExtent:c}=r,l=i||o;return{id:n,fullExtent:l&&h.fromJSON(l),timeExtent:c&&p.fromJSON({start:c[0],end:c[1]})}}))}async queryAttachments(t,e={}){await this.load();const s=this._getLayerRequestOptions(e);return this.queryTask.executeAttachmentQuery(t,s)}async queryFeatures(t,e){return await this.load(),this.queryTask.execute(t,{...e,query:this._createRequestQueryOptions(e)})}async queryFeaturesJSON(t,e){return await this.load(),this.queryTask.executeJSON(t,{...e,query:this._createRequestQueryOptions(e)})}async queryObjectIds(t,e){return await this.load(),this.queryTask.executeForIds(t,{...e,query:this._createRequestQueryOptions(e)})}async queryFeatureCount(t,e){return await this.load(),this.queryTask.executeForCount(t,{...e,query:this._createRequestQueryOptions(e)})}async queryExtent(t,e){return await this.load(),this.queryTask.executeForExtent(t,{...e,query:this._createRequestQueryOptions(e)})}async queryRelatedFeatures(t,e){return await this.load(),this.queryTask.executeRelationshipQuery(t,{...e,query:this._createRequestQueryOptions(e)})}async queryRelatedFeaturesCount(t,e){return await this.load(),this.queryTask.executeRelationshipQueryForCount(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopFeatures(t,e){return await this.load(),this.queryTask.executeTopFeaturesQuery(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopObjectIds(t,e){return await this.load(),this.queryTask.executeForTopIds(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopExtents(t,e){return await this.load(),this.queryTask.executeForTopExtents(t,{...e,query:this._createRequestQueryOptions(e)})}async queryTopCount(t,e){return await this.load(),this.queryTask.executeForTopCount(t,{...e,query:this._createRequestQueryOptions(e)})}async fetchPublishingStatus(){if(!y(this.layer.url))return"unavailable";const t=f(this.layer.url,"status"),e=await u(t,{query:{f:"json"}});return L.fromJSON(e.data.status)}async uploadAssets(t,e){const{uploadAssets:s}=await import("./p-9b33926f.js");return s(t,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},e)}async _asyncApplyEdits(t,e){const s=(await u(t,e)).data.statusUrl;for(;;){const t=(await u(s,{query:{f:"json"},responseType:"json"})).data;switch(t.status){case"Completed":return u(t.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new m("async-applyEdits-failed","asynchronous applyEdits call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new m("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)")}await w(K)}}_createRequestQueryOptions(t){const e={...this.layer.customParameters,token:this.layer.apiKey,...t?.query};return this.layer.datesInUnknownTimezone&&(e.timeReferenceUnknownClient=!0),e}async _fetchService(t,e){if(!t){const{data:s}=await u(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:o("featurelayer-advanced-symbols")?{returnAdvancedSymbols:!0}:{},signal:e}));t=s}this.sourceJSON=await this._patchServiceJSON(t,e);const s=t.type;if(!V.has(s))throw new m("feature-layer-source:unsupported-type",`Source type "${s}" is not supported`)}async _patchServiceJSON(t,e){if("Table"!==t.type&&t.geometryType&&!t?.drawingInfo?.renderer&&!t.defaultSymbol){const e=M(t.geometryType).renderer;b("drawingInfo.renderer",e,t)}if("esriGeometryMultiPatch"===t.geometryType&&t.infoFor3D&&(t.geometryType="mesh"),null==t.extent)try{const{data:s}=await u(this.layer.url,this._getLayerRequestOptions({signal:e}));s.spatialReference&&(t.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:s.spatialReference})}catch(t){g(t)}return t}async _getFeatureJSON(t,e){const{geometry:s}=t,a={...t.attributes};if(null!=e&&"mesh"===s?.type){const{transformFieldRoles:t}=e,{origin:r,spatialReference:n,transform:i}=s,o=this.layer.spatialReference;await I(n,o);const u=F(r,o);if(a[t.originX]=u.x,a[t.originY]=u.y,a[t.originZ]=u.z??0,null!=i){const{translation:e,scale:r,rotation:u}=i,{vertexSpace:c}=s,l=c.isGeoreferenced?1:q(n)/q(o);a[t.translationX]=e[0]*l,a[t.translationY]=-e[2]*l,a[t.translationZ]=e[1]*l,a[t.scaleX]=r[0],a[t.scaleY]=r[2],a[t.scaleZ]=r[1],a[t.rotationX]=u[0],a[t.rotationY]=u[2],a[t.rotationZ]=u[1],a[t.rotationDeg]=u[3]}return{geometry:null,attributes:a}}return null==s?{attributes:a}:"mesh"===s.type||"extent"===s.type?null:{geometry:s.toJSON(),attributes:a}}async _getAttachmentEditsJSON(t){const e=await Promise.all((t.addAttachments??[]).map((t=>this._getAttachmentEditJSON(t)))),s=await Promise.all((t.updateAttachments??[]).map((t=>this._getAttachmentEditJSON(t)))),a=t.deleteAttachments??[];return e.length||s.length||a.length?{adds:e,updates:s,deletes:[...a]}:null}async _getAttachmentEditJSON(t){const{feature:e,attachment:s}=t,{globalId:a,name:r,contentType:n,data:i,uploadId:o}=s,u={globalId:a,parentGlobalId:null,contentType:null,name:null,uploadId:null,data:null};if(e&&(u.parentGlobalId="attributes"in e?e.attributes&&e.attributes[this.layer.globalIdField]:e.globalId),o)u.uploadId=o;else if(i){const t=await S(i);t&&(u.contentType=t.mediaType,u.data=t.data),i instanceof File&&(u.name=i.name)}return r&&(u.name=r),n&&(u.contentType=n),u}async _uploadMeshesAndGetAssetMapEditsJSON(t){const{addAssetFeatures:e}=t;if(!e?.length)return null;const s=await this._filterRedundantAssetMaps(e);if(!e?.length)return null;const a=new Array,r=new Map;for(const t of s){const{geometry:e}=t,{vertexSpace:s}=e;if(s.isRelative)a.push(e);else{const s=k(e);r.set(s,e),t.geometry=s,a.push(s)}}await this.uploadAssets(a);for(const[t,e]of r)e.addExternalSources(t.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(s),updates:[],deletes:[]}}_getAssetMapEditsJSON(t){const e=new Array,s=this.layer.globalIdField,a=this.layer.parsedUrl;for(const r of t){const t=r.geometry,{metadata:n}=t,i=n.getExternalSourcesOnService(a),o=r.getAttribute(s);if(0===i.length){j.getLogger(this).error(`Skipping feature ${o}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}const{source:u}=i.find(N)??i[0],{vertexSpace:c}=t,l=c.isGeoreferenced?["PROJECT_VERTICES"]:[];for(const t of u)1===t.parts.length?e.push({globalId:O(),parentGlobalId:o,assetName:t.assetName,assetHash:t.parts[0].partHash,flags:l}):j.getLogger(this).error(`Skipping asset ${t.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return e}_getFeatureIds(t,e){if(!t||0===t.length)return[];if(e&&T(t))return t.map((t=>t.globalId));if(C(t))return t.map((t=>t.objectId));const{layer:s}=this,a=e?s.globalIdField:s.objectIdField;return a?t.map((t=>t.getAttribute(a))):[]}_createEditsResult(t){const e=t.data,{layerId:s}=this.layer,a=[];let r=null;if(Array.isArray(e))for(const t of e)a.push({id:t.id,editedFeatures:t.editedFeatures}),t.id===s&&(r={addResults:t.addResults??[],updateResults:t.updateResults??[],deleteResults:t.deleteResults??[],attachments:t.attachments,editMoment:t.editMoment});else r=e;const n=r?.assetMaps;if(n){for(const t of n.addResults)t.success||j.getLogger(this).error(`Failed to map asset to feature with globalId ${t.globalId}.`);for(const t of n.updateResults)t.success||j.getLogger(this).error(`Failed to map asset to feature with globalId ${t.globalId}.`)}const i=r?.attachments,o={addFeatureResults:r?.addResults?.map(this._createFeatureEditResult,this)??[],updateFeatureResults:r?.updateResults?.map(this._createFeatureEditResult,this)??[],deleteFeatureResults:r?.deleteResults?.map(this._createFeatureEditResult,this)??[],addAttachmentResults:i&&i.addResults?i.addResults.map(this._createFeatureEditResult,this):[],updateAttachmentResults:i&&i.updateResults?i.updateResults.map(this._createFeatureEditResult,this):[],deleteAttachmentResults:i&&i.deleteResults?i.deleteResults.map(this._createFeatureEditResult,this):[]};if(r?.editMoment&&(o.editMoment=r.editMoment),a.length>0){o.editedFeatureResults=[];for(const t of a){const{editedFeatures:e}=t,s=e?.spatialReference?new A(e.spatialReference):null;o.editedFeatureResults.push({layerId:t.id,editedFeatures:{adds:e?.adds?.map((t=>this._createEditedFeature(t,s)))||[],updates:e?.updates?.map((t=>({original:this._createEditedFeature(t[0],s),current:this._createEditedFeature(t[1],s)})))||[],deletes:e?.deletes?.map((t=>this._createEditedFeature(t,s)))||[],spatialReference:s}})}}return o}_createEditedFeature(t,e){return new E({attributes:t.attributes,geometry:R({...t.geometry,spatialReference:e})})}_createFeatureEditResult(t){const e=!0===t.success?null:t.error||{code:void 0,description:void 0};return{objectId:t.objectId,globalId:t.globalId,error:e?new m("feature-layer-source:edit-failure",e.description,{code:e.code}):null}}_createAttachmentErrorResult(t,e){const s=e.details.messages&&e.details.messages[0]||e.message,a=e.details.httpStatus||e.details.messageCode;return{objectId:t,globalId:null,error:new m("feature-layer-source:attachment-failure",s,{code:a})}}_getFormDataForAttachment(t,e){const s=t instanceof FormData?t:t&&t.elements?new FormData(t):null;if(s)for(const t in e){const a=e[t];null!=a&&(s.set?s.set(t,a):s.append(t,a))}return s}_getLayerRequestOptions(t={}){const{parsedUrl:e,gdbVersion:s,dynamicDataSource:a}=this.layer;return{...t,query:{gdbVersion:s,layer:a?JSON.stringify({source:a}):void 0,...e.query,f:"json",...this._createRequestQueryOptions(t)},responseType:"json"}}async _filterRedundantAssetMaps(t){const{layer:e}=this,{globalIdField:s,infoFor3D:a,parsedUrl:r}=e;if(null==a||null==s)return t;const n=$(a);if(null==n)return t;const i=f(r.path,`../${n.id}`),o=new Array,u=new Array;for(const e of t)e.geometry.metadata.getExternalSourcesOnService(r).length>0?u.push(e):o.push(e);const l=u.map((t=>t.getAttribute(s))).filter(c);if(0===l.length)return t;const{assetMapFieldRoles:{parentGlobalId:d,assetHash:h}}=a,p=new x;p.where=`${d} IN (${l.map((t=>`'${t}'`))})`,p.outFields=[h,d],p.returnGeometry=!1;const y=await D(i,p),{features:m}=y;return 0===m.length?t:[...o,...u.filter((t=>{const e=t.getAttribute(s);if(!e)return!0;const{metadata:a}=t.geometry,n=m.filter((t=>t.getAttribute(d)===e));if(0===n.length)return!0;const i=n.map((t=>t.getAttribute(h)));return a.getExternalSourcesOnService(r).flatMap((({source:t})=>t.flatMap((t=>t.parts.map((t=>t.partHash)))))).some((t=>i.every((e=>t!==e))))}))]}};s([a()],H.prototype,"type",void 0),s([a({constructOnly:!0})],H.prototype,"layer",void 0),s([a({readOnly:!0})],H.prototype,"queryTask",null),H=s([r("esri.layers.graphics.sources.FeatureLayerSource")],H);const K=1e3,W=H;export default W;
//# sourceMappingURL=p-848e63b2.js.map