import{h as t}from"./p-b54724b6.js";import{h as r}from"./p-fd8dc94a.js";import{T as e}from"./p-3800516a.js";import"./p-9a4094ba.js";import"./p-9f1a0adc.js";import"./p-de65f975.js";import"./p-cc24e5bd.js";import"./p-52a9dec5.js";import"./p-2563414c.js";import"./p-4f2ece68.js";import"./p-728b50df.js";import"./p-cc3f40fb.js";import"./p-603bf978.js";import"./p-1cec84d0.js";import"./p-76eeb521.js";import"./p-74887bd8.js";class n{async createIndex(t,e){const n=new Array;if(!t.vertexAttributes||!t.vertexAttributes.position)return new r;const o=this._createMeshData(t),s=null!=e?await e.invoke("createIndexThread",o,{transferList:n}):this.createIndexThread(o).result;return this._createPooledRBush().fromJSON(s)}createIndexThread(t){const r=new Float64Array(t.position),e=this._createPooledRBush();return t.components?this._createIndexComponentsThread(e,r,t.components.map((t=>new Uint32Array(t)))):this._createIndexAllThread(e,r)}_createIndexAllThread(t,r){const e=new Array(r.length/9);let n=0;for(let t=0;t<r.length;t+=9)e[n++]=o(r,t,t+3,t+6);return t.load(e),{result:t.toJSON()}}_createIndexComponentsThread(t,r,e){let n=0;for(const t of e)n+=t.length/3;const s=new Array(n);let a=0;for(const t of e)for(let e=0;e<t.length;e+=3)s[a++]=o(r,3*t[e],3*t[e+1],3*t[e+2]);return t.load(s),{result:t.toJSON()}}_createMeshData(t){const r=(t.vertexSpace.isRelative?e({position:t.vertexAttributes.position,normal:null,tangent:null},t.vertexSpace,t.transform,t.spatialReference).position:t.vertexAttributes.position).buffer;return!t.components||t.components.some((t=>!t.faces))?{position:r}:{position:r,components:t.components.map((t=>t.faces))}}_createPooledRBush(){return new r(9,t("esri-csp-restrictions")?t=>t:[".minX",".minY",".maxX",".maxY"])}}function o(t,r,e,n){return{minX:Math.min(t[r],t[e],t[n]),maxX:Math.max(t[r],t[e],t[n]),minY:Math.min(t[r+1],t[e+1],t[n+1]),maxY:Math.max(t[r+1],t[e+1],t[n+1]),p0:[t[r],t[r+1],t[r+2]],p1:[t[e],t[e+1],t[e+2]],p2:[t[n],t[n+1],t[n+2]]}}export default n;
//# sourceMappingURL=p-fec6d1fe.js.map