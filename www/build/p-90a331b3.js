import{aT as t,a6 as r,fm as s}from"./p-b54724b6.js";import{u as e,f as n,W as a,U as i,R as o,I as l,a as c,s as m}from"./p-f7376ac9.js";import{m as u,j as p,L as f,h as d}from"./p-1bd9b819.js";import{_ as h,i as y}from"./p-7d91e4a1.js";import{d as x,k as j,$ as w}from"./p-22a6b5ef.js";import"./p-9f1a0adc.js";import"./p-7833a3a9.js";import"./p-6cd106e8.js";class P{convertVectorFieldData(t){const r=e.fromJSON(t.pixelBlock),s=n(r,t.type);return Promise.resolve(null!=s?s.toJSON():null)}computeStatisticsHistograms(t){const r=e.fromJSON(t.pixelBlock),s=u(r);return Promise.resolve(s)}async decode(t){const r=await p(t.data,t.options);return r&&r.toJSON()}symbolize(r){r.pixelBlock=e.fromJSON(r.pixelBlock),r.extent=r.extent?t.fromJSON(r.extent):null;const s=this.symbolizer.symbolize(r);return Promise.resolve(null!=s?s.toJSON():null)}async updateSymbolizer(t){this.symbolizer=f.fromJSON(t.symbolizerJSON),t.histograms&&"rasterStretch"===this.symbolizer?.rendererJSON.type&&(this.symbolizer.rendererJSON.histograms=t.histograms)}async updateRasterFunction(t){this.rasterFunction=h(t.rasterFunctionJSON)}async process(s){const n=this.rasterFunction.process({extent:t.fromJSON(s.extent),primaryPixelBlocks:s.primaryPixelBlocks.map((t=>null!=t?e.fromJSON(t):null)),primaryPixelSizes:s.primaryPixelSizes?.map((t=>null!=t?r.fromJSON(t):null)),primaryRasterIds:s.primaryRasterIds});return null!=n?n.toJSON():null}stretch(t){const r=this.symbolizer.simpleStretch(e.fromJSON(t.srcPixelBlock),t.stretchParams);return Promise.resolve(null!=r&&r.toJSON())}estimateStatisticsHistograms(t){const r=d(e.fromJSON(t.srcPixelBlock));return Promise.resolve(r)}split(t){const r=a(e.fromJSON(t.srcPixelBlock),t.tileSize,t.maximumPyramidLevel);return r&&r.forEach(((t,s)=>{r.set(s,t?.toJSON())})),Promise.resolve(r)}async mosaicAndTransform(t){const r=t.srcPixelBlocks.map((t=>t?new e(t):null)),s=i(r,t.srcMosaicSize,{blockWidths:t.blockWidths,alignmentInfo:t.alignmentInfo,clipOffset:t.clipOffset,clipSize:t.clipSize});let n,a=s;return t.coefs&&(a=o(s,t.destDimension,t.coefs,t.sampleSpacing,t.interpolation)),t.projectDirections&&t.gcsGrid&&(n=l(t.destDimension,t.gcsGrid),a=c(a,t.isUV?"vector-uv":"vector-magdir",n)),{pixelBlock:a?.toJSON(),localNorthDirections:n}}async createFlowMesh(t,r){const s={data:new Float32Array(t.flowData.buffer),mask:new Uint8Array(t.flowData.maskBuffer),width:t.flowData.width,height:t.flowData.height},{vertexData:e,indexData:n}=await m(t.meshType,t.simulationSettings,s,r.signal);return{result:{vertexBuffer:e.buffer,indexBuffer:n.buffer},transferList:[e.buffer,n.buffer]}}async getProjectionOffsetGrid(r){const e=t.fromJSON(r.projectedExtent),n=t.fromJSON(r.srcBufferExtent);let a=null;r.datumTransformationSteps&&(a=new s({steps:r.datumTransformationSteps})),(r.includeGCSGrid||x(e.spatialReference,n.spatialReference,a))&&await j();const i=r.rasterTransform?y(r.rasterTransform):null;return w({...r,projectedExtent:e,srcBufferExtent:n,datumTransformation:a,rasterTransform:i})}}export default P;
//# sourceMappingURL=p-90a331b3.js.map