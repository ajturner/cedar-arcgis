import{bP as t,U as e,ab as n,cc as o,e as s,cd as r,b as i,b7 as c,ce as f,bf as u,cf as l,b2 as a,s as y,c as p}from"./p-b54724b6.js";import{s as g,o as m,r as b,i as d}from"./p-80be55a5.js";function h(t,e){return e?{...e,query:{...t??{},...e.query}}:{query:t}}function w(n){return"string"==typeof n?t(n):e(n)}function N(t,e,n){const o={};for(const s in t){if("declaredClass"===s)continue;const r=t[s];if(null!=r&&"function"!=typeof r)if(Array.isArray(r)){o[s]=[];for(let t=0;t<r.length;t++)o[s][t]=N(r[t])}else if("object"==typeof r)if(r.toJSON){const t=r.toJSON(n&&n[s]);o[s]=e?t:JSON.stringify(t)}else o[s]=e?r:JSON.stringify(r);else o[s]=r}return o}async function J(t,e,r,i){const c=w(t),f=e[0].spatialReference,u={...i,query:{...c.query,f:"json",sr:JSON.stringify(f),target:JSON.stringify({geometryType:o(e[0]),geometries:e}),cutter:JSON.stringify(r)}},l=await s(c.path+"/cut",u),{cutIndexes:a,geometries:y=[]}=l.data;return{cutIndexes:a,geometries:y.map((t=>{const e=n(t);return e.spatialReference=f,e}))}}function O(t){return{geometryType:o(t[0]),geometries:t.map((t=>t.toJSON()))}}function S(t,e,n){const o=r(e);return t.map((t=>{const e=o.fromJSON(t);return e.spatialReference=n,e}))}async function j(e,n,r){const i="string"==typeof e?t(e):e,c=n[0].spatialReference,f=o(n[0]),u={...r,query:{...i.query,f:"json",sr:c.wkid??JSON.stringify(c),geometries:JSON.stringify(O(n))}},{data:l}=await s(i.path+"/simplify",u);return S(l.geometries,f,c)}const q=i.getLogger("esri.geometry.support.normalizeUtils");function x(t){return"polygon"===t.type}function A(t){return"polygon"===t[0].type}function M(t){return"polyline"===t[0].type}function T(t,e){if(!(t instanceof f||t instanceof c)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw q.error(t),new y(t)}const n=m(t),o=[];for(const t of n){const n=[];o.push(n),n.push([t[0][0],t[0][1]]);for(let o=0;o<t.length-1;o++){const s=t[o][0],r=t[o][1],i=t[o+1][0],c=t[o+1][1],f=Math.sqrt((i-s)*(i-s)+(c-r)*(c-r)),u=(c-r)/f,l=(i-s)/f,a=f/e;if(a>1){for(let t=1;t<=a-1;t++){const o=t*e,i=l*o+s,c=u*o+r;n.push([i,c])}const t=(f+Math.floor(a-1)*e)/2,o=l*t+s,i=u*t+r;n.push([o,i])}n.push([i,c])}}return x(t)?new c({rings:o,spatialReference:t.spatialReference}):new f({paths:o,spatialReference:t.spatialReference})}function z(t,e,n){if(e){const e=T(t,1e6);t=l(e,!0)}return n&&(t=g(t,n)),t}function C(t,e,n){if(Array.isArray(t)){const o=t[0];if(o>e){const n=d(o,e);t[0]=o+n*(-2*e)}else if(o<n){const e=d(o,n);t[0]=o+e*(-2*n)}}else{const o=t.x;if(o>e){const n=d(o,e);t=t.clone().offset(n*(-2*e),0)}else if(o<n){const e=d(o,n);t=t.clone().offset(e*(-2*n),0)}}return t}function I(t,e){let n=-1;for(let o=0;o<e.cutIndexes.length;o++){const s=e.cutIndexes[o],r=e.geometries[o],i=m(r);for(let t=0;t<i.length;t++){const e=i[t];e.some((n=>{if(n[0]<180)return!0;{let n=0;for(let t=0;t<e.length;t++){const o=e[t][0];n=o>n?o:n}n=Number(n.toFixed(9));const o=-360*d(n,180);for(let n=0;n<e.length;n++){const e=r.getPoint(t,n);r.setPoint(t,n,e.clone().offset(o,0))}return!0}}))}if(s===n){if(A(t))for(const e of m(r))t[s]=t[s].addRing(e);else if(M(t))for(const e of m(r))t[s]=t[s].addPath(e)}else n=s,t[s]=r}return t}async function R(t,e,n){if(!Array.isArray(t))return R([t],e);e&&"string"!=typeof e&&q.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const o="string"==typeof e?e:e?.url??p.geometryServiceUrl;let s,r,i,l,y,m,h,w,N=0;const O=[],S=[];for(const e of t)if(null!=e)if(s||(s=e.spatialReference,r=a(s),i=s.isWebMercator,m=i?102100:4326,l=b[m].maxX,y=b[m].minX,h=b[m].plus180Line,w=b[m].minus180Line),r)if("mesh"===e.type)S.push(e);else if("point"===e.type)S.push(C(e.clone(),l,y));else if("multipoint"===e.type){const t=e.clone();t.points=t.points.map((t=>C(t,l,y))),S.push(t)}else if("extent"===e.type){const t=e.clone()._normalize(!1,!1,r);S.push(t.rings?new c(t):t)}else if(e.extent){const t=e.extent,n=d(t.xmin,y)*(2*l);let o=0===n?e.clone():g(e.clone(),n);t.offset(n,0),t.intersects(h)&&t.xmax!==l?(N=t.xmax>N?t.xmax:N,o=z(o,i),O.push(o),S.push("cut")):t.intersects(w)&&t.xmin!==y?(N=t.xmax*(2*l)>N?t.xmax*(2*l):N,o=z(o,i,360),O.push(o),S.push("cut")):S.push(o)}else S.push(e.clone());else S.push(e);else S.push(e);let x=d(N,l),A=-90;const M=x,T=new f;for(;x>0;){const t=360*x-180;T.addPath([[t,A],[t,-1*A]]),A*=-1,x--}if(O.length>0&&M>0){const e=I(O,await J(o,O,T,n)),s=[],r=[];for(let n=0;n<S.length;n++){const o=S[n];if("cut"!==o)r.push(o);else{const o=e.shift(),c=t[n];null!=c&&"polygon"===c.type&&c.rings&&c.rings.length>1&&o.rings.length>=c.rings.length?(s.push(o),r.push("simplify")):r.push(i?u(o):o)}}if(!s.length)return r;const c=await j(o,s,n),f=[];for(let t=0;t<r.length;t++){const e=r[t];"simplify"!==e?f.push(e):f.push(i?u(c.shift()):c.shift())}return f}const U=[];for(let t=0;t<S.length;t++){const e=S[t];if("cut"!==e)U.push(e);else{const t=O.shift();U.push(!0===i?u(t):t)}}return U}function U(t,e){const n=a(e);if(n){const[e,o]=n.valid,s=o-e;if(t<e)for(;t<e;)t+=s;if(t>o)for(;t>o;)t-=s}return t}export{R as b,w as f,h as i,S as o,N as s,U as v};
//# sourceMappingURL=p-a5e3ec2a.js.map