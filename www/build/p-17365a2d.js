import{ag as t,eX as s,F as e,aN as i,Q as n}from"./p-b54724b6.js";import{E as o,I as r}from"./p-8a4ae095.js";import{t as c,n as h,h as a,e as l,i as f,f as u,r as d,a as p,N as w,b as m,c as b,_ as M}from"./p-6bb7b693.js";import{t as y}from"./p-de65627f.js";import{o as g}from"./p-42c332a2.js";import{l as x,m as k,o as I,p as _,n as T,u as A,a as L}from"./p-4f76b2d1.js";import{n as N}from"./p-ca5fb53c.js";import{r as v,c as j,i as D}from"./p-873e8cec.js";import{t as P,T as S,m as F,l as B}from"./p-17a45052.js";import{i as C}from"./p-38e70926.js";import{C as U}from"./p-50b034e8.js";import"./p-0e94eaa4.js";import"./p-570a8a46.js";import"./p-13e550f5.js";import"./p-795f7c81.js";import"./p-7833a3a9.js";import"./p-f5f26b1f.js";import"./p-9f1a0adc.js";function R(t){return 746===t||747===t||!(t<4352)&&(t>=12704&&t<=12735||(t>=12544&&t<=12591||(t>=65072&&t<=65103&&!(t>=65097&&t<=65103)||(t>=63744&&t<=64255||(t>=13056&&t<=13311||(t>=11904&&t<=12031||(t>=12736&&t<=12783||(t>=12288&&t<=12351&&!(t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||(t>=13312&&t<=19903||(t>=19968&&t<=40959||(t>=12800&&t<=13055||(t>=12592&&t<=12687||(t>=43360&&t<=43391||(t>=55216&&t<=55295||(t>=4352&&t<=4607||(t>=44032&&t<=55215||(t>=12352&&t<=12447||(t>=12272&&t<=12287||(t>=12688&&t<=12703||(t>=12032&&t<=12255||(t>=12784&&t<=12799||(t>=12448&&t<=12543&&12540!==t||(t>=65280&&t<=65519&&!(65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||(t>=65104&&t<=65135&&!(t>=65112&&t<=65118||t>=65123&&t<=65126)||(t>=5120&&t<=5759||(t>=6320&&t<=6399||(t>=65040&&t<=65055||(t>=19904&&t<=19967||(t>=40960&&t<=42127||t>=42128&&t<=42191)))))))))))))))))))))))))))))}function O(t){return!(t<11904)&&(t>=12704&&t<=12735||(t>=12544&&t<=12591||(t>=65072&&t<=65103||(t>=63744&&t<=64255||(t>=13056&&t<=13311||(t>=11904&&t<=12031||(t>=12736&&t<=12783||(t>=12288&&t<=12351||(t>=13312&&t<=19903||(t>=19968&&t<=40959||(t>=12800&&t<=13055||(t>=65280&&t<=65519||(t>=12352&&t<=12447||(t>=12272&&t<=12287||(t>=12032&&t<=12255||(t>=12784&&t<=12799||(t>=12448&&t<=12543||(t>=65040&&t<=65055||(t>=42128&&t<=42191||t>=40960&&t<=42127)))))))))))))))))))}function z(t){switch(t){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function V(t){switch(t){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}const G=24,q=17;class E{constructor(t,s,e,i,n,o,r){this._glyphItems=t,this._maxWidth=s,this._lineHeight=e,this._letterSpacing=i,this._hAnchor=n,this._vAnchor=o,this._justify=r}getShaping(t,s,e){const i=this._letterSpacing,n=this._lineHeight,o=this._justify,r=this._maxWidth,c=[];let h=0,a=0;for(const s of t){const t=s.codePointAt(0);if(null==t)continue;const n=e&&R(t);let o;for(const s of this._glyphItems)if(o=s[t],o)break;c.push({codePoint:t,x:h,y:a,vertical:n,glyphMosaicItem:o}),o&&(h+=o.metrics.advance+i)}let l=h;if(r>0){l=h/Math.max(1,Math.ceil(h/r))}const f=t.includes("â€‹"),u=[],d=c.length;for(let t=0;t<d-1;t++){const s=c[t].codePoint,e=O(s);if(z(s)||e){let i=0;if(10===s)i-=1e4;else if(e&&f)i+=150;else{40!==s&&65288!==s||(i+=50);const e=c[t+1].codePoint;41!==e&&65289!==e||(i+=50)}u.push(this._buildBreak(t+1,c[t].x,l,u,i,!1))}}const p=this._optimalBreaks(this._buildBreak(d,h,l,u,0,!0));let w=0;const m=s?-n:n;let b=0;for(let t=0;t<p.length;t++){const s=p[t];let e=b;for(;e<s&&V(c[e].codePoint);)c[e].glyphMosaicItem=null,++e;let i=s-1;for(;i>e&&V(c[i].codePoint);)c[i].glyphMosaicItem=null,--i;if(e<=i){const t=c[e].x;for(let s=e;s<=i;s++)c[s].x-=t,c[s].y=a;let s=c[i].x;c[i].glyphMosaicItem&&(s+=c[i].glyphMosaicItem.metrics.advance),w=Math.max(s,w),o&&this._applyJustification(c,e,i)}b=s,a+=m}if(c.length>0){const t=p.length-1,e=(o-this._hAnchor)*w;let i=(-this._vAnchor*(t+1)+.5)*n;s&&t&&(i+=t*n);for(const t of c)t.x+=e,t.y+=i}return c.filter((t=>t.glyphMosaicItem))}static getTextBox(t,s){if(!t.length)return null;let e=1/0,i=1/0,n=0,o=0;for(const r of t){const t=r.glyphMosaicItem.metrics.advance,c=r.x,h=r.y-q,a=c+t,l=h+s;e=Math.min(e,c),n=Math.max(n,a),i=Math.min(i,h),o=Math.max(o,l)}return{x:e,y:i,width:n-e,height:o-i}}static getBox(t){if(!t.length)return null;let s=1/0,e=1/0,i=0,n=0;for(const o of t){const{height:t,left:r,top:c,width:h}=o.glyphMosaicItem.metrics,a=o.x,l=o.y-(t-Math.abs(c)),f=a+h+r,u=l+t;s=Math.min(s,a),i=Math.max(i,f),e=Math.min(e,l),n=Math.max(n,u)}return{x:s,y:e,width:i-s,height:n-e}}static addDecoration(t,s){const e=t.length;if(0===e)return;const i=3;let n=t[0].x+t[0].glyphMosaicItem.metrics.left,o=t[0].y;for(let r=1;r<e;r++){const e=t[r];if(e.y!==o){const c=t[r-1].x+t[r-1].glyphMosaicItem.metrics.left+t[r-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:n,y:o+s-i,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new y(4,0,4,8),metrics:{width:c-n,height:2+2*i,left:0,top:0,advance:0},page:0,code:0}}),o=e.y,n=e.x+e.glyphMosaicItem.metrics.left}}const r=t[e-1].x+t[e-1].glyphMosaicItem.metrics.left+t[e-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:n,y:o+s-i,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new y(4,0,4,8),metrics:{width:r-n,height:2+2*i,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(t,s,e,i){const n=(t-s)*(t-s);return i?t<s?n/2:2*n:n+Math.abs(e)*e}_buildBreak(t,s,e,i,n,o){let r=null,c=this._breakScore(s,e,n,o);for(const t of i){const i=s-t.x,h=this._breakScore(i,e,n,o)+t.score;h<=c&&(r=t,c=h)}return{index:t,x:s,score:c,previousBreak:r}}_optimalBreaks(t){return t?this._optimalBreaks(t.previousBreak).concat(t.index):[]}_applyJustification(t,s,e){const i=t[e],n=i.vertical?G:i.glyphMosaicItem?i.glyphMosaicItem.metrics.advance:0,o=(i.x+n)*this._justify;for(let i=s;i<=e;i++)t[i].x-=o}}const W=4096,K=8,Y=.5,H=2;class J{constructor(t,s,e=0,i=-1,n=Y){this.x=t,this.y=s,this.angle=e,this.segment=i,this.minzoom=n}}class Q{constructor(t,s,e,i,n,o=Y,r=h){this.anchor=t,this.labelAngle=s,this.glyphAngle=e,this.page=i,this.alternateVerticalGlyph=n,this.minzoom=o,this.maxzoom=r}}class X{constructor(t,s,e,i,n,o,r,c,h,a,l,f){this.tl=t,this.tr=s,this.bl=e,this.br=i,this.mosaicRect=n,this.labelAngle=o,this.minAngle=r,this.maxAngle=c,this.anchor=h,this.minzoom=a,this.maxzoom=l,this.page=f}}class Z{constructor(t){this.shapes=t}}class ${getIconPlacement(t,s,e){const i=new a(t.x,t.y),n=e.rotationAlignment===x.MAP,o=e.keepUpright;let r=e.rotate*l;n&&(r+=t.angle);const h=new Z([]);return e.allowOverlap&&e.ignorePlacement||!g||(h.iconColliders=[]),this._addIconPlacement(h,i,s,e,r),n&&o&&this._addIconPlacement(h,i,s,e,r+c),h}_addIconPlacement(t,s,e,i,n){const o=e.pixelRatio,r=e.width/o,c=e.height/o,l=i.offset;let f=l[0],u=l[1];switch(i.anchor){case k.CENTER:f-=r/2,u-=c/2;break;case k.LEFT:u-=c/2;break;case k.RIGHT:f-=r,u-=c/2;break;case k.TOP:f-=r/2;break;case k.BOTTOM:f-=r/2,u-=c;break;case k.TOP_LEFT:break;case k.BOTTOM_LEFT:u-=c;break;case k.TOP_RIGHT:f-=r;break;case k.BOTTOM_RIGHT:f-=r,u-=c}const d=e.rect,p=2/o,w=f-p,m=u-p,b=w+d.width/o,M=m+d.height/o,y=new a(w,m),x=new a(b,M),I=new a(w,M),_=new a(b,m);if(0!==n){const t=Math.cos(n),s=Math.sin(n);y.rotate(t,s),x.rotate(t,s),I.rotate(t,s),_.rotate(t,s)}const T=new X(y,_,I,x,d,n,0,256,s,Y,h,0);if(t.shapes.push(T),(!i.allowOverlap||!i.ignorePlacement)&&g){const e=i.size,o=i.padding,a={xTile:s.x,yTile:s.y,dxPixels:f*e-o,dyPixels:u*e-o,hard:!i.optional,partIndex:0,width:r*e+2*o,height:c*e+2*o,angle:n,minLod:Y,maxLod:h};t.iconColliders.push(a)}}getTextPlacement(t,s,e,i){const n=new a(t.x,t.y),o=i.rotate*l,r=i.rotationAlignment===x.MAP,f=i.keepUpright,u=i.padding;let d=Y;const p=!r?0:t.angle,w=t.segment>=0&&r,m=i.allowOverlap&&i.ignorePlacement?null:[],b=[],M=4,y=!w;let g=Number.POSITIVE_INFINITY,I=Number.NEGATIVE_INFINITY,_=g,T=I;const A=(w||r)&&f,L=i.size/G;let N=!1;for(const t of s)if(t.vertical){N=!0;break}let v,j=0,D=0;if(!w&&N){const t=E.getTextBox(s,i.lineHeight*G);switch(i.anchor){case k.LEFT:j=t.height/2,D=-t.width/2;break;case k.RIGHT:j=-t.height/2,D=t.width/2;break;case k.TOP:j=t.height/2,D=t.width/2;break;case k.BOTTOM:j=-t.height/2,D=-t.width/2;break;case k.TOP_LEFT:j=t.height;break;case k.BOTTOM_LEFT:D=-t.width;break;case k.TOP_RIGHT:D=t.width;break;case k.BOTTOM_RIGHT:j=-t.height}}j+=i.offset[0]*G,D+=i.offset[1]*G;for(const l of s){const s=l.glyphMosaicItem;if(!s||s.rect.isEmpty)continue;const x=s.rect,k=s.metrics,P=s.page;if(m&&y){if(void 0!==v&&v!==l.y){let s,e,n,r;N?(s=-T+j,e=g+D,n=T-_,r=I-g):(s=g+j,e=_+D,n=I-g,r=T-_);const c={xTile:t.x,yTile:t.y,dxPixels:s*L-u,dyPixels:e*L-u,hard:!i.optional,partIndex:1,width:n*L+2*u,height:r*L+2*u,angle:o,minLod:Y,maxLod:h};m.push(c),g=Number.POSITIVE_INFINITY,I=Number.NEGATIVE_INFINITY,_=g,T=I}v=l.y}const S=[];if(w){const i=.5*s.metrics.width,n=(l.x+k.left-M+i)*L*K;if(d=this._placeGlyph(t,d,n,e,t.segment,1,l.vertical,P,S),f&&(d=this._placeGlyph(t,d,n,e,t.segment,-1,l.vertical,P,S)),d>=H)break}else S.push(new Q(n,p,p,P,!1)),r&&f&&S.push(new Q(n,p+c,p+c,P,!1));const F=l.x+k.left,B=l.y-q-k.top,C=F+k.width,U=B+k.height;let R,O,z,V,G,E,W,J;if(!w&&N)if(l.vertical){const t=(F+C)/2-k.height/2,s=(B+U)/2+k.width/2;R=new a(-s-M+j,t-M+D),O=new a(R.x+x.width,R.y+x.height),z=new a(R.x,O.y),V=new a(O.x,R.y)}else R=new a(-B+M+j,F-M+D),O=new a(R.x-x.height,R.y+x.width),z=new a(O.x,R.y),V=new a(R.x,O.y);else R=new a(F-M+j,B-M+D),O=new a(R.x+x.width,R.y+x.height),z=new a(R.x,O.y),V=new a(O.x,R.y);for(const s of S){let e,n,r,c;if(s.alternateVerticalGlyph){if(!G){const t=(B+U)/2+D;G=new a((F+C)/2+j-k.height/2-M,t+k.width/2+M),E=new a(G.x+x.height,G.y-x.width),W=new a(E.x,G.y),J=new a(G.x,E.y)}e=G,n=W,r=J,c=E}else e=R,n=z,r=V,c=O;const h=B,f=U,d=s.glyphAngle+o;if(0!==d){const t=Math.cos(d),s=Math.sin(d);e=e.clone(),n=n?.clone(),r=r?.clone(),c=c?.clone(),e.rotate(t,s),c?.rotate(t,s),n?.rotate(t,s),r?.rotate(t,s)}let p=0,v=256;if(w&&N?l.vertical?s.alternateVerticalGlyph?(p=32,v=96):(p=224,v=32):(p=224,v=96):(p=192,v=64),b.push(new X(e,r,n,c,x,s.labelAngle,p,v,s.anchor,s.minzoom,s.maxzoom,s.page)),m&&(!A||this._legible(s.labelAngle)))if(y)F<g&&(g=F),h<_&&(_=h),C>I&&(I=C),f>T&&(T=f);else if(s.minzoom<H){const e={xTile:t.x,yTile:t.y,dxPixels:(F+j)*L-u,dyPixels:(h+j)*L-u,hard:!i.optional,partIndex:1,width:(C-F)*L+2*u,height:(f-h)*L+2*u,angle:d,minLod:s.minzoom,maxLod:s.maxzoom};m.push(e)}}}if(d>=H)return null;if(m&&y){let s,e,n,r;N?(s=-T+j,e=g+D,n=T-_,r=I-g):(s=g+j,e=_+D,n=I-g,r=T-_);const c={xTile:t.x,yTile:t.y,dxPixels:s*L-u,dyPixels:e*L-u,hard:!i.optional,partIndex:1,width:n*L+2*u,height:r*L+2*u,angle:o,minLod:Y,maxLod:h};m.push(c)}const P=new Z(b);return m&&m.length>0&&(P.textColliders=m),P}_legible(t){const s=f(t);return s<65||s>=193}_placeGlyph(t,s,e,i,n,o,r,l,f){let p=o;const w=p<0?u(t.angle+c,d):t.angle;let m=0;e<0&&(p*=-1,e*=-1,m=c),p>0&&++n;let b=new a(t.x,t.y),M=i[n],y=h;if(i.length<=n)return y;for(;;){const t=M.x-b.x,o=M.y-b.y,c=Math.sqrt(t*t+o*o),h=Math.max(e/c,s),a=t/c,g=o/c,x=u(Math.atan2(g,a)+m,d);if(f.push(new Q(b,w,x,l,!1,h,y)),r&&f.push(new Q(b,w,x,l,!0,h,y)),h<=s)return h;b=M.clone();do{if(n+=p,i.length<=n||n<0)return h;M=i[n]}while(b.isEqual(M));let k=M.x-b.x,I=M.y-b.y;const _=Math.sqrt(k*k+I*I);k*=c/_,I*=c/_,b.x-=k,b.y-=I,y=h}}}var tt;!function(t){t[t.moveTo=1]="moveTo",t[t.lineTo=2]="lineTo",t[t.close=7]="close"}(tt||(tt={}));class st{constructor(t,s){this.values={},this._geometry=void 0,this._pbfGeometry=null;const e=s.keys,i=s.values,n=t.asUnsafe();for(;n.next();)switch(n.tag()){case 1:this.id=n.getUInt64();break;case 2:{const t=n.getMessage().asUnsafe(),s=this.values;for(;!t.empty();){const n=t.getUInt32(),o=t.getUInt32();s[e[n]]=i[o]}t.release();break}case 3:this.type=n.getUInt32();break;case 4:this._pbfGeometry=n.getMessage();break;default:n.skip()}}getGeometry(t){if(void 0!==this._geometry)return this._geometry;if(!this._pbfGeometry)return null;const s=this._pbfGeometry.asUnsafe();let e,i;this._pbfGeometry=null,t?t.reset(this.type):e=[];let n,o=tt.moveTo,r=0,c=0,h=0;for(;!s.empty();){if(0===r){const t=s.getUInt32();o=7&t,r=t>>3}switch(r--,o){case tt.moveTo:c+=s.getSInt32(),h+=s.getSInt32(),t?t.moveTo(c,h):e&&(i&&e.push(i),i=[],i.push(new a(c,h)));break;case tt.lineTo:c+=s.getSInt32(),h+=s.getSInt32(),t?t.lineTo(c,h):i&&i.push(new a(c,h));break;case tt.close:t?t.close():i&&!i[0].equals(c,h)&&i.push(i[0].clone());break;default:throw s.release(),new Error("Invalid path operation")}}return t?n=t.result():e&&(i&&e.push(i),n=e),s.release(),this._geometry=n,n}}class et extends P{constructor(){super(12)}add(t,s,e){const i=this.array;i.push(t),i.push(s),i.push(e)}}class it{constructor(t){this.extent=4096,this.keys=[],this.values=[],this._pbfLayer=t.clone();const s=t.asUnsafe();for(;s.next();)switch(s.tag()){case 1:this.name=s.getString();break;case 3:this.keys.push(s.getString());break;case 4:this.values.push(s.processMessage(it._parseValue));break;case 5:this.extent=s.getUInt32();break;default:s.skip()}}getData(){return this._pbfLayer}static _parseValue(t){for(;t.next();)switch(t.tag()){case 1:return t.getString();case 2:return t.getFloat();case 3:return t.getDouble();case 4:return t.getInt64();case 5:return t.getUInt64();case 6:return t.getSInt64();case 7:return t.getBool();default:t.skip()}return null}}class nt extends P{constructor(t){super(t)}add(t,s,e,i,n,o,r,c,h,a,l,f){const u=this.array;let d=P.i1616to32(t,s);u.push(d);const p=31;d=P.i8888to32(Math.round(p*e),Math.round(p*i),Math.round(p*n),Math.round(p*o)),u.push(d),d=P.i8888to32(Math.round(p*r),Math.round(p*c),Math.round(p*h),Math.round(p*a)),u.push(d),d=P.i1616to32(l,0),u.push(d),f&&u.push(...f)}}class ot extends P{constructor(t){super(t)}add(t,s,e){const i=this.array;i.push(P.i1616to32(t,s)),e&&i.push(...e)}}class rt extends P{constructor(t){super(t)}add(t,s,e,i,n,o,r){const c=this.array,h=this.index;let a=P.i1616to32(t,s);c.push(a);const l=15;return a=P.i8888to32(Math.round(l*e),Math.round(l*i),n,o),c.push(a),r&&c.push(...r),h}}class ct extends P{constructor(t){super(t)}add(t,s,e,i,n,o,r,c,h,a,l,u){const d=this.array;let p=P.i1616to32(t,s);d.push(p),p=P.i1616to32(Math.round(8*e),Math.round(8*i)),d.push(p),p=P.i8888to32(n/4,o/4,c,h),d.push(p),p=P.i8888to32(0,f(r),10*a,Math.min(10*l,255)),d.push(p),u&&d.push(...u)}}class ht extends P{constructor(t){super(t)}add(t,s,e,i,n){const o=this.array,r=P.i1616to32(2*t+e,2*s+i);o.push(r),n&&o.push(...n)}}class at{constructor(t,s,e){this.layerExtent=4096,this._features=[],this.layer=t,this.zoom=s,this._spriteInfo=e,this._filter=t.getFeatureFilter()}pushFeature(t){this._filter&&!this._filter.filter(t,this.zoom)||this._features.push(t)}hasFeatures(){return this._features.length>0}getResources(t,s,e){}}class lt extends at{constructor(t,s,e,i,n){super(t,s,e),this.type=o.CIRCLE,this._circleVertexBuffer=i,this._circleIndexBuffer=n}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(t){const s=this._circleVertexBuffer,e=this._circleIndexBuffer;this._circleIndexStart=3*e.index,this._circleIndexCount=0;const i=this.layer,n=this.zoom;t&&t.setExtent(this.layerExtent);for(const o of this._features){const r=o.getGeometry(t);if(!r)continue;const c=i.circleMaterial.encodeAttributes(o,n,i);for(const t of r)if(t)for(const i of t){const t=s.index;s.add(i.x,i.y,0,0,c),s.add(i.x,i.y,0,1,c),s.add(i.x,i.y,1,0,c),s.add(i.x,i.y,1,1,c),e.add(t,t+1,t+2),e.add(t+1,t+2,t+3),this._circleIndexCount+=6}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this._circleVertexBuffer.array.length,t+=this._circleIndexBuffer.array.length;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._circleIndexStart,s[i++]=this._circleIndexCount,s[i++]=this._circleVertexBuffer.array.length;for(let t=0;t<this._circleVertexBuffer.array.length;t++)e[i++]=this._circleVertexBuffer.array[t];s[i++]=this._circleIndexBuffer.array.length;for(let t=0;t<this._circleIndexBuffer.array.length;t++)s[i++]=this._circleIndexBuffer.array[t];return s.buffer}}class ft extends at{constructor(t,s,e,i,n,r,c){super(t,s,e),this.type=o.FILL,this._patternMap=new Map,this._fillVertexBuffer=i,this._fillIndexBuffer=n,this._outlineVertexBuffer=r,this._outlineIndexBuffer=c}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(t,s,e){const i=this.layer,n=this.zoom,o=i.getPaintProperty("fill-pattern");if(o)if(o.isDataDriven)for(const t of this._features)s(o.getValue(n,t),!0);else s(o.getValue(n),!0)}processFeatures(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const s=this.layer,e=this.zoom,{fillMaterial:i,outlineMaterial:n,hasDataDrivenFill:o,hasDataDrivenOutline:r}=s;t&&t.setExtent(this.layerExtent);const c=s.getPaintProperty("fill-pattern"),h=c?.isDataDriven;let a=!c&&s.getPaintValue("fill-antialias",e);if(s.outlineUsesFillColor){if(a&&!s.hasDataDrivenOpacity){const t=s.getPaintValue("fill-opacity",e),i=s.getPaintValue("fill-opacity",e+1);t<1&&i<1&&(a=!1)}if(a&&!s.hasDataDrivenColor){const t=s.getPaintValue("fill-color",e),i=s.getPaintValue("fill-color",e+1);t[3]<1&&i[3]<1&&(a=!1)}}const l=this._features,f=t?.validateTessellation;if(h){const o=[];for(const h of l){const l=c.getValue(e,h),u=this._spriteInfo[l];if(!u||!u.rect)continue;const d=i.encodeAttributes(h,e,s,u),p=a&&r?n.encodeAttributes(h,e,s):[],w=h.getGeometry(t);o.push({ddFillAttributes:d,ddOutlineAttributes:p,page:u.page,geometry:w}),o.sort(((t,s)=>t.page-s.page));for(const{ddFillAttributes:t,ddOutlineAttributes:e,page:i,geometry:n}of o)this._processFeature(n,a,s.outlineUsesFillColor,t,e,f,i)}}else for(const c of l){const h=o?i.encodeAttributes(c,e,s):null,l=a&&r?n.encodeAttributes(c,e,s):null,u=c.getGeometry(t);this._processFeature(u,a,s.outlineUsesFillColor,h,l,f)}}serialize(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._fillIndexStart,s[i++]=this._fillIndexCount,s[i++]=this._outlineIndexStart,s[i++]=this._outlineIndexCount;const n=this._patternMap,o=n.size;if(s[i++]=o,o>0)for(const[t,[e,o]]of n)s[i++]=t,s[i++]=e,s[i++]=o;s[i++]=this._fillVertexBuffer.array.length;for(let t=0;t<this._fillVertexBuffer.array.length;t++)e[i++]=this._fillVertexBuffer.array[t];s[i++]=this._fillIndexBuffer.array.length;for(let t=0;t<this._fillIndexBuffer.array.length;t++)s[i++]=this._fillIndexBuffer.array[t];s[i++]=this._outlineVertexBuffer.array.length;for(let t=0;t<this._outlineVertexBuffer.array.length;t++)e[i++]=this._outlineVertexBuffer.array[t];s[i++]=this._outlineIndexBuffer.array.length;for(let t=0;t<this._outlineIndexBuffer.array.length;t++)s[i++]=this._outlineIndexBuffer.array[t];return s.buffer}_processFeature(t,s,e,i,n,o,r){if(!t)return;const c=t.length,h=!n||0===n.length;if(s&&(!e||h))for(let s=0;s<c;s++)this._processOutline(t[s],n);const a=32;let l;for(let s=0;s<c;s++){const e=ft._area(t[s]);e>a?(void 0!==l&&this._processFill(t,l,i,o,r),l=[s]):e<-a&&void 0!==l&&l.push(s)}void 0!==l&&this._processFill(t,l,i,o,r)}_processOutline(t,s){const e=this._outlineVertexBuffer,i=this._outlineIndexBuffer,n=i.index;let o,r,c;const h=new a(0,0),l=new a(0,0),f=new a(0,0);let u=-1,d=-1,p=-1,w=-1,m=-1,b=!1;const M=0;let y=t.length;if(y<2)return;const g=t[M];let x=t[y-1];for(;y&&x.isEqual(g);)--y,x=t[y-1];if(!(y-M<2)){for(let n=M;n<y;++n){n===M?(o=t[y-1],r=t[M],c=t[M+1],h.assignSub(r,o),h.normalize(),h.rightPerpendicular()):(o=r,r=c,c=n!==y-1?t[n+1]:t[M],h.assign(l));const a=this._isClipEdge(o,r);-1===w&&(b=a),l.assignSub(c,r),l.normalize(),l.rightPerpendicular();const g=h.x*l.y-h.y*l.x;f.assignAdd(h,l),f.normalize();const x=-f.x*-h.x+-f.y*-h.y;let k=Math.abs(0!==x?1/x:1);k>8&&(k=8),g>=0?(p=e.add(r.x,r.y,h.x,h.y,0,1,s),-1===w&&(w=p),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p),d=e.add(r.x,r.y,k*-f.x,k*-f.y,0,-1,s),-1===m&&(m=d),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p),u=d,d=p,p=e.add(r.x,r.y,f.x,f.y,0,1,s),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p),d=e.add(r.x,r.y,l.x,l.y,0,1,s),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p)):(p=e.add(r.x,r.y,k*f.x,k*f.y,0,1,s),-1===w&&(w=p),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p),d=e.add(r.x,r.y,-h.x,-h.y,0,-1,s),-1===m&&(m=d),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p),u=d,d=p,p=e.add(r.x,r.y,-f.x,-f.y,0,-1,s),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p),u=e.add(r.x,r.y,-l.x,-l.y,0,-1,s),u>=0&&d>=0&&p>=0&&!a&&i.add(u,d,p))}u>=0&&d>=0&&w>=0&&!b&&i.add(u,d,w),u>=0&&w>=0&&m>=0&&!b&&i.add(u,m,w),this._outlineIndexCount+=3*(i.index-n)}}_processFill(s,e,i,n,o){n=!0;let r;e.length>1&&(r=[]);let c=0;for(const t of e)0!==c&&r.push(c),c+=s[t].length;const h=2*c,a=t.acquire();for(const t of e){const e=s[t],i=e.length;for(let t=0;t<i;++t)a.push(e[t].x,e[t].y)}const l=C(a,r,2);if(n&&C.deviation(a,r,2,l)>0){const t=e.map((t=>s[t].length)),{buffer:n,vertexCount:r}=v(a,t);if(r>0){const t=this._fillVertexBuffer.index;for(let t=0;t<r;t++)this._fillVertexBuffer.add(n[2*t],n[2*t+1],i);for(let s=0;s<r;s+=3){const e=t+s;this._fillIndexBuffer.add(e,e+1,e+2)}if(void 0!==o){const t=this._patternMap,s=t.get(o);s?s[1]+=r:t.set(o,[this._fillIndexStart+this._fillIndexCount,r])}this._fillIndexCount+=r}}else{const t=l.length;if(t>0){const s=this._fillVertexBuffer.index;let e=0;for(;e<h;)this._fillVertexBuffer.add(a[e++],a[e++],i);let n=0;for(;n<t;)this._fillIndexBuffer.add(s+l[n++],s+l[n++],s+l[n++]);if(void 0!==o){const s=this._patternMap,e=s.get(o);e?e[1]+=t:s.set(o,[this._fillIndexStart+this._fillIndexCount,t])}this._fillIndexCount+=t}}t.release(a)}_isClipEdge(t,s){return t.x===s.x?t.x<=-64||t.x>=4160:t.y===s.y&&(t.y<=-64||t.y>=4160)}static _area(t){let s=0;const e=t.length-1;for(let i=0;i<e;i++)s+=(t[i].x-t[i+1].x)*(t[i].y+t[i+1].y);return s+=(t[e].x-t[0].x)*(t[e].y+t[0].y),.5*s}}const ut=65535;class dt extends at{constructor(t,s,e,i,n){super(t,s,e),this.type=o.LINE,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=i,this.tessellationProperties._lineIndexBuffer=n,this._lineTessellator=new j(pt(this.tessellationProperties),wt(this.tessellationProperties),t.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(t,s,e){const i=this.layer,n=this.zoom,o=i.getPaintProperty("line-pattern"),r=i.getPaintProperty("line-dasharray"),c=i.getLayoutProperty("line-cap");if(!o&&!r)return;const h=c?.getValue(n)||0,a=c?.isDataDriven,l=o?.isDataDriven,f=r?.isDataDriven;if(l||f)for(const t of this._features)s(l?o.getValue(n,t):this._getDashArrayKey(t,n,i,r,a,c,h));else if(o)s(o.getValue(n));else if(r){const t=r.getValue(n);s(i.getDashKey(t,h))}}processFeatures(t){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const s=this.layer,e=this.zoom,i=this._features,n=this._tessellationOptions,{hasDataDrivenLine:o,lineMaterial:r}=s;t&&t.setExtent(this.layerExtent);const c=s.getPaintProperty("line-pattern"),h=s.getPaintProperty("line-dasharray"),a=c?.isDataDriven,l=h?.isDataDriven;let f;f=s.getLayoutProperty("line-cap");const u=f?.isDataDriven?f:null,d=u?null:s.getLayoutValue("line-cap",e),p=d||0,w=!!u;f=s.getLayoutProperty("line-join");const m=f?.isDataDriven?f:null,b=m?null:s.getLayoutValue("line-join",e);f=s.getLayoutProperty("line-miter-limit");const M=f?.isDataDriven?f:null,y=M?null:s.getLayoutValue("line-miter-limit",e);f=s.getLayoutProperty("line-round-limit");const g=f?.isDataDriven?f:null,x=g?null:s.getLayoutValue("line-round-limit",e);f=s.getPaintProperty("line-width");const k=f?.isDataDriven?f:null,I=k?null:s.getPaintValue("line-width",e);f=s.getPaintProperty("line-offset");const _=f?.isDataDriven?f:null,T=_?null:s.getPaintValue("line-offset",e);if(a||l){const o=[];for(const n of i){const i=a?c.getValue(e,n):this._getDashArrayKey(n,e,s,h,w,u,p),l=this._spriteInfo[i];if(!l||!l.rect)continue;const f=r.encodeAttributes(n,e,s,l),A=n.getGeometry(t);o.push({ddAttributes:f,page:l.page,cap:u?u.getValue(e,n):d,join:m?m.getValue(e,n):b,miterLimit:M?M.getValue(e,n):y,roundLimit:g?g.getValue(e,n):x,halfWidth:.5*(k?k.getValue(e,n):I),offset:_?_.getValue(e,n):T,geometry:A})}o.sort(((t,s)=>t.page-s.page)),n.textured=!0;for(const{ddAttributes:t,page:s,cap:e,join:i,miterLimit:r,roundLimit:c,halfWidth:h,offset:a,geometry:l}of o)n.capType=e,n.joinType=i,n.miterLimit=r,n.roundLimit=c,n.halfWidth=h,n.offset=a,this._processFeature(l,t,s)}else{if(c){const t=c.getValue(e),s=this._spriteInfo[t];if(!s||!s.rect)return}n.textured=!(!c&&!h),n.capType=d,n.joinType=b,n.miterLimit=y,n.roundLimit=x,n.halfWidth=.5*I,n.offset=T;for(const c of i){const i=o?r.encodeAttributes(c,e,s):null;u&&(n.capType=u.getValue(e,c)),m&&(n.joinType=m.getValue(e,c)),M&&(n.miterLimit=M.getValue(e,c)),g&&(n.roundLimit=g.getValue(e,c)),k&&(n.halfWidth=.5*k.getValue(e,c)),_&&(n.offset=_.getValue(e,c));const h=c.getGeometry(t);this._processFeature(h,i)}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this.tessellationProperties._lineVertexBuffer.array.length,t+=this.tessellationProperties._lineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._lineIndexStart,s[i++]=this._lineIndexCount;const n=this._patternMap,o=n.size;if(s[i++]=o,o>0)for(const[t,[e,o]]of n)s[i++]=t,s[i++]=e,s[i++]=o;s[i++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineVertexBuffer.array.length;t++)e[i++]=this.tessellationProperties._lineVertexBuffer.array[t];s[i++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineIndexBuffer.array.length;t++)s[i++]=this.tessellationProperties._lineIndexBuffer.array[t];return s.buffer}_processFeature(t,s,e){if(!t)return;const i=t.length;for(let n=0;n<i;n++)this._processGeometry(t[n],s,e)}_processGeometry(t,s,e){if(t.length<2)return;const i=.001;let n,o,r=t[0],c=1;for(;c<t.length;)n=t[c].x-r.x,o=t[c].y-r.y,n*n+o*o<i*i?t.splice(c,1):(r=t[c],++c);if(t.length<2)return;const h=this.tessellationProperties._lineIndexBuffer,a=3*h.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=ut,this.tessellationProperties._ddValues=s,this._lineTessellator.tessellate(t,this._tessellationOptions);const l=3*h.index-a;if(void 0!==e){const t=this._patternMap,s=t.get(e);s?s[1]+=l:t.set(e,[a+this._lineIndexCount,l])}this._lineIndexCount+=l}_getDashArrayKey(t,s,e,i,n,o,r){const c=n?o.getValue(s,t):r,h=i.getValue(s,t);return e.getDashKey(h,c)}}const pt=t=>(s,e,i,n,o,r,c,h,a,l,f)=>(t._lineVertexBuffer.add(s,e,c,h,i,n,o,r,a,l,f,t._ddValues),t._lineVertexBuffer.index-1),wt=t=>(s,e,i)=>{t._lineIndexBuffer.add(s,e,i)};const mt=10;function bt(t,s){return t.iconMosaicItem&&s.iconMosaicItem?t.iconMosaicItem.page===s.iconMosaicItem.page?0:t.iconMosaicItem.page-s.iconMosaicItem.page:t.iconMosaicItem&&!s.iconMosaicItem?1:!t.iconMosaicItem&&s.iconMosaicItem?-1:0}class Mt extends at{constructor(t,s,e,i,n,r,c,h){super(t,s,h.getSpriteItems()),this.type=o.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._iconVertexBuffer=e,this._iconIndexBuffer=i,this._textVertexBuffer=n,this._textIndexBuffer=r,this._placementEngine=c,this._workerTileHandler=h}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(t,e,i){const n=this.layer,o=this.zoom;t&&t.setExtent(this.layerExtent);const r=n.getLayoutProperty("icon-image"),c=n.getLayoutProperty("text-field");let h=n.getLayoutProperty("text-transform"),a=n.getLayoutProperty("text-font");const l=[];let f,u,d,p;r&&!r.isDataDriven&&(f=r.getValue(o)),c&&!c.isDataDriven&&(u=c.getValue(o)),h&&h.isDataDriven||(d=n.getLayoutValue("text-transform",o),h=null),a&&a.isDataDriven||(p=n.getLayoutValue("text-font",o),a=null);for(const w of this._features){const m=w.getGeometry(t);if(!m||0===m.length)continue;let b,M;r&&(b=r.isDataDriven?r.getValue(o,w):this._replaceKeys(f,w.values),b&&e(b));let y=!1;if(c&&(M=c.isDataDriven?c.getValue(o,w):this._replaceKeys(u,w.values),M)){switch(M=M.replaceAll("\\n","\n"),h&&(d=h.getValue(o,w)),d){case I.LOWERCASE:M=M.toLowerCase();break;case I.UPPERCASE:M=M.toUpperCase()}if(Mt._bidiEngine.hasBidiChar(M)){let t;t="rtl"===Mt._bidiEngine.checkContextual(M)?"IDNNN":"ICNNN",M=Mt._bidiEngine.bidiTransform(M,t,"VLYSN"),y=!0}if(M.length>0){a&&(p=a.getValue(o,w));for(const t of p){let s=i[t];s||(s=i[t]=new Set);for(const t of M){const e=t.codePointAt(0);null!=e&&s.add(e)}}}}if(!b&&!M)continue;const g=n.getLayoutValue("symbol-sort-key",o,w),x={feature:w,sprite:b,label:M,rtl:y,geometry:m,hash:(M?s(M):0)^(b?s(b):0),priority:g,textFont:p};l.push(x)}this._symbolFeatures=l}processFeatures(t){t&&t.setExtent(this.layerExtent);const s=this.layer,i=this.zoom,n=s.getLayoutValue("symbol-placement",i),o=n!==T.POINT,r=s.getLayoutValue("symbol-spacing",i)*K,c=s.getLayoutProperty("icon-image"),h=s.getLayoutProperty("text-field"),a=c?new S(s,i,o):null,f=h?new F(s,i,o):null,u=this._workerTileHandler;let d;c&&(d=u.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const w=[];let m=1;f&&f.size&&(m=f.size/G);const b=f?f.maxAngle*l:0,M=f?f.size*K:0;for(const t of this._symbolFeatures){let s;a&&d&&t.sprite&&(s=d[t.sprite],s&&s.sdf&&(this._isIconSDF=!0));let c;!!s&&a.update(i,t.feature);let h=0;const l=t.label;if(l){e(f),f.update(i,t.feature);const s=o&&f.rotationAlignment===x.MAP?f.keepUpright:f.writingMode&&f.writingMode.includes(_.VERTICAL);let n=.5;switch(f.anchor){case k.TOP_LEFT:case k.LEFT:case k.BOTTOM_LEFT:n=0;break;case k.TOP_RIGHT:case k.RIGHT:case k.BOTTOM_RIGHT:n=1}let r=.5;switch(f.anchor){case k.TOP_LEFT:case k.TOP:case k.TOP_RIGHT:r=0;break;case k.BOTTOM_LEFT:case k.BOTTOM:case k.BOTTOM_RIGHT:r=1}let a=.5;switch(f.justify){case A.AUTO:a=n;break;case A.LEFT:a=0;break;case A.RIGHT:a=1}const d=f.letterSpacing*G,p=o?0:f.maxWidth*G,w=f.lineHeight*G,b=t.textFont.map((t=>u.getGlyphItems(t)));if(c=new E(b,p,w,d,n,r,a).getShaping(l,t.rtl,s),c&&c.length>0){let t=1e30,s=-1e30;for(const e of c)t=Math.min(t,e.x),s=Math.max(s,e.x);h=(s-t+2*G)*m*K}}for(let e of t.geometry){const i=[];if(n===T.LINE){if(c?.length&&f?.size){const t=f.size*K*(2+Math.min(2,4*Math.abs(f.offset[1])));e=Mt._smoothVertices(e,t)}Mt._pushAnchors(i,e,r,h)}else n===T.LINE_CENTER?Mt._pushCenterAnchor(i,e):t.feature.type===p.Polygon?Mt._pushCentroid(i,e):i.push(new J(e[0].x,e[0].y));for(const n of i){if(n.x<0||n.x>W||n.y<0||n.y>W)continue;if(o&&h>0&&f?.rotationAlignment===x.MAP&&!Mt._honorsTextMaxAngle(e,n,h,b,M))continue;const i={shaping:c,line:e,iconMosaicItem:s,anchor:n,symbolFeature:t,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};w.push(i),this._processFeature(i,a,f)}}}w.sort(bt),this._addPlacedGlyphs(),this._symbolInstances=w}serialize(){let t=11;t+=this.layerUIDs.length,t+=3*this.markerPageMap.size,t+=3*this.glyphsPageMap.size,t+=Mt._symbolsSerializationLength(this._symbolInstances),t+=this._iconVertexBuffer.array.length,t+=this._iconIndexBuffer.array.length,t+=this._textVertexBuffer.array.length,t+=this._textIndexBuffer.array.length;const s=new Uint32Array(t),e=new Int32Array(s.buffer),i=new Float32Array(s.buffer);let n=0;s[n++]=this.type,s[n++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[n++]=this.layerUIDs[t];s[n++]=this._isIconSDF?1:0,s[n++]=this.markerPageMap.size;for(const[t,[e,i]]of this.markerPageMap)s[n++]=t,s[n++]=e,s[n++]=i;s[n++]=this.glyphsPageMap.size;for(const[t,[e,i]]of this.glyphsPageMap)s[n++]=t,s[n++]=e,s[n++]=i;s[n++]=this._iconVertexBuffer.index/4,s[n++]=this._textVertexBuffer.index/4,n=Mt.serializeSymbols(s,e,i,n,this._symbolInstances),s[n++]=this._iconVertexBuffer.array.length;for(let t=0;t<this._iconVertexBuffer.array.length;t++)e[n++]=this._iconVertexBuffer.array[t];s[n++]=this._iconIndexBuffer.array.length;for(let t=0;t<this._iconIndexBuffer.array.length;t++)s[n++]=this._iconIndexBuffer.array[t];s[n++]=this._textVertexBuffer.array.length;for(let t=0;t<this._textVertexBuffer.array.length;t++)e[n++]=this._textVertexBuffer.array[t];s[n++]=this._textIndexBuffer.array.length;for(let t=0;t<this._textIndexBuffer.array.length;t++)s[n++]=this._textIndexBuffer.array[t];return s.buffer}static _symbolsSerializationLength(t){let s=0;s+=1;for(const e of t||[]){s+=4,s+=1;for(const t of e.textColliders)s+=mt;for(const t of e.iconColliders)s+=mt;s+=1,s+=2*e.textVertexRanges.length,s+=1,s+=2*e.iconVertexRanges.length}return s}static serializeSymbols(t,s,e,i,n){n=n||[],s[i++]=n.length;for(const t of n){s[i++]=t.anchor.x,s[i++]=t.anchor.y,s[i++]=t.symbolFeature.hash,s[i++]=t.symbolFeature.priority,s[i++]=t.textColliders.length+t.iconColliders.length;for(const n of t.textColliders)s[i++]=n.xTile,s[i++]=n.yTile,s[i++]=n.dxPixels,s[i++]=n.dyPixels,s[i++]=n.hard?1:0,s[i++]=n.partIndex,e[i++]=n.minLod,e[i++]=n.maxLod,s[i++]=n.width,s[i++]=n.height;for(const n of t.iconColliders)s[i++]=n.xTile,s[i++]=n.yTile,s[i++]=n.dxPixels,s[i++]=n.dyPixels,s[i++]=n.hard?1:0,s[i++]=n.partIndex,e[i++]=n.minLod,e[i++]=n.maxLod,s[i++]=n.width,s[i++]=n.height;s[i++]=t.textVertexRanges.length;for(const[e,n]of t.textVertexRanges)s[i++]=e,s[i++]=n;s[i++]=t.iconVertexRanges.length;for(const[e,n]of t.iconVertexRanges)s[i++]=e,s[i++]=n}return i}_replaceKeys(t,s){return t.replaceAll(/{([^{}]+)}/g,((t,e)=>e in s?s[e]:""))}_processFeature(t,s,e){const{line:i,iconMosaicItem:n,shaping:o,anchor:r}=t,c=this.zoom,h=this.layer,a=!!n;let l=!0;a&&(l=s?.optional||!n);const f=o&&o.length>0,u=!f||e?.optional;let d,p;if(a&&(d=this._placementEngine.getIconPlacement(r,n,s)),(d||l)&&(f&&(p=this._placementEngine.getTextPlacement(r,o,i,e)),p||u)){if(d&&p||(u||l?u||p?l||d||(p=null):d=null:(d=null,p=null)),p){const s=h.hasDataDrivenText?h.textMaterial.encodeAttributes(t.symbolFeature.feature,c,h):null;if(this._storePlacedGlyphs(t,p.shapes,c,e.rotationAlignment,s),p.textColliders){t.textColliders=p.textColliders;for(const t of p.textColliders){t.minLod=Math.max(c+w(t.minLod),0),t.maxLod=Math.min(c+w(t.maxLod),25);const s=t.angle;if(s){const e=Math.cos(s),i=Math.sin(s),n=t.dxPixels*e-t.dyPixels*i,o=t.dxPixels*i+t.dyPixels*e,r=(t.dxPixels+t.width)*e-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*e,h=t.dxPixels*e-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*e,l=(t.dxPixels+t.width)*e-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*e,u=Math.min(n,r,h,l),d=Math.max(n,r,h,l),p=Math.min(o,c,a,f),w=Math.max(o,c,a,f);t.dxPixels=u,t.dyPixels=p,t.width=d-u,t.height=w-p}}}}if(d){const e=h.hasDataDrivenIcon?h.iconMaterial.encodeAttributes(t.symbolFeature.feature,c,h):null;if(this._addPlacedIcons(t,d.shapes,c,n.page,s.rotationAlignment===x.VIEWPORT,e),d.iconColliders){t.iconColliders=d.iconColliders;for(const t of d.iconColliders){t.minLod=Math.max(c+w(t.minLod),0),t.maxLod=Math.min(c+w(t.maxLod),25);const s=t.angle;if(s){const e=Math.cos(s),i=Math.sin(s),n=t.dxPixels*e-t.dyPixels*i,o=t.dxPixels*i+t.dyPixels*e,r=(t.dxPixels+t.width)*e-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*e,h=t.dxPixels*e-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*e,l=(t.dxPixels+t.width)*e-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*e,u=Math.min(n,r,h,l),d=Math.max(n,r,h,l),p=Math.min(o,c,a,f),w=Math.max(o,c,a,f);t.dxPixels=u,t.dyPixels=p,t.width=d-u,t.height=w-p}}}}}}_addPlacedIcons(t,s,e,i,n,o){const r=Math.max(e-1,0),c=this._iconVertexBuffer,h=this._iconIndexBuffer,a=this._markerMap;for(const l of s){const s=n?0:Math.max(e+w(l.minzoom),r),f=n?25:Math.min(e+w(l.maxzoom),25);if(f<=s)continue;const u=l.tl,d=l.tr,p=l.bl,m=l.br,b=l.mosaicRect,M=l.labelAngle,y=l.minAngle,g=l.maxAngle,x=l.anchor,k=c.index,I=b.x,_=b.y,T=I+b.width,A=_+b.height,L=c.index;c.add(x.x,x.y,u.x,u.y,I,_,M,y,g,s,f,o),c.add(x.x,x.y,d.x,d.y,T,_,M,y,g,s,f,o),c.add(x.x,x.y,p.x,p.y,I,A,M,y,g,s,f,o),c.add(x.x,x.y,m.x,m.y,T,A,M,y,g,s,f,o),t.iconVertexRanges.length>0&&t.iconVertexRanges[0][0]+t.iconVertexRanges[0][1]===L?t.iconVertexRanges[0][1]+=4:t.iconVertexRanges.push([L,4]),h.add(k,k+1,k+2),h.add(k+1,k+2,k+3),a.has(i)?a.get(i)[1]+=6:a.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const t=this._textVertexBuffer,s=this._textIndexBuffer,e=this._glyphMap;for(const[i,n]of this._glyphBufferDataStorage)for(const o of n){const n=t.index,r=o.symbolInstance,c=o.ddAttributes,h=t.index;t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tl[0],o.tl[1],o.xmin,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tr[0],o.tr[1],o.xmax,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.bl[0],o.bl[1],o.xmin,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.br[0],o.br[1],o.xmax,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),r.textVertexRanges.length>0&&r.textVertexRanges[0][0]+r.textVertexRanges[0][1]===h?r.textVertexRanges[0][1]+=4:r.textVertexRanges.push([h,4]),s.add(n,n+1,n+2),s.add(n+1,n+2,n+3),e.has(i)?e.get(i)[1]+=6:e.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(t,s,e,i,n){const o=Math.max(e-1,0),r=i===x.VIEWPORT;let c,h,a,l,f,u,d,p,m,b,M;for(const i of s){if(c=r?0:Math.max(e+w(i.minzoom),o),h=r?25:Math.min(e+w(i.maxzoom),25),h<=c)continue;a=i.tl,l=i.tr,f=i.bl,u=i.br,d=i.labelAngle,p=i.minAngle,m=i.maxAngle,b=i.anchor,M=i.mosaicRect,this._glyphBufferDataStorage.has(i.page)||this._glyphBufferDataStorage.set(i.page,[]);this._glyphBufferDataStorage.get(i.page).push({glyphAnchor:[b.x,b.y],tl:[a.x,a.y],tr:[l.x,l.y],bl:[f.x,f.y],br:[u.x,u.y],xmin:M.x,ymin:M.y,xmax:M.x+M.width,ymax:M.y+M.height,labelAngle:d,minAngle:p,maxAngle:m,minLod:c,maxLod:h,placementLod:o,symbolInstance:t,ddAttributes:n})}}static _pushAnchors(t,s,e,i){e+=i;let n=0;const o=s.length-1;for(let t=0;t<o;t++)n+=a.distance(s[t],s[t+1]);let r=i||e;if(r*=.5,n<=r)return;const c=r/n;let h=0,l=-(e=n/Math.max(Math.round(n/e),1))/2;const f=s.length-1;for(let i=0;i<f;i++){const n=s[i],o=s[i+1],r=o.x-n.x,a=o.y-n.y,f=Math.sqrt(r*r+a*a);let u;for(;l+e<h+f;){l+=e;const s=(l-h)/f,d=m(n.x,o.x,s),p=m(n.y,o.y,s);void 0===u&&(u=Math.atan2(a,r)),t.push(new J(d,p,u,i,c))}h+=f}}static _pushCenterAnchor(t,s){let e=0;const i=s.length-1;for(let t=0;t<i;t++)e+=a.distance(s[t],s[t+1]);const n=e/2;let o=0;const r=s.length-1;for(let e=0;e<r;e++){const i=s[e],r=s[e+1],c=r.x-i.x,h=r.y-i.y,a=Math.sqrt(c*c+h*h);if(n<o+a){const s=(n-o)/a,l=m(i.x,r.x,s),f=m(i.y,r.y,s),u=Math.atan2(h,c);return void t.push(new J(l,f,u,e,0))}o+=a}}static _deviation(t,s,e){const i=(s.x-t.x)*(e.x-s.x)+(s.y-t.y)*(e.y-s.y),n=(s.x-t.x)*(e.y-s.y)-(s.y-t.y)*(e.x-s.x);return Math.atan2(n,i)}static _honorsTextMaxAngle(t,s,e,i,n){let o=0;const r=e/2;let c=new a(s.x,s.y),h=s.segment+1;for(;o>-r;){if(--h,h<0)return!1;o-=a.distance(t[h],c),c=t[h]}o+=a.distance(t[h],t[h+1]);const l=[];let f=0;const u=t.length;for(;o<r;){const s=t[h];let e,r=h;do{if(++r,r===u)return!1;e=t[r]}while(e.isEqual(s));let c,d=r;do{if(++d,d===u)return!1;c=t[d]}while(c.isEqual(e));const p=this._deviation(s,e,c);for(l.push({deviation:p,distToAnchor:o}),f+=p;o-l[0].distToAnchor>n;)f-=l.shift().deviation;if(Math.abs(f)>i)return!1;o+=a.distance(e,c),h=r}return!0}static _smoothVertices(t,s){if(s<=0)return t;let e=t.length;if(e<3)return t;const i=[];let n=0,o=0;i.push(0);for(let s=1;s<e;s++){const e=a.distance(t[s],t[s-1]);e>0&&(n+=e,i.push(n),o++,o!==s&&(t[o]=t[s]))}if(e=o+1,e<3)return t;s=Math.min(s,.2*n);const r=t[0].x,c=t[0].y,h=t[e-1].x,l=t[e-1].y,f=a.sub(t[0],t[1]);f.normalize(),t[0].x+=s*f.x,t[0].y+=s*f.y,f.assignSub(t[e-1],t[e-2]),f.normalize(),t[e-1].x+=s*f.x,t[e-1].y+=s*f.y,i[0]-=s,i[e-1]+=s;const u=[];u.push(new a(r,c));const d=1e-6,p=.5*s;for(let n=1;n<e-1;n++){let o=0,r=0,c=0;for(let e=n-1;e>=0;e--){const h=p+i[e+1]-i[n];if(h<0)break;const a=i[e+1]-i[e],l=i[n]-i[e]<p?1:h/a;if(l<d)break;const f=l*l,u=l*h-.5*f*a,w=l*a/s,m=t[e+1],b=t[e].x-m.x,M=t[e].y-m.y;o+=w/u*(m.x*l*h+.5*f*(h*b-a*m.x)-f*l*a*b/3),r+=w/u*(m.y*l*h+.5*f*(h*M-a*m.y)-f*l*a*M/3),c+=w}for(let h=n+1;h<e;h++){const e=p-i[h-1]+i[n];if(e<0)break;const a=i[h]-i[h-1],l=i[h]-i[n]<p?1:e/a;if(l<d)break;const f=l*l,u=l*e-.5*f*a,w=l*a/s,m=t[h-1],b=t[h].x-m.x,M=t[h].y-m.y;o+=w/u*(m.x*l*e+.5*f*(e*b-a*m.x)-f*l*a*b/3),r+=w/u*(m.y*l*e+.5*f*(e*M-a*m.y)-f*l*a*M/3),c+=w}u.push(new a(o/c,r/c))}return u.push(new a(h,l)),t[0].x=r,t[0].y=c,t[e-1].x=h,t[e-1].y=l,u}static _pushCentroid(t,s){const e=0,i=0,n=4096,o=4096,r=s.length-1;let c=0,h=0,a=0,l=s[0].x,f=s[0].y;l>n&&(l=n),l<e&&(l=e),f>o&&(f=o),f<i&&(f=i);for(let t=1;t<r;t++){let r=s[t].x,u=s[t].y,d=s[t+1].x,p=s[t+1].y;r>n&&(r=n),r<e&&(r=e),u>o&&(u=o),u<i&&(u=i),d>n&&(d=n),d<e&&(d=e),p>o&&(p=o),p<i&&(p=i);const w=(r-l)*(p-f)-(d-l)*(u-f);c+=w*(l+r+d),h+=w*(f+u+p),a+=w}c/=3*a,h/=3*a,isNaN(c)||isNaN(h)||t.push(new J(c,h))}}Mt._bidiEngine=new U;var yt;!function(t){t[t.INITIALIZED=0]="INITIALIZED",t[t.NO_DATA=1]="NO_DATA",t[t.READY=2]="READY",t[t.MODIFIED=3]="MODIFIED",t[t.INVALID=4]="INVALID"}(yt||(yt={}));const gt=8,xt=14,kt=5;class It{constructor(t,s,e,i,n){if(this._pbfTiles={},this._tileClippers={},this._client=e,this._tile=s,n){this._styleLayerUIDs=new Set;for(const t of n)this._styleLayerUIDs.add(t)}this._styleRepository=i,this._layers=this._styleRepository?.layers??[];const[o,r,c]=s.tileKey.split("/").map(parseFloat);this._level=o;const h=gt+Math.max((this._level-xt)*kt,0);for(const s of Object.keys(t)){const e=t[s];this._pbfTiles[s]=new N(new Uint8Array(e.protobuff),new DataView(e.protobuff));if(e.refKey){const[t]=e.refKey.split("/").map(parseFloat),i=o-t;if(i>0){const t=(1<<i)-1,e=r&t,n=c&t;this._tileClippers[s]=new b(i,e,n,8,h)}}this._tileClippers[s]||(this._tileClippers[s]=new M)}}_canParseStyleLayer(t){return!this._styleLayerUIDs||this._styleLayerUIDs.has(t)}async parse(t){const s=D(),e=this._initialize(t),{returnedBuckets:i}=e;this._processLayers(e),this._linkReferences(e),this._filterFeatures(e);const n=[],o=new Set,r=(t,s)=>{o.has(t)||(n.push({name:t,repeat:s}),o.add(t))},c={};for(const t of i)t.getResources(t.tileClipper,r,c);if(this._tile.status===yt.INVALID)return[];const h=this._fetchResources(n,c,t);return Promise.all([...h,s]).then((()=>this._processFeatures(e.returnedBuckets)))}_initialize(t){return{signal:t&&t.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(t){const{sourceNameToTileData:s,layers:e,zoom:i,sourceNameToTileClipper:n,sourceNameToUniqueSourceLayerBuckets:o,sourceNameToUniqueSourceLayers:r,returnedBuckets:c,layerIdToBucket:h,referencerUIDToReferencedId:a}=t;for(let t=e.length-1;t>=0;t--){const l=e[t];if(!this._canParseStyleLayer(l.uid)||l.minzoom&&i<Math.floor(l.minzoom)||l.maxzoom&&i>=l.maxzoom||l.type===L.BACKGROUND)continue;if(!s[l.source]||!n[l.source])continue;const f=s[l.source],u=n[l.source],d=l.sourceLayer,p=f[d];if(p){let t=r[l.source];if(t||(t=r[l.source]=new Set),t.add(l.sourceLayer),l.refLayerId)a.set(l.uid,l.refLayerId);else{const t=this._createBucket(l);if(t){t.layerUIDs=[l.uid],t.layerExtent=p.extent,t.tileClipper=u;let s=o[l.source];s||(s=o[l.source]={});let e=s[d];e||(e=s[d]=[]),e.push(t),c.push(t),h[l.id]=t}}}}}_linkReferences(t){const{layerIdToBucket:s,referencerUIDToReferencedId:e}=t;e.forEach(((t,e)=>{s[t]&&s[t].layerUIDs.push(e)}))}_filterFeatures(t){const{signal:s,sourceNameToTileData:e,sourceNameToUniqueSourceLayerBuckets:n,sourceNameToUniqueSourceLayers:o}=t,r=10*this._level,c=10*(this._level+1),h=[],a=[];for(const t of Object.keys(o)){o[t].forEach((s=>{h.push(s),a.push(t)}))}for(let t=0;t<h.length;t++){const o=a[t],l=h[t];if(!e[o]||!n[o])continue;const f=e[o][l],u=n[o][l];if(!u||0===u.length)continue;if(i(s))return;const d=f.getData();for(;d.nextTag(2);){const t=d.getMessage(),s=new st(t,f);t.release();const e=s.values;if(e){const t=e._minzoom;if(t&&t>=c)continue;const s=e._maxzoom;if(s&&s<=r)continue}for(const t of u)t.pushFeature(s)}}}_fetchResources(t,s,e){const i=[],n=this._tile.getWorkerTileHandler();let o,r;t.length>0&&(o=n.fetchSprites(t,this._client,e),i.push(o));for(const t in s){const o=s[t];o.size>0&&(r=n.fetchGlyphs(this._tile.tileKey,t,o,this._client,e),i.push(r))}return i}_processFeatures(t){const s=t.filter((t=>t.hasFeatures()||this._canParseStyleLayer(t.layer.uid)));for(const t of s)t.processFeatures(t.tileClipper);return s}_parseTileData(t){const s={};for(const e of Object.keys(t)){const i=t[e],n={};for(;i.next();)switch(i.tag()){case 3:{const t=i.getMessage(),s=new it(t);t.release(),n[s.name]=s;break}default:i.skip()}s[e]=n}return s}_createBucket(t){switch(t.type){case L.BACKGROUND:return null;case L.FILL:return this._createFillBucket(t);case L.LINE:return this._createLineBucket(t);case L.CIRCLE:return this._createCircleBucket(t);case L.SYMBOL:return this._createSymbolBucket(t)}}_createFillBucket(t){return new ft(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new ot(t.fillMaterial.getStride()),new et,new rt(t.outlineMaterial.getStride()),new et)}_createLineBucket(t){return new dt(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new nt(t.lineMaterial.getStride()),new et)}_createCircleBucket(t){return new lt(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new ht(t.circleMaterial.getStride()),new et)}_createSymbolBucket(t){const s=this._tile;return new Mt(t,this._level,new ct(t.iconMaterial.getStride()),new et,new ct(t.textMaterial.getStride()),new et,s.placementEngine,s.getWorkerTileHandler())}}class _t{constructor(t,s,e,i){this.status=yt.INITIALIZED,this.placementEngine=new $,this.tileKey=t,this.refKeys=s,this._workerTileHandler=e,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=yt.INITIALIZED,this._workerTileHandler=null}async parse(t,s){const e=s&&s.signal;if(null!=e){const t=()=>{e.removeEventListener("abort",t),this.status=yt.INVALID};e.addEventListener("abort",t)}let i;const o={bucketsWithData:[],emptyBuckets:null};try{i=await this._parse(t,s)}catch(t){if(n(t))throw t;return{result:o,transferList:[]}}this.status=yt.READY;const r=o.bucketsWithData,c=[];for(const t of i)if(t.hasFeatures()){const s=t.serialize();r.push(s)}else c.push(t.layer.uid);const h=[...r];let a=null;return c.length>0&&(a=Uint32Array.from(c),h.push(a.buffer)),o.emptyBuckets=a,{result:o,transferList:h}}setObsolete(){this.status=yt.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}async _parse(t,s){const e=t.sourceName2DataAndRefKey;if(0===Object.keys(e).length)return[];this.status=yt.MODIFIED;return new It(e,this,s.client,this._styleRepository,t.styleLayerUIDs).parse(s)}}class Tt{constructor(){this._spriteInfo={},this._glyphInfo={}}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){return this._styleRepository?.layers??[]}async createTileAndParse(t,s){const{key:e}=t,i={};for(const s of Object.keys(t.sourceName2DataAndRefKey)){const e=t.sourceName2DataAndRefKey[s];i[s]=e.refKey}const o=new _t(e,i,this,this._styleRepository);try{return await o.parse(t,s)}catch(t){if(o.setObsolete(),o.release(),!n(t))throw t;return null}}updateStyle(t){if(!t||0===t.length||!this._styleRepository)return;const s=this._styleRepository;for(const e of t){const t=e.type,i=e.data;switch(t){case r.PAINTER_CHANGED:s.setPaintProperties(i.layer,i.paint);break;case r.LAYOUT_CHANGED:s.setLayoutProperties(i.layer,i.layout);break;case r.LAYER_REMOVED:s.deleteStyleLayer(i.layer);break;case r.LAYER_CHANGED:s.setStyleLayer(i.layer,i.index);break;case r.SPRITES_CHANGED:this._spriteInfo={}}}}setStyle(t){this._styleRepository=new B(t),this._spriteInfo={},this._glyphInfo={}}fetchSprites(t,s,e){const i=[],n=this._spriteInfo;for(const s of t){void 0===n[s.name]&&i.push(s)}return 0===i.length?Promise.resolve():s.invoke("getSprites",i,{signal:e&&e.signal}).then((t=>{for(const s in t){const e=t[s];n[s]=e}}))}getSpriteItems(){return this._spriteInfo}fetchGlyphs(t,s,e,i,n){const o=[];let r=this._glyphInfo[s];return r?e.forEach((t=>{r[t]||o.push(t)})):(r=this._glyphInfo[s]=[],e.forEach((t=>o.push(t)))),0===o.length?Promise.resolve():i.invoke("getGlyphs",{tileID:t,font:s,codePoints:o},n).then((t=>{for(let s=0;s<t.length;s++)t[s]&&(r[s]=t[s])}))}getGlyphItems(t){return this._glyphInfo[t]}}export default Tt;
//# sourceMappingURL=p-17365a2d.js.map