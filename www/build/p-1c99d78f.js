import{b as t,s as e,fh as s,jC as i,bP as r,cB as n,e as l,w as o,af as a,Q as u,cF as h,eV as c,ay as p,aN as y,U as f,iI as d,cr as A,aT as m,bO as w,j5 as g,cD as v,dv as S,jD as b,a6 as j,hG as x,hH as U,d2 as T,d3 as O,d4 as _,i3 as R,hR as B,d5 as D,bS as I,cK as M,jE as E,jF as Q,ar as k,l as L,y as C,aU as P,W as V,a8 as $,n as W}from"./p-b54724b6.js";import{p as G}from"./p-a01007cf.js";import{j as J,p as N}from"./p-8bc47c76.js";import{T as F}from"./p-a0d095b0.js";import{e as q}from"./p-cae2235f.js";import{e as z}from"./p-a10686d4.js";import{l as K}from"./p-17a45052.js";import{n as X}from"./p-a379c2ce.js";import"./p-58fca073.js";import"./p-52d8e383.js";import"./p-4f76b2d1.js";import"./p-0e94eaa4.js";import"./p-8a4ae095.js";import"./p-13e550f5.js";import"./p-795f7c81.js";import"./p-7833a3a9.js";import"./p-6bb7b693.js";import"./p-f5f26b1f.js";import"./p-570a8a46.js";import"./p-541ec65c.js";let Y=null;function H(t){if(Y)return Y;const e={lossy:"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",lossless:"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",alpha:"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==",animation:"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"};return Y=new Promise((s=>{const i=new Image;i.onload=()=>{i.onload=i.onerror=null,s(i.width>0&&i.height>0)},i.onerror=()=>{i.onload=i.onerror=null,s(!1)},i.src="data:image/webp;base64,"+e[t]})),Y}const Z=1.15;class tt{constructor(t,e){this._spriteSource=t,this._maxTextureSize=e,this.devicePixelRatio=1,this._spriteImageFormat="png",this._isRetina=!1,this._spritesData={},this.image=null,this.width=null,this.height=null,this.loadStatus="not-loaded","url"===t.type&&t.spriteFormat&&(this._spriteImageFormat=t.spriteFormat),t.pixelRatio&&(this.devicePixelRatio=t.pixelRatio),this.baseURL=t.spriteUrl}get spriteNames(){const t=[];for(const e in this._spritesData)t.push(e);return t.sort(),t}getSpriteInfo(t){return this._spritesData?this._spritesData[t]:null}async load(t){if(this.baseURL){this.loadStatus="loading";try{await this._loadSprites(t),this.loadStatus="loaded"}catch{this.loadStatus="failed"}}else this.loadStatus="failed"}async _loadSprites(s){this._isRetina=this.devicePixelRatio>Z;const{width:i,height:r,data:n,json:l}=await this._getSpriteData(this._spriteSource,s),o=Object.keys(l);if(!o||0===o.length||!n)return this._spritesData=this.image=null,void(this.width=this.height=0);this._spritesData=l,this.width=i,this.height=r;const a=Math.max(this._maxTextureSize,4096);if(i>a||r>a){const s=`Sprite resource for style ${this.baseURL} is bigger than the maximum allowed of ${a} pixels}`;throw t.getLogger("esri.layers.support.SpriteSource").error(s),new e("SpriteSource",s)}let u;for(let t=0;t<n.length;t+=4)u=n[t+3]/255,n[t]=n[t]*u,n[t+1]=n[t+1]*u,n[t+2]=n[t+2]*u;this.image=n}async _getSpriteData(t,o){if("image"===t.type){let r,n;if(this.devicePixelRatio<Z){if(!t.spriteSource1x)throw new e("SpriteSource","no image data provided for low resolution sprites!");r=t.spriteSource1x.image,n=t.spriteSource1x.json}else{if(!t.spriteSource2x)throw new e("SpriteSource","no image data provided for high resolution sprites!");r=t.spriteSource2x.image,n=t.spriteSource2x.json}return"width"in r&&"height"in r&&"data"in r&&(s(r.data)||i(r.data))?{width:r.width,height:r.height,data:new Uint8Array(r.data),json:n}:{...et(r),json:n}}const a=r(this.baseURL),u=a.query?"?"+n(a.query):"",h=this._isRetina?"@2x":"",c=`${a.path}${h}.${this._spriteImageFormat}${u}`,p=`${a.path}${h}.json${u}`,[y,f]=await Promise.all([l(p,o),l(c,{responseType:"image",...o})]);return{...et(f.data),json:y.data}}}function et(t){const e=document.createElement("canvas"),s=e.getContext("2d");e.width=t.width,e.height=t.height,s.drawImage(t,0,0,t.width,t.height);const i=s.getImageData(0,0,t.width,t.height);return{width:t.width,height:t.height,data:new Uint8Array(i.data)}}class st{constructor(t){this.url=t}destroy(){this._tileIndexPromise=null}async fetchTileIndex(){return this._tileIndexPromise||(this._tileIndexPromise=l(this.url).then((t=>t.data.index))),this._tileIndexPromise}async dataKey(t,e){const s=await this.fetchTileIndex();return o(e),this._getIndexedDataKey(s,t)}_getIndexedDataKey(t,e){const s=[e];if(e.level<0||e.row<0||e.col<0||e.row>>e.level>0||e.col>>e.level>0)return null;let i=e;for(;0!==i.level;)i=new q(i.level-1,i.row>>1,i.col>>1,i.world),s.push(i);let r,n,l=t,o=s.pop();if(1===l)return o;for(;s.length;)if(r=s.pop(),n=(1&r.col)+((1&r.row)<<1),l){if(0===l[n]){o=null;break}if(1===l[n]){o=r;break}o=r,l=l[n]}return o}}class it{constructor(t,e){this._tilemap=t,this._tileIndexUrl=e}destroy(){this._tilemap=a(this._tilemap),this._tileIndexPromise=null}async fetchTileIndex(t){return this._tileIndexPromise||(this._tileIndexPromise=l(this._tileIndexUrl,{query:{...t?.query}}).then((t=>t.data.index))),this._tileIndexPromise}dataKey(t,e){const{level:s,row:i,col:r}=t,n=new q(t);return this._tilemap.fetchAvailabilityUpsample(s,i,r,n,e).then((()=>(n.world=t.world,n))).catch((t=>{if(u(t))throw t;return null}))}}class rt{constructor(t){this._tileUrl=t,this._promise=null,this._abortController=null,this._abortOptions=[]}getData(t){null===this._promise&&(this._abortController=new AbortController,this._promise=this._makeRequest(this._tileUrl,this._abortController.signal));const e=this._abortOptions;return e.push(t),p(t,(()=>{e.every((t=>y(t)))&&this._abortController.abort()})),this._promise.then((t=>f(t)))}async _makeRequest(t,e){const{data:s}=await l(t,{responseType:"array-buffer",signal:e});return s}}const nt=new Map;function lt(t,e,s,i,n){const l=r(t),o=l.query;if(o)for(const[t,r]of Object.entries(o))switch(r){case"{x}":o[t]=i.toString();break;case"{y}":o[t]=s.toString();break;case"{z}":o[t]=e.toString()}const a=l.path;return ot(h(a.replaceAll(/\{z\}/gi,e.toString()).replaceAll(/\{y\}/gi,s.toString()).replaceAll(/\{x\}/gi,i.toString()),{...l.query}),n)}function ot(t,e){return c(nt,t,(()=>new rt(t))).getData(e).then((e=>(nt.delete(t),e))).catch((e=>{throw nt.delete(t),e}))}class at{constructor(t,e,s){this.tilemap=null,this.tileInfo=null,this.capabilities=null,this.fullExtent=null,this.name=t,this.sourceUrl=e;const i=r(this.sourceUrl),n=f(s),l=n.tiles;if(i)for(let t=0;t<l.length;t++){const e=r(l[t]);e&&(d(e.path)||(e.path=A(i.path,e.path)),l[t]=h(e.path,{...i.query,...e.query}))}this.tileServers=l;const o=s.capabilities&&s.capabilities.split(",").map((t=>t.toLowerCase().trim())),a=!0===s?.exportTilesAllowed,u=!0===o?.includes("tilemap"),c=a&&s.hasOwnProperty("maxExportTilesCount")?s.maxExportTilesCount:0;this.capabilities={operations:{supportsExportTiles:a,supportsTileMap:u},exportTiles:a?{maxExportTilesCount:+c}:null},this.tileInfo=J.fromJSON(n.tileInfo);const p=s.tileMap?h(A(i.path,s.tileMap),i.query??{}):null;u?(this.type="vector-tile",this.tilemap=new it(new F({layer:{parsedUrl:i,tileInfo:this.tileInfo},minLOD:n.minLOD??this.tileInfo.lods[0].level,maxLOD:n.maxLOD??this.tileInfo.lods[this.tileInfo.lods.length-1].level}),p)):p&&(this.tilemap=new st(p)),this.fullExtent=m.fromJSON(s.fullExtent)}destroy(){this.tilemap?.destroy()}async getRefKey(t,e){return await(this.tilemap?.dataKey(t,e))??t}requestTile(t,e,s,i){const r=this.tileServers[e%this.tileServers.length];return lt(r,t,e,s,i)}isCompatibleWith(t){const e=this.tileInfo,s=t.tileInfo;if(!e.spatialReference.equals(s.spatialReference))return!1;if(!e.origin.equals(s.origin))return!1;if(Math.round(e.dpi)!==Math.round(s.dpi))return!1;const i=e.lods,r=s.lods,n=Math.min(i.length,r.length);for(let t=0;t<n;t++){const e=i[t],s=r[t];if(e.level!==s.level||Math.round(e.scale)!==Math.round(s.scale))return!1}return!0}}async function ut(t,e){const s={source:null,sourceBase:null,sourceUrl:null,validatedSource:null,style:null,styleBase:null,styleUrl:null,sourceNameToSource:{},primarySourceName:"",spriteFormat:"png"},[i,r]="string"==typeof t?[t,null]:[null,t.jsonUrl];await ct(s,"esri",t,r,e);return{layerDefinition:s.validatedSource,url:i,serviceUrl:s.sourceUrl,style:s.style,styleUrl:s.styleUrl,spriteUrl:s.style.sprite&&ht(s.styleBase,s.style.sprite),spriteFormat:s.spriteFormat,glyphsUrl:s.style.glyphs&&ht(s.styleBase,s.style.glyphs),sourceNameToSource:s.sourceNameToSource,primarySourceName:s.primarySourceName}}function ht(...t){let e;for(const s of t)if(null!=s)if(w(s)){if(e){const t=e.split("://")[0];e=t+":"+s.trim()}}else e=d(s)?s:A(e,s);return e?g(e):void 0}async function ct(t,e,s,i,r){let n,a,u;if(o(r),"string"==typeof s){const t=v(s);u=await l(t,{...r,responseType:"json",query:{f:"json",...r?.query}}),u.ssl&&(n&&(n=n.replace(/^http:/i,"https:")),a&&(a=a.replace(/^http:/i,"https:"))),n=t,a=t}else null!=s&&(u={data:s},n=s.jsonUrl||null,a=i);const h=u?.data;if(pt(h))return t.styleUrl=n||null,ft(t,h,a,r);if(yt(h))return t.sourceUrl?dt(t,h,a,!1,e,r):(t.sourceUrl=n||null,dt(t,h,a,!0,e,r));throw new Error("You must specify the URL or the JSON for a service or for a style.")}function pt(t){return!!t&&"sources"in t&&!!t.sources}function yt(t){return!pt(t)}async function ft(t,e,s,i){const r=s?S(s):b();t.styleBase=r,t.style=e,e["sprite-format"]&&"webp"===e["sprite-format"].toLowerCase()&&(t.spriteFormat="webp");const n=[];if(e.sources&&e.sources.esri){const s=e.sources.esri;s.url?await ct(t,"esri",ht(r,s.url),void 0,i):n.push(ct(t,"esri",s,r,i))}for(const s of Object.keys(e.sources))"esri"!==s&&"vector"===e.sources[s].type&&(e.sources[s].url?n.push(ct(t,s,ht(r,e.sources[s].url),void 0,i)):e.sources[s].tiles&&n.push(ct(t,s,e.sources[s],r,i)));await Promise.all(n)}async function dt(t,e,s,i,r,n){const l=s?g(s)+"/":b(),o=At(e),a=new at(r,h(l,n?.query??{}),o);if(!i&&t.primarySourceName in t.sourceNameToSource){const e=t.sourceNameToSource[t.primarySourceName];if(!e.isCompatibleWith(a))return;null!=a.fullExtent&&(null!=e.fullExtent?e.fullExtent.union(a.fullExtent):e.fullExtent=a.fullExtent.clone()),e.tileInfo&&a.tileInfo&&e.tileInfo.lods.length<a.tileInfo.lods.length&&(e.tileInfo=a.tileInfo)}if(i&&(t.sourceBase=l,t.source=e,t.validatedSource=o,t.primarySourceName=r),t.sourceNameToSource[r]=a,!t.style){if(null==e.defaultStyles)throw new Error;return"string"==typeof e.defaultStyles?ct(t,"",ht(l,e.defaultStyles,"root.json"),void 0,n):ct(t,"",e.defaultStyles,ht(l,"root.json"),n)}}function At(t){if(t.hasOwnProperty("tileInfo"))return t;const e={xmin:-20037507.067161843,ymin:-20037507.067161843,xmax:20037507.067161843,ymax:20037507.067161843,spatialReference:{wkid:102100}},s=512;let i=78271.51696400007,r=295828763.7957775;const n=[],l=t.hasOwnProperty("minzoom")?+t.minzoom:0,o=t.hasOwnProperty("maxzoom")?+t.maxzoom:22;for(let t=0;t<=o;t++)t>=l&&n.push({level:t,scale:r,resolution:i}),i/=2,r/=2;return{capabilities:"TilesOnly",initialExtent:e,fullExtent:e,minScale:0,maxScale:0,tiles:t.tiles,tileInfo:{rows:s,cols:s,dpi:96,format:"pbf",origin:{x:-20037508.342787,y:20037508.342787},lods:n,spatialReference:{wkid:102100}}}}const mt=1e-6;function wt(t,e){if(t===e)return!0;if(null==t&&null!=e)return!1;if(null!=t&&null==e)return!1;if(null==t||null==e)return!1;if(!t.spatialReference.equals(e.spatialReference)||t.dpi!==e.dpi)return!1;const s=t.origin,i=e.origin;if(Math.abs(s.x-i.x)>=mt||Math.abs(s.y-i.y)>=mt)return!1;let r,n;t.lods[0].scale>e.lods[0].scale?(r=t,n=e):(n=t,r=e);for(let t=r.lods[0].scale;t>=n.lods[n.lods.length-1].scale-mt;t/=2)if(Math.abs(t-n.lods[0].scale)<mt)return!0;return!1}function gt(t,e){if(t===e)return t;if(null==t&&null!=e)return e;if(null!=t&&null==e)return t;if(null==t||null==e)return null;const s=t.size[0],i=t.format,r=t.dpi,n=new j({x:t.origin.x,y:t.origin.y}),l=t.spatialReference,o=t.lods[0].scale>e.lods[0].scale?t.lods[0]:e.lods[0],a=t.lods[t.lods.length-1].scale<=e.lods[e.lods.length-1].scale?t.lods[t.lods.length-1]:e.lods[e.lods.length-1],u=o.scale,h=o.resolution,c=a.scale,p=[];let y=u,f=h,d=0;for(;y>c;)p.push(new N({level:d,resolution:f,scale:y})),d++,y/=2,f/=2;return new J({size:[s,s],dpi:r,format:i||"pbf",origin:n,lods:p,spatialReference:l})}let vt=class extends(x(U(G(T(O(_(R(B(D(I)))))))))){constructor(...t){super(...t),this._spriteSourceMap=new Map,this.currentStyleInfo=null,this.style=null,this.isReference=null,this.operationalLayerType="VectorTileLayer",this.tilemapCache=null,this.type="vector-tile",this.url=null,this.showCollisionBoxes="none",this.path=null}normalizeCtorArgs(t,e){return"string"==typeof t?{url:t,...e}:t}destroy(){if(this.sourceNameToSource)for(const t of Object.values(this.sourceNameToSource))t?.destroy();this.primarySource?.destroy(),this._spriteSourceMap.clear()}async prefetchResources(t){await this.loadSpriteSource(globalThis.devicePixelRatio||1,t)}load(t){const e=this.loadFromPortal({supportedTypes:["Vector Tile Service"],supportsData:!1},t).catch(M).then((async()=>{if(!this.portalItem||!this.portalItem.id)return;const e=`${this.portalItem.itemCdnUrl}/resources/styles/root.json`;(await l(e,{...t,query:{f:"json",...this.customParameters,token:this.apiKey}})).data&&this.read({url:e},z(this.portalItem))})).catch(M).then((()=>this._loadStyle(t)));return this.addResolvingPromise(e),Promise.resolve(this)}get attributionDataUrl(){const t=this.currentStyleInfo,e=t&&t.serviceUrl&&r(t.serviceUrl);if(!e)return null;const s=this._getDefaultAttribution(e.path);return s?h(s,{...this.customParameters,token:this.apiKey}):null}get capabilities(){const t=this.primarySource;return t?t.capabilities:{operations:{supportsExportTiles:!1,supportsTileMap:!1},exportTiles:null}}get fullExtent(){return this.primarySource?.fullExtent||null}get parsedUrl(){return this.serviceUrl?r(this.serviceUrl):null}get serviceUrl(){return this.currentStyleInfo&&this.currentStyleInfo.serviceUrl||null}get spatialReference(){return this.tileInfo?.spatialReference??null}get styleUrl(){return this.currentStyleInfo&&this.currentStyleInfo.styleUrl||null}writeStyleUrl(t,e){t&&w(t)&&(t=`https:${t}`);const s=E(t);e.styleUrl=Q(t,s)}get tileInfo(){const t=[];for(const e in this.sourceNameToSource)t.push(this.sourceNameToSource[e]);let e=this.primarySource?.tileInfo||new J;if(t.length>1)for(let s=0;s<t.length;s++)wt(e,t[s].tileInfo)&&(e=gt(e,t[s].tileInfo));return e}readTilemapCache(t,e){const s=e.capabilities?.includes("Tilemap");return s?new F({layer:this}):null}readVersion(t,e){return e.version?parseFloat(e.version):parseFloat(e.currentVersion)}async loadSpriteSource(t=1,e){if(!this._spriteSourceMap.has(t)){const s=X("2d").maxTextureSize,i=this.currentStyleInfo?.spriteUrl?h(this.currentStyleInfo.spriteUrl,{...this.customParameters,token:this.apiKey}):null,r=new tt({type:"url",spriteUrl:i,pixelRatio:t,spriteFormat:this.currentStyleInfo?.spriteFormat},s);await r.load(e),this._spriteSourceMap.set(t,r)}return this._spriteSourceMap.get(t)}async setSpriteSource(t,e){if(!t)return null;const s=X("2d").maxTextureSize,i=t.spriteUrl,r=i?h(i,{...this.customParameters,token:this.apiKey}):null;if(!r&&"url"===t.type)return null;const n=new tt(t,s);try{await n.load(e);const s=t.pixelRatio||1;return this._spriteSourceMap.clear(),this._spriteSourceMap.set(s,n),r&&this.currentStyleInfo&&(this.currentStyleInfo.spriteUrl=r),this.emit("spriteSource-change",{spriteSource:n}),n}catch(t){M(t)}return null}async loadStyle(t,e){const s=t||this.style||this.url;return this._loadingTask&&"string"==typeof s&&this.url===s||(this._loadingTask?.abort(),this._loadingTask=k((t=>(this._spriteSourceMap.clear(),this._getSourceAndStyle(s,{signal:t}))),e)),this._loadingTask.promise}getStyleLayerId(t){return this.styleRepository.getStyleLayerId(t)}getStyleLayerIndex(t){return this.styleRepository.getStyleLayerIndex(t)}getPaintProperties(t){return f(this.styleRepository.getPaintProperties(t))}setPaintProperties(t,e){const s=this.styleRepository.isPainterDataDriven(t);this.styleRepository.setPaintProperties(t,e);const i=this.styleRepository.isPainterDataDriven(t);this.emit("paint-change",{layer:t,paint:e,isDataDriven:s||i})}getStyleLayer(t){return f(this.styleRepository.getStyleLayer(t))}setStyleLayer(t,e){this.styleRepository.setStyleLayer(t,e),this.emit("style-layer-change",{layer:t,index:e})}deleteStyleLayer(t){this.styleRepository.deleteStyleLayer(t),this.emit("delete-style-layer",{layer:t})}getLayoutProperties(t){return f(this.styleRepository.getLayoutProperties(t))}setLayoutProperties(t,e){this.styleRepository.setLayoutProperties(t,e),this.emit("layout-change",{layer:t,layout:e})}setStyleLayerVisibility(t,e){this.styleRepository.setStyleLayerVisibility(t,e),this.emit("style-layer-visibility-change",{layer:t,visibility:e})}getStyleLayerVisibility(t){return this.styleRepository.getStyleLayerVisibility(t)}write(t,s){return s?.origin&&!this.styleUrl?(s.messages&&s.messages.push(new e("vectortilelayer:unsupported",`VectorTileLayer (${this.title}, ${this.id}) with style defined by JSON only are not supported`,{layer:this})),null):super.write(t,s)}getTileUrl(t,e,s){return null}async _getSourceAndStyle(t,e){if(!t)throw new Error("invalid style!");const s=await ut(t,{...e,query:{...this.customParameters,token:this.apiKey}});if("webp"===s.spriteFormat){await H("lossy")||(s.spriteFormat="png")}this._set("currentStyleInfo",{...s}),"string"==typeof t?(this.url=t,this.style=null):(this.url=null,this.style=t),this._set("sourceNameToSource",s.sourceNameToSource),this._set("primarySource",s.sourceNameToSource[s.primarySourceName]),this._set("styleRepository",new K(s.style)),this.read(s.layerDefinition,{origin:"service"}),this.emit("load-style")}_getDefaultAttribution(t){const e=t.match(/^https?:\/\/(?:basemaps|basemapsbeta|basemapsdev)(?:-api)?\.arcgis\.com(\/[^\/]+)?\/arcgis\/rest\/services\/([^\/]+(\/[^\/]+)*)\/vectortileserver/i),s=["OpenStreetMap_v2","OpenStreetMap_Daylight_v2","OpenStreetMap_Export_v2","OpenStreetMap_FTS_v2","OpenStreetMap_GCS_v2","World_Basemap","World_Basemap_v2","World_Basemap_Export_v2","World_Basemap_GCS_v2","World_Basemap_WGS84","World_Contours_v2"];if(!e)return;const i=e[2]&&e[2].toLowerCase();if(!i)return;const r=e[1]||"";for(const t of s)if(t.toLowerCase().includes(i))return v(`//static.arcgis.com/attribution/Vector${r}/${t}`)}async _loadStyle(t){return this._loadingTask?.promise??this.loadStyle(null,t)}};L([C({readOnly:!0})],vt.prototype,"attributionDataUrl",null),L([C({type:["show","hide"]})],vt.prototype,"listMode",void 0),L([C({json:{read:!0,write:!0}})],vt.prototype,"blendMode",void 0),L([C({readOnly:!0,json:{read:!1}})],vt.prototype,"capabilities",null),L([C({readOnly:!0})],vt.prototype,"currentStyleInfo",void 0),L([C({json:{read:!1},readOnly:!0,type:m})],vt.prototype,"fullExtent",null),L([C()],vt.prototype,"style",void 0),L([C({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],vt.prototype,"isReference",void 0),L([C({type:["VectorTileLayer"]})],vt.prototype,"operationalLayerType",void 0),L([C({readOnly:!0})],vt.prototype,"parsedUrl",null),L([C({readOnly:!0})],vt.prototype,"serviceUrl",null),L([C({type:P,readOnly:!0})],vt.prototype,"spatialReference",null),L([C({readOnly:!0})],vt.prototype,"styleRepository",void 0),L([C({readOnly:!0})],vt.prototype,"sourceNameToSource",void 0),L([C({readOnly:!0})],vt.prototype,"primarySource",void 0),L([C({type:String,readOnly:!0,json:{write:{ignoreOrigin:!0},origins:{"web-document":{write:{ignoreOrigin:!0,isRequired:!0}}}}})],vt.prototype,"styleUrl",null),L([V(["portal-item","web-document"],"styleUrl")],vt.prototype,"writeStyleUrl",null),L([C({json:{read:!1,origins:{service:{read:!1}}},readOnly:!0,type:J})],vt.prototype,"tileInfo",null),L([C()],vt.prototype,"tilemapCache",void 0),L([$("service","tilemapCache",["capabilities","tileInfo"])],vt.prototype,"readTilemapCache",null),L([C({json:{read:!1},readOnly:!0,value:"vector-tile"})],vt.prototype,"type",void 0),L([C({json:{origins:{"web-document":{read:{source:"styleUrl"}},"portal-item":{read:{source:"url"}}},write:!1,read:!1}})],vt.prototype,"url",void 0),L([C({readOnly:!0})],vt.prototype,"version",void 0),L([$("version",["version","currentVersion"])],vt.prototype,"readVersion",null),L([C({type:String})],vt.prototype,"showCollisionBoxes",void 0),L([C({type:String,json:{origins:{"web-scene":{read:!0,write:!0}},read:!1}})],vt.prototype,"path",void 0),vt=L([W("esri.layers.VectorTileLayer")],vt);const St=vt;export default St;
//# sourceMappingURL=p-1c99d78f.js.map