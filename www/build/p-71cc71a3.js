import{dr as t,s as e,E as s,dF as i,ar as r,Q as a,b as n,aR as o,dJ as p,e as l,cc as c}from"./p-b54724b6.js";import{r as d,s as u,e as h,n as f,t as m}from"./p-a3f0a5f3.js";import{m as y}from"./p-ed4e008d.js";import{f as j,g}from"./p-8eb5caaf.js";import{e as w}from"./p-66b640a7.js";import{L as b,I,T as F}from"./p-7a0db0bb.js";import{a as T,i as E,o as R}from"./p-5525ea5e.js";import{y as S,d as x,c as _,u as v,h as D}from"./p-053e4f44.js";import"./p-e6a64715.js";import"./p-dc29c329.js";import"./p-48f43d72.js";import"./p-fd8dc94a.js";import"./p-9a4094ba.js";import"./p-9f1a0adc.js";import"./p-d8b2b368.js";import"./p-a5e3ec2a.js";import"./p-80be55a5.js";import"./p-c6ce33a2.js";import"./p-b8ded059.js";import"./p-623dbe5e.js";import"./p-1b4a7439.js";import"./p-98e621d1.js";import"./p-1b31d781.js";import"./p-c19b935f.js";const Q={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};class O{constructor(){this._queryEngine=null,this._snapshotFeatures=async t=>{const e=await this._fetch(t);return this._createFeatures(e)}}destroy(){this._queryEngine?.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(r,a={}){this._loadOptions={url:r.url,customParameters:r.customParameters};const n=[];await this._checkProjection(r.spatialReference);let o=null;r.url&&(o=await this._fetch(a?.signal));const l=b(o,{geometryType:r.geometryType}),c=r.fields||l.fields||[],d=null!=r.hasZ?r.hasZ:l.hasZ,u=l.geometryType;let h=r.objectIdField||l.objectIdFieldName||"__OBJECTID";const f=r.spatialReference||p;let m=r.timeInfo;c===l.fields&&l.unknownFields.length>0&&n.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:l.unknownFields}});let j=new t(c).get(h);j?("esriFieldTypeString"!==j.type&&(j.type="esriFieldTypeOID"),j.editable=!1,j.nullable=!1,h=j.name):(j={alias:h,name:h,type:"string"===l.objectIdFieldType?"esriFieldTypeString":"esriFieldTypeOID",editable:!1,nullable:!1},c.unshift(j));const g={};for(const t of c){if(null==t.name&&(t.name=t.alias),null==t.alias&&(t.alias=t.name),!t.name)throw new e("geojson-layer:invalid-field-name","field name is missing",{field:t});if(!s.jsonValues.includes(t.type))throw new e("geojson-layer:invalid-field-type",`invalid type for field "${t.name}"`,{field:t});if(t.name!==j.name){const e=i(t);void 0!==e&&(g[t.name]=e)}}this._fieldsIndex=new t(c);const I=this._fieldsIndex.requiredFields.indexOf(j);if(I>-1&&this._fieldsIndex.requiredFields.splice(I,1),m){if(m.startTimeField){const t=this._fieldsIndex.get(m.startTimeField);t?(m.startTimeField=t.name,t.type="esriFieldTypeDate"):m.startTimeField=null}if(m.endTimeField){const t=this._fieldsIndex.get(m.endTimeField);t?(m.endTimeField=t.name,t.type="esriFieldTypeDate"):m.endTimeField=null}if(m.trackIdField){const t=this._fieldsIndex.get(m.trackIdField);t?m.trackIdField=t.name:(m.trackIdField=null,n.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:m}}))}m.startTimeField||m.endTimeField||(n.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:m}}),m=null)}const F=u?R(u):void 0,S={warnings:n,featureErrors:[],layerDefinition:{...Q,drawingInfo:F??void 0,templates:T(g),extent:void 0,geometryType:u,objectIdField:h,fields:c,hasZ:!!d,timeInfo:m}};this._queryEngine=new w({fields:c,geometryType:u,hasM:!1,hasZ:d,objectIdField:h,spatialReference:f,timeInfo:m,featureStore:new y({geometryType:u,hasM:!1,hasZ:d}),cacheSpatialQueries:!0}),this._createDefaultAttributes=E(g,h);const x=await this._createFeatures(o);this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,x);const _=this._normalizeFeatures(x,S.warnings,S.featureErrors);this._queryEngine.featureStore.addMany(_);const{fullExtent:v,timeExtent:D}=await this._queryEngine.fetchRecomputedExtents();if(S.layerDefinition.extent=v,D){const{start:t,end:e}=D;S.layerDefinition.timeInfo.timeExtent=[t,e]}return S}async applyEdits(t){const{spatialReference:e,geometryType:s}=this._queryEngine;return await Promise.all([S(e,s),j(t.adds,e),j(t.updates,e)]),await this._waitSnapshotComplete(),this._applyEdits(t)}async queryFeatures(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(t,e.signal)}async queryFeatureCount(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(t,e.signal)}async queryObjectIds(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(t,e.signal)}async queryExtent(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(t,e.signal)}async querySnapping(t,e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(t,e.signal)}async refresh(t){this._loadOptions.customParameters=t,this._snapshotTask?.abort(),this._snapshotTask=r(this._snapshotFeatures),this._snapshotTask.promise.then((t=>{this._queryEngine.featureStore.clear(),this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,t);const e=this._normalizeFeatures(t);e&&this._queryEngine.featureStore.addMany(e)}),(t=>{this._queryEngine.featureStore.clear(),a(t)||n.getLogger("esri.layers.GeoJSONLayer").error(new e("geojson-layer:refresh","An error occurred during refresh",{error:t}))})),await this._waitSnapshotComplete();const{fullExtent:s,timeExtent:i}=await this._queryEngine.fetchRecomputedExtents();return{extent:s,timeExtent:i}}async _createFeatures(t){if(null==t)return[];const{geometryType:e,hasZ:s,objectIdField:i}=this._queryEngine,r=I(t,{geometryType:e,hasZ:s,objectIdField:i});if(!o(this._queryEngine.spatialReference,p))for(const t of r)null!=t.geometry&&(t.geometry=d(g(u(t.geometry,this._queryEngine.geometryType,this._queryEngine.hasZ,!1),p,this._queryEngine.spatialReference)));return r}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(t){const{url:e,customParameters:s}=this._loadOptions,i=(await l(e,{responseType:"json",query:{...s},signal:t})).data;return await F(i),i}_normalizeFeatures(t,e,s){const{objectIdField:i}=this._queryEngine,r=[];for(const a of t){const t=this._createDefaultAttributes(),n=x(this._fieldsIndex,t,a.attributes,!0,e);n?s?.push(n):(this._assignObjectId(t,a.attributes,!0),a.attributes=t,a.objectId=t[i],r.push(a))}return r}async _applyEdits(t){const{adds:e,updates:s,deletes:i}=t,r={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(e&&e.length&&this._applyAddEdits(r,e),s&&s.length&&this._applyUpdateEdits(r,s),i&&i.length){for(const t of i)r.deleteResults.push(_(t));this._queryEngine.featureStore.removeManyById(i)}const{fullExtent:a,timeExtent:n}=await this._queryEngine.fetchRecomputedExtents();return{extent:a,timeExtent:n,featureEditResults:r}}_applyAddEdits(t,e){const{addResults:s}=t,{geometryType:i,hasM:r,hasZ:a,objectIdField:n,spatialReference:o,featureStore:p}=this._queryEngine,l=[];for(const r of e){if(r.geometry&&i!==c(r.geometry)){s.push(v("Incorrect geometry type."));continue}const e=this._createDefaultAttributes(),a=x(this._fieldsIndex,e,r.attributes);if(a)s.push(a);else{if(this._assignObjectId(e,r.attributes),r.attributes=e,null!=r.uid){const e=r.attributes[n];t.uidToObjectId[r.uid]=e}if(null!=r.geometry){const t=r.geometry.spatialReference??o;r.geometry=g(D(r.geometry,t),t,o)}l.push(r),s.push(_(r.attributes[n]))}}p.addMany(h([],l,i,a,r,n))}_applyUpdateEdits({updateResults:t},e){const{geometryType:s,hasM:i,hasZ:r,objectIdField:a,spatialReference:n,featureStore:o}=this._queryEngine;for(const p of e){const{attributes:e,geometry:l}=p,d=e&&e[a];if(null==d){t.push(v(`Identifier field ${a} missing`));continue}if(!o.has(d)){t.push(v(`Feature with object id ${d} missing`));continue}const u=f(o.getFeature(d),s,r,i);if(null!=l){if(s!==c(l)){t.push(v("Incorrect geometry type."));continue}const e=l.spatialReference??n;u.geometry=g(D(l,e),e,n)}if(e){const s=x(this._fieldsIndex,u.attributes,e);if(s){t.push(s);continue}}o.add(m(u,s,r,i,a)),t.push(_(d))}}_createObjectIdGenerator(t,e){const s=t.fieldsIndex.get(t.objectIdField);if("esriFieldTypeString"===s.type)return()=>s.name+"-"+Date.now().toString(16);let i=Number.NEGATIVE_INFINITY;for(const t of e)t.objectId&&(i=Math.max(i,t.objectId));return i=Math.max(0,i)+1,()=>i++}_assignObjectId(t,e,s=!1){const i=this._queryEngine.objectIdField;t[i]=s&&i in e?e[i]:this._objectIdGenerator()}async _checkProjection(t){try{await j(p,t)}catch{throw new e("geojson-layer","Projection not supported")}}}export default O;
//# sourceMappingURL=p-71cc71a3.js.map