import{f_ as t,b7 as s,bM as i,b2 as e,cc as n,c4 as r,dQ as o,f$ as h,e_ as c,dX as l,bX as u,g0 as a,h as f,g1 as d,aO as p,a3 as m,ad as w,w as y,R as g,g2 as x,g3 as v,aU as b,cK as _,F as M,c3 as B,c6 as D,g4 as A,Q as F,c2 as j,c5 as T,g5 as C,g6 as S,g7 as P,l as G,y as I,n as L}from"./p-b54724b6.js";import{s as R,d as z,g as U,b as O}from"./p-399020b7.js";import{a as k}from"./p-89e4900b.js";import{f as V,g as X}from"./p-8eb5caaf.js";import{X as q}from"./p-570a8a46.js";import{x as E,j as K,F as N,H as Q,Y,P as H,R as Z,t as $,S as J}from"./p-29040467.js";import{u as W,c as tt}from"./p-1fd43aa6.js";import{F as st}from"./p-13e550f5.js";import{m as it,r as et,T as nt,_ as rt}from"./p-b6ec07fb.js";import{U as ot}from"./p-5b0b1d68.js";import{a as ht,o as ct,x as lt,b as ut,r as at,E as ft}from"./p-fb79aaf0.js";import{h as dt,I as pt,r as mt,B as wt}from"./p-0357efed.js";import{o as yt,C as gt,d as xt,h as vt,$ as bt}from"./p-a3f0a5f3.js";import{i as _t}from"./p-cd4a8b9a.js";import{v as Mt}from"./p-a5e3ec2a.js";import{L as Bt,b as Dt}from"./p-98e621d1.js";import{t as At}from"./p-e6a64715.js";import"./p-faf4e331.js";import"./p-74887bd8.js";import"./p-2d1dac84.js";import{n as Ft}from"./p-a379c2ce.js";import{createSymbolSchema as jt}from"./p-8eafbd05.js";const Tt=-1;class Ct{constructor(){this._dirties=[{vertexFrom:Tt,vertexCount:Tt,indexFrom:Tt,indexCount:Tt,allDirty:!1},{vertexFrom:Tt,vertexCount:Tt,indexFrom:Tt,indexCount:Tt,allDirty:!1},{vertexFrom:Tt,vertexCount:Tt,indexFrom:Tt,indexCount:Tt,allDirty:!1},{vertexFrom:Tt,vertexCount:Tt,indexFrom:Tt,indexCount:Tt,allDirty:!1},{vertexFrom:Tt,vertexCount:Tt,indexFrom:Tt,indexCount:Tt,allDirty:!1}]}hasDirty(){return this._dirties.some((t=>t.indexCount!==Tt||t.allDirty))}markAllClean(){for(const t of this._dirties)t.indexFrom=Tt,t.indexCount=Tt,t.vertexFrom=Tt,t.vertexCount=Tt,t.allDirty=!1}markAllDirty(){for(const t of this._dirties)t.allDirty=!0}forEach(t){for(let s=0;s<this._dirties.length;++s){const{indexCount:i,indexFrom:e,vertexCount:n,vertexFrom:r,allDirty:o}=this._dirties[s],h={};let c,l=!1;(o||r!==Tt&&n>0)&&(h.geometry={count:n,from:r,allDirty:o},l=!0),(o||e!==Tt&&i>0)&&(c={count:i,from:e,allDirty:o},l=!0),l&&t({indices:c,vertices:h},s)}}markDirtyIndices(t,s,i){const e=this._dirties[t],n=s,r=i;if(!e.allDirty)if(e.indexCount!==Tt){const t=Math.min(e.indexFrom,n),s=Math.max(e.indexFrom+e.indexCount,n+r)-t;e.indexFrom=t,e.indexCount=s}else e.indexFrom=n,e.indexCount=r}markDirtyVertices(t,s,i,e){const n=this._dirties[t],r=i,o=e;if(!n.allDirty)if(n.vertexCount!==Tt){const t=Math.min(n.vertexFrom,r),s=Math.max(n.vertexFrom+n.vertexCount,r+o)-t;n.vertexFrom=t,n.vertexCount=s}else n.vertexFrom=r,n.vertexCount=o}}class St{get largestRange(){return this._largestRange}constructor(t){this._largestRange=null,this._parent=t,this._updateLargestRange()}rangeCreated(t){(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}rangeResized(t,s){t===this._largestRange?t.count<s&&this._updateLargestRange():(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}findBestRange(t){let s=this._parent._freeHead,i=null;for(;null!==s;)s.count>=t&&(!i||s.count-t<i.count-t)&&(i=s),s=s.next;return i}findAdjacentRanges(t,s){let i=!0,e=!1,n=null,r=this._parent._freeHead;for(;i&&!e;){const o=null!==n?n.from+n.count:0,h=null!==r?r.from:this._parent._size;t>=o&&t+s<=h?(i=!1,e=!0):null!==r?(n=r,r=r.next):i=!1}return[n,r]}_updateLargestRange(){let t=null,s=this._parent._freeHead;for(;null!==s;)(!t||s.count>t.count)&&(t=s),s=s.next;this._largestRange=t}}class Pt{constructor(t,s){this._allocated=0,this._size=t,this._freeHead=t>0?{from:0,count:t,prev:null,next:null}:null,this._bookKeeper=s||new St(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(t){const s=this._bookKeeper.findBestRange(t);if(null==s)return-1;const i=s.from,e=s.count;if(s.from+=t,s.count-=t,this._bookKeeper.rangeResized(s,i,e),this._allocated+=t,0===s.count){const t=null!==s.prev?this._freeHead:s.next;Pt._removeRange(s),this._freeHead=t}return i}free(t,s){const[i,e]=this._bookKeeper.findAdjacentRanges(t,s),n={from:t,count:s,prev:i??null,next:e??null};if(null!=i&&(i.next=n),null!=e&&(e.prev=n),this._bookKeeper.rangeCreated(n),this._allocated-=s,null!=e&&n.from+n.count===e.from){const t=n.from,s=n.count;Pt._fuse(n,e),Pt._removeRange(e),this._bookKeeper.rangeResized(n,t,s),this._bookKeeper.rangeResized(e,void 0,0)}if(null!=i&&i.from+i.count===n.from){const t=i.from,s=i.count;Pt._fuse(i,n),Pt._removeRange(n),this._bookKeeper.rangeResized(i,t,s),this._bookKeeper.rangeResized(n,void 0,0)}this._freeHead=null!==n.prev?this._freeHead:n}get fragmentation(){const t=this._size-this._allocated;if(0===t)return 0;return 1-this._bookKeeper.largestRange.count/t}static _removeRange(t){null!==t.prev?null!==t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null:null!==t.next&&(t.next.prev=null)}static _fuse(t,s){t.count+=s.count,t.next=s.next,s.from+=s.count,s.count=0,null!==s.next&&(s.next.prev=t)}}const Gt=["FILL","LINE","MARKER","TEXT","LABEL"];function It(t){const s=t.getStrides(),i={};for(let t=0;t<s.length;t++)i[Gt[t]]=s[t];return i}const Lt=.5;class Rt{constructor(t,s,i,e){this._strides=t,this._displayList=s,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=i;for(const s in t){this._freeListsAndStorage[s]={vtxFreeList:e?new Pt(e):null,idxFreeList:e?new Pt(e):null,vertexBuffers:{},indexBuffer:e?new Uint32Array(e):null};for(const i in t[s])this._freeListsAndStorage[s].vertexBuffers[i]={data:e?E(e,t[s][i]):null,stride:t[s][i]}}}static fromTileData(t,s){const i=It(t),e=[0,0,0,0,0],n=[0,0,0,0,0];for(const s of t.tileDisplayData.displayObjects)for(const t of s.displayRecords)e[t.geometryType]=Math.max(e[t.geometryType],t.vertexFrom+t.vertexCount),n[t.geometryType]=Math.max(n[t.geometryType],t.indexFrom+t.indexCount);const r=new Rt(i,t.tileDisplayData.displayList,s,void 0),o=t.tileBufferData?.geometries??[];for(let t=0;t<o.length;++t){const s=e[t],i=n[t],h=o[t],c=Gt[t],l=r._storageFor(c),u=o[t].indexBuffer;l.indexBuffer=u,l.idxFreeList=new Pt(u.length),l.idxFreeList.allocate(i);let a=0;for(const s in h.vertexBuffer){const i=o[t].vertexBuffer[s];l.vertexBuffers[s].data=i.data,l.vertexBuffers[s].stride=i.stride;const e=N(i.stride),n=i.data.length*e/i.stride;a||(a=n)}l.vtxFreeList=new Pt(a),l.vtxFreeList.allocate(s)}return r}delete(t){const s=Gt[t.geometryType];this._freeVertices(s,t.vertexFrom,t.vertexCount),this._freeIndices(s,t.indexFrom,t.indexCount),this._displayList.removeFromList(t),t.vertexFrom=void 0,t.indexFrom=void 0}setMeshData(t,s,i,e,n){const r=Gt[t.geometryType];let o,h;t.meshData=null,void 0===t.vertexFrom?(h=s.vertexCount,o=this._allocateVertices(r,h)):s.vertexCount>t.vertexCount?(this._freeVertices(r,t.vertexFrom,t.vertexCount),h=s.vertexCount,o=this._allocateVertices(r,h)):s.vertexCount===t.vertexCount?(o=t.vertexFrom,h=t.vertexCount):(this._freeVertices(r,t.vertexFrom+s.vertexCount,t.vertexCount-s.vertexCount),o=t.vertexFrom,h=s.vertexCount);let c,l,u,a=!0;if(void 0===t.indexFrom?(c=n,u=s.indexCount,l=this._allocateIndices(r,u)):s.indexCount>t.indexCount?(c=this._displayList.removeFromList(t),this._freeIndices(r,t.indexFrom,t.indexCount),u=s.indexCount,l=this._allocateIndices(r,u)):s.indexCount===t.indexCount?(a=!1,l=t.indexFrom,u=t.indexCount):(c=this._displayList.removeFromList(t),this._freeIndices(r,t.indexFrom+s.indexCount,t.indexCount-s.indexCount),l=t.indexFrom,u=s.indexCount),-1!==o&&-1!==l){const n=this._storageFor(r);if(K(o,l,n.vertexBuffers,n.indexBuffer,s,i,e),t.vertexFrom=o,t.indexFrom=l,t.vertexCount=s.vertexCount,t.indexCount=s.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const s in i)this._dirtyMap.markDirtyVertices(t.geometryType,s,t.vertexFrom,t.vertexCount)}return a&&this._displayList.addToList(t,c),!0}return-1!==o&&this._freeVertices(r,o,h),-1!==l&&this._freeIndices(r,l,u),t.setMeshDataFromBuffers(s,i,e),t.vertexFrom=void 0,t.vertexCount=0,t.indexFrom=void 0,t.indexCount=0,!1}tryAddMeshData(t,s){const i=s.vertexBuffer,e=s.indexBuffer,n=Gt[t.geometryType],r=this._allocateVertices(n,t.vertexCount);if(-1===r)return this._freeVertices(n,r,t.vertexCount),!1;const o=this._allocateIndices(n,t.indexCount);if(-1===o)return this._freeVertices(n,r,t.vertexCount),this._freeIndices(n,o,t.indexCount),!1;const h=this._storageFor(n);if(K(r,o,h.vertexBuffers,h.indexBuffer,t,i,e),t.vertexFrom=r,t.indexFrom=o,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const s in i)this._dirtyMap.markDirtyVertices(t.geometryType,s,r,t.vertexCount)}return this._displayList.addToList(t),!0}_allocateVertices(t,s){const i=this._storageFor(t),e=i.vtxFreeList?.allocate(s);if(null==e||-1===e)return-1;const n=i.vtxFreeList?.fragmentation;return null==n||n>Lt?-1:e}_freeVertices(t,s,i){const e=this._storageFor(t);e.vtxFreeList?.free(s,i)}_freeIndices(t,s,i){const e=this._storageFor(t);e.idxFreeList?.free(s,i)}_allocateIndices(t,s){const i=this._storageFor(t),e=i.idxFreeList?.allocate(s);if(null==e||-1===e)return-1;const n=i.idxFreeList?.fragmentation;return null==n||n>Lt?-1:e}_storageFor(t){return this._freeListsAndStorage[t]}_stridesFor(t,s){return this._strides[t][s]}}class zt{constructor(t){this.geometryMap=Q((()=>({indexBuffer:tt.createIndex(t,st.STATIC_DRAW),vao:null})),((s,i)=>({vertexBuffer:tt.createVertex(t,Y[i])})))}dispose(){for(let t=0;t<5;t++){const s=this.geometryMap[t];if(s){s.data.vao?.disposeVAOOnly(),s.data.indexBuffer?.dispose();for(const t in s.buffers)s.buffers[t]?.data.vertexBuffer.dispose()}}}get(t){const s=this.geometryMap[t];return{getVAO(t,i,e){if(!s.data.vao){const n={};for(const t in s.buffers)n[t]=s.buffers[t].data.vertexBuffer;s.data.vao=new W(t,e,i,n,s.data.indexBuffer)}return s.data.vao}}}has(t){return null!=this.geometryMap[t]}upload(t,s){s.forEach(((s,i)=>{this._upload(s,i,t)}))}_upload(t,s,i){if(t.indices&&(t.indices.allDirty?this._uploadIndices(i,s):null!=t.indices.from&&null!=t.indices.count&&this._uploadIndices(i,s,t.indices.from,t.indices.count)),t.vertices){const e=t.vertices;for(const t in e){const n=e[t];n.allDirty?this._uploadVertices(i,s,t):null!=n.from&&null!=n.count&&this._uploadVertices(i,s,t,n.from,n.count)}}}_uploadVertices(t,s,i,e,n){const r=this.geometryMap[s];if(!r)return;const o=t.geometries[s].vertexBuffer[i];if(!o)return;const{data:h,stride:c}=o;if(r.buffers[i]&&h.length>0){const t=c/h.BYTES_PER_ELEMENT;null!=e&&null!=n?r.buffers[i].data.vertexBuffer.setSubData(h,e*t,e*t,(e+n)*t):r.buffers[i].data.vertexBuffer.setData(h)}}_uploadIndices(t,s,i,e){const n=this.geometryMap[s];if(!n)return;const r=t.geometries[s].indexBuffer;n.data.indexBuffer&&r.length>0&&(null!=i&&null!=e?n.data.indexBuffer.setSubData(r,i,i,i+e):n.data.indexBuffer.setData(r))}}class Ut extends it{constructor(){super(...arguments),this._data=null,this._displayList=null,this._lastCommitTime=0,this._hasData=!1,this._invalidated=!1,this._wglBuffers=null,this._dirtyMap=new Ct}destroy(){super.destroy(),this.clear()}get hasData(){return!!this._hasData}get displayObjects(){return this._displayObjects??[]}getGeometry(t){return this._wglBuffers&&this._wglBuffers.has(t)?this._wglBuffers.get(t):null}getDisplayList(){return this._displayList}patch(t){if(!0===t.clear)return this.clear(),void(this._hasData=!1);const s=t.addOrUpdate,i=t.remove;!this._data&&s&&s.tileDisplayData?.displayObjects.length?(s.tileDisplayData.computeDisplayList(),this._dirtyMap=new Ct,this._dispRecStore=Rt.fromTileData(s,this._dirtyMap),this._data=s,this._dirtyMap.markAllDirty(),this._hasData=!0,t.end&&this.ready()):this._data&&(s&&s.tileDisplayData?.displayObjects.length||i.length)?this._doPatchData(t):t.end&&this.ready(),t.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}commit(t){t.time&&t.time===this._lastCommitTime||(this._lastCommitTime=t.time,this.visible&&this._data&&(this._wglBuffers||(this._wglBuffers=new zt(t.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._dirtyMap.markAllClean())))}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(t){this._invalidated=!0,this._patchData(t)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=Rt.fromTileData(this._data,this._dirtyMap)),this.requestRender()}_patchData(t){let s=!0;const i=t.addOrUpdate&&t.addOrUpdate.tileDisplayData&&t.addOrUpdate.tileDisplayData.displayObjects||[],e=(t.remove||[]).slice();for(const t of i)null!=t.insertAfter&&e.push(t.id);let n;e.length>0&&(n=new Set(e));const r=this._data.tileDisplayData;for(const t of e){const s=r.displayObjectRegistry.get(t);if(s){r.displayList.removeFromList(s.displayRecords);for(const t of s.displayRecords)this._dispRecStore.delete(t);r.displayObjectRegistry.delete(t)}}n?.size&&(r.displayObjects=r.displayObjects.filter((t=>!n.has(t.id))));for(const e of i){let i,n=r.displayObjectRegistry.get(e.id);if(n){const t=n.displayRecords;n.set(e),n.displayRecords=t;const s=n.displayRecords.length;for(let t=0;t<s;++t){const s=n.displayRecords[t],i=e.displayRecords[t];(t>=e.displayRecords.length||s.geometryType!==i.geometryType||s.symbolLevel!==i.symbolLevel||s.zOrder!==i.zOrder||s.materialKey!==i.materialKey)&&(this._dispRecStore.delete(n.displayRecords[t]),t<e.displayRecords.length&&(n.displayRecords[t]=void 0))}n.displayRecords.length=e.displayRecords.length}else{let t;n=e.copy(),n.displayRecords=[],r.displayObjectRegistry.set(e.id,n);const s=r.displayObjects;if(null!=n.insertAfter)if(i={},n.insertAfter>=0){const i=r.displayObjectRegistry.get(n.insertAfter);i?(t=s.indexOf(i)+1,t<s.length?s.splice(t,0,n):(s.push(n),t=s.length)):(s.push(n),t=s.length)}else s.unshift(n),t=0;else s.push(n),t=s.length;if(i){const n=e.displayRecords.length>0?1:0;let o=0;for(let e=t-1;e>=0&&o<n;--e)for(let t=s[e].displayRecords.length-1;t>=0&&o<n;--t){const n=s[e].displayRecords[t],h=r.displayList.getDPInfoType();i[h]||(i[h]=n,++o)}}}const o=e.displayRecords.length;for(let h=0;h<o;++h){const o=e.displayRecords[h];let c=n.displayRecords[h];c?(c.meshData=o.meshData,c.materialKey=o.materialKey):(c=o.copy(),c.vertexFrom=void 0,c.indexFrom=void 0,n.displayRecords[h]=c);const l=o.geometryType,u=r.displayList.getDPInfoType(),a=t.addOrUpdate.tileBufferData.geometries[l],f=a.vertexBuffer,d=a.indexBuffer;let p;i&&(p=i[u]?r.displayList.splitAfter(i[u]):-1),s=this._dispRecStore.setMeshData(c,o,f,d,p)&&s,i&&null!=c.indexFrom&&null!=c.indexFrom&&(i[u]=c)}}return s}}class Ot{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(t){return this._byGeometryType?this._byGeometryType[t].vertices:0}indicesFor(t){return this._byGeometryType?this._byGeometryType[t].indices:0}needMore(t,s,i){if(!s&&!i)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const e=this._byGeometryType[t];e.vertices+=s,e.indices+=i}}const kt=5;class Vt{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const t=new Vt;for(let s=0;s<this.geometries.length;s++){const i=this.geometries[s],e=t.geometries[s];e.indexBuffer=i.indexBuffer.slice(),e.vertexBuffer={};for(const t in i.vertexBuffer){const{data:s,stride:n}=i.vertexBuffer[t];e.vertexBuffer[t]={data:s.slice(),stride:n}}}return t}static deserialize(t){const s=new Vt;for(let i=0;i<kt;++i){s.geometries[i].indexBuffer=new Uint32Array(t.geometries[i].indexBuffer),s.geometries[i].vertexBuffer={};for(const e in t.geometries[i].vertexBuffer)s.geometries[i].vertexBuffer[e]={data:H(t.geometries[i].vertexBuffer[e].data,t.geometries[i].vertexBuffer[e].stride),stride:t.geometries[i].vertexBuffer[e].stride}}return s}serialize(){const t={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let s=0;s<kt;++s)for(const i in this.geometries[s].vertexBuffer)t.geometries[s].vertexBuffer[i]={data:this.geometries[s].vertexBuffer[i].data.buffer,stride:this.geometries[s].vertexBuffer[i].stride};return t}getBuffers(){const t=[];for(let s=0;s<kt;++s){t.push(this.geometries[s].indexBuffer.buffer);for(const i in this.geometries[s].vertexBuffer)t.push(this.geometries[s].vertexBuffer[i].data.buffer)}return t}}function Xt(t,s,i,...e){s<t.length?t.splice(s,i,...e):t.push(...e)}class qt{constructor(){this.symbolLevels=[]}replay(t,s,i){for(const e of this.symbolLevels)for(const n of e.zLevels){const e=n.geometryDPInfo.unified;if(e)for(const n of e){const{geometryType:e,materialKey:r,indexFrom:o,indexCount:h}=n,c=ot.load(r).symbologyType,l=t.painter.getBrush(e,c),u={geometryType:e,materialKey:r,indexFrom:o,indexCount:h,target:s.getGeometry(e)};l.prepareState(t),l.drawGeometry(t,s,u,i)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(t,s){if(Array.isArray(t))for(const i of t)this._addToList(i,s);else this._addToList(t,s)}removeFromList(t){Array.isArray(t)||(t=[t]);let s=null;for(const i of t)s=this._removeFromList(i);return s}clone(){const t=new qt;for(const s of this.symbolLevels)t.symbolLevels.push(s.clone());return t}splitAfter(t){const s=this._getDisplayList(t.symbolLevel,t.zOrder),i=s.length,e=t.indexFrom+t.indexCount;for(let n=0;n<i;++n){const i=s[n];if(i.geometryType===t.geometryType&&e>i.indexFrom&&e<=i.indexFrom+i.indexCount){if(e<i.indexFrom+i.indexCount){const t=new Et;t.geometryType=i.geometryType,t.materialKey=i.materialKey,t.indexFrom=e,t.indexCount=i.indexFrom+i.indexCount-e,s.splice(n+1,0,t),i.indexCount=e-i.indexFrom}return n}}}_addToList(t,s){const i=t.symbolLevel,e=t.zOrder,n=this._getDisplayList(i,e),r=null!=s?s:n.length-1,o=r>=0&&r<n.length?n[r]:null;if(null!==o&&o.materialKey===t.materialKey&&o.indexFrom+o.indexCount===t.indexFrom&&o.geometryType===t.geometryType)o.indexCount+=t.indexCount;else{const s=new Et;s.indexFrom=t.indexFrom,s.indexCount=t.indexCount,s.materialKey=t.materialKey,s.geometryType=t.geometryType,Xt(n,r+1,0,s)}}_removeFromList(t){const s=t.symbolLevel,i=t.zOrder,e=this._getDisplayList(s,i),n=e.length;let r;for(let s=0;s<n;++s){const i=e[s];if(t.indexFrom+t.indexCount>i.indexFrom&&t.indexFrom<i.indexFrom+i.indexCount&&i.geometryType===t.geometryType){r=s;break}}if(void 0!==r){const s=e[r];if(t.indexFrom===s.indexFrom)return s.indexCount-=t.indexCount,s.indexFrom+=t.indexCount,0===s.indexCount&&Xt(e,r,1),r-1;if(t.indexFrom+t.indexCount===s.indexFrom+s.indexCount)return s.indexCount-=t.indexCount,0===s.indexCount?(Xt(e,r,1),r-1):r;{const i=s.indexFrom,n=t.indexFrom-s.indexFrom,o=t.indexCount,h=s.indexFrom+s.indexCount-(t.indexFrom+t.indexCount);s.indexCount=n;const c=new Et;return c.geometryType=s.geometryType,c.materialKey=s.materialKey,c.indexFrom=i+n+o,c.indexCount=h,Xt(e,r+1,0,c),r}}return null}_getDisplayList(t,s){let i;const e=this.symbolLevels.length;for(let s=0;s<e;s++)if(this.symbolLevels[s].symbolLevel===t){i=this.symbolLevels[s];break}let n;i||(i=new Qt,i.symbolLevel=t,this.symbolLevels.push(i));const r=i.zLevels.length;for(let t=0;t<r;t++)if(i.zLevels[t].zLevel===s){n=i.zLevels[t];break}return n||(n=new Nt,n.geometryDPInfo=new Kt,n.zLevel=s,i.zLevels.push(n)),n.geometryDPInfo.unified||(n.geometryDPInfo.unified=[]),n.geometryDPInfo.unified}getDPInfoType(){return"unified"}}class Et{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const t=new Et;return t.geometryType=this.geometryType,t.materialKey=this.materialKey,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t}}class Kt{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const t=new Kt;return t.fill=this.fill&&this.fill.map((t=>t.clone())),t.line=this.line&&this.line.map((t=>t.clone())),t.marker=this.marker&&this.marker.map((t=>t.clone())),t.text=this.text&&this.text.map((t=>t.clone())),t.label=this.label&&this.label.map((t=>t.clone())),t.unified=this.unified&&this.unified.map((t=>t.clone())),t}}class Nt{constructor(){this.geometryDPInfo=new Kt}clone(){const t=new Nt;return t.zLevel=this.zLevel,t.geometryDPInfo=this.geometryDPInfo.clone(),t}}class Qt{constructor(){this.zLevels=[]}clone(){const t=new Qt;t.symbolLevel=this.symbolLevel;for(const s of this.zLevels)t.zLevels.push(s.clone());return t}}class Yt{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(t,s,i){for(const s in t)this.vertexData.set(s,t[s]);for(const s in this.vertexData)null===t[s]&&this.vertexData.delete(s);this.vertexCount=s,this.indexData=i}}class Ht{constructor(t,s,i,e=0,n=0){this.id=t,this.geometryType=s,this.materialKey=i,this.minZoom=e,this.maxZoom=n,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0,this._sortKey=null}get sortKey(){return null==this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const t=new Ht(this.id,this.geometryType,this.materialKey);return t.vertexFrom=this.vertexFrom,t.vertexCount=this.vertexCount,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t.zOrder=this.zOrder,t.symbolLevel=this.symbolLevel,t.meshData=this.meshData,t.minZoom=this.minZoom,t.maxZoom=this.maxZoom,t}setMeshDataFromBuffers(t,s,i){const e=new Yt;for(const i in s){const n=s[i].stride,r=s[i].data;if(!r)continue;const o=[],h=N(n);for(let s=0;s<n*t.vertexCount/h;++s)o[s]=r[s+n*t.vertexFrom/h];e.vertexData.set(i,o)}e.indexData.length=0;for(let s=0;s<t.indexCount;++s)e.indexData[s]=i[s+t.indexFrom]-t.vertexFrom;e.vertexCount=t.vertexCount,this.meshData=e}readMeshDataFromBuffers(t,s){this.meshData?this.meshData.clear():this.meshData=new Yt;for(const s in t){const i=t[s].stride,e=t[s].data,n=[],r=N(i);for(let t=0;t<i*this.vertexCount/r;++t)n[t]=e[t+i*this.vertexFrom/r];this.meshData.vertexData.set(s,n)}this.meshData.indexData.length=0;for(let t=0;t<this.indexCount;++t)this.meshData.indexData[t]=s[t+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(t,s,i,e){if(this.meshData){for(const i in s){const e=s[i].stride,n=this.meshData.vertexData.get(i),r=s[i].data,o=N(e);for(let s=0;s<e*this.meshData.vertexCount/o;++s)r[s+e*t/o]=n[s]}for(let s=0;s<this.meshData.indexData.length;++s)e[s+i]=this.meshData.indexData[s]+t;this.vertexFrom=t,this.vertexCount=this.meshData.vertexCount,this.indexFrom=i,this.indexCount=this.meshData.indexData.length}}static writeAllMeshDataToBuffers(t,s,i){let e=0,n=0;for(const r of t)r.writeMeshDataToBuffers(e,s,n,i),e+=r.vertexCount,n+=r.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(t){return t.push(this.geometryType),t.push(this.materialKey),t.push(this.vertexFrom),t.push(this.vertexCount),t.push(this.indexFrom),t.push(this.indexCount),t.push(this.minZoom),t.push(this.maxZoom),t}static deserialize(t,s){const i=t.readInt32(),e=t.readInt32(),n=new Ht(s.id,i,e);return n.vertexFrom=t.readInt32(),n.vertexCount=t.readInt32(),n.indexFrom=t.readInt32(),n.indexCount=t.readInt32(),n.minZoom=t.readInt32(),n.maxZoom=t.readInt32(),n}}function Zt(t,s){if(null!==s){t.push(s.length);for(const i of s)i.serialize(t);return t}t.push(0)}function $t(t,s,i){const e=t.readInt32(),n=new Array(e);for(let e=0;e<n.length;e++)n[e]=s.deserialize(t,i);return n}class Jt{constructor(t){this.insertAfter=null,this.id=t,this.displayRecords=[]}copy(){const t=new Jt(this.id);return t.set(this),t}clone(){const t=new Jt(this.id);return t.displayRecords=this.displayRecords.map((t=>t.clone())),t.insertAfter=this.insertAfter,t}set(t){this.id=t.id,this.displayRecords=t.displayRecords,this.insertAfter=t.insertAfter}serialize(t){return t.push(this.id),Zt(t,this.displayRecords),t}static deserialize(t){const s=t.readInt32(),i=new Jt(s),e={id:s};return i.displayRecords=$t(t,Ht,e)??[],i}}class Wt{constructor(){this.displayObjects=[],this._displayList=null}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const t of this.displayObjects)this._displayObjectRegistry.set(t.id,t)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(){this._displayList=new qt;for(const t of this.displayObjects)for(const s of t.displayRecords)this._displayList.addToList(s)}clone(){const t=new Wt;return this.displayObjects&&(t.displayObjects=this.displayObjects.map((t=>t.clone()))),t}serialize(t){return Zt(t,this.displayObjects),t}_deserializeObjects(t){const s=t.readInt32(),i=new Array(s),e=new Map;for(let s=0;s<i.length;++s){const n=Jt.deserialize(t);i[s]=n,e.set(n.id,n)}this.displayObjects=i,this._displayList=null,this._displayObjectRegistry=e}static deserialize(t){const s=new Wt;return s._deserializeObjects(t),s}}class ts{constructor(t,s){this.data=t,this.stride=s}static decode(t){const s=H(t.data,t.stride),i=t.stride;return new ts(s,i)}static fromVertexVector(t){const s=H(t.data.buffer(),t.stride),i=t.stride;return new ts(s,i)}}class ss{constructor(t,s,i){this.geometryType=t,this.indexBuffer=new Uint32Array(s),this.namedBuffers=i}static decode(t){const s=t.geometryType,i=t.indexBuffer,e={};for(const s in t.namedBuffers)e[s]=ts.decode(t.namedBuffers[s]);return new ss(s,i,e)}static fromVertexData(t,s){const i=t.indices,e=H(t.vertices,t.stride),n=t.stride,r={geometry:new ts(e,n)};return new ss(s,i,r)}static fromVertexVectors(t){const s=t.geometryType,i=t.indexVector.buffer(),e={};let n;for(n in t.namedVectors)e[n]=ts.fromVertexVector(t.namedVectors[n]);return new ss(s,i,e)}}class is{get vertexCount(){const t=this.stride/4,s=this.data.length/t;return s!==(0|s)&&console.debug("Corrupted stride"),s}constructor(t,s){this.data=t,this.stride=s}transfer(t,s){const i=this.data.buffer();t.vertexCount=this.vertexCount,t.data=i,t.stride=this.stride,s.push(i)}}class es{constructor(t,s,i){this.geometryType=t,this.indexVector=new ht(Uint32Array,6*s),this.namedVectors={};const e=Z(t,i);for(const t in e){const i=e[t];let n;switch(i%4){case 0:case 2:n=new ht(Uint32Array,i*s);break;case 1:case 3:n=new ht(Uint8Array,i*s)}this.namedVectors[t]=new is(n,i)}}get(t){return this.namedVectors[t].data}getVector(t){return this.namedVectors[t]}transfer(t,s){const i=this.indexVector.buffer(),e={};let n;for(n in s.push(i),this.namedVectors){const t=this.namedVectors[n];e[n]={},t.transfer(e[n],s)}t.geometryType=this.geometryType,t.indexBuffer=i,t.namedBuffers=e,this.destroy()}intoBuffers(){const t=ss.fromVertexVectors(this);return this.destroy(),t}destroy(){this.indexVector=null,this.namedVectors=null}}const ns=new Ot,rs=new Ot,os=5;function hs(t,s){const i={};for(const e in t){const n={data:E(s,t[e]),stride:t[e]};i[e]=n}return i}function cs(t){return[t.fill||{},t.line||{},t.icon||{},t.text||{},t.label||{}]}function ls(t){const s=[[],[],[],[],[]],i=t;for(const t of i)for(const i of t.displayRecords)s[i.geometryType].push(i);return s}class us{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){if(ns.reset(),!this.tileDisplayData)return;const s=ls(this.tileDisplayData.displayObjects);for(const t of s)for(const s of t)s&&ns.needMore(s.geometryType,s.meshData?s.meshData.vertexCount:s.vertexCount,s.meshData?s.meshData.indexData.length:s.indexCount);const i=s.length,e=new Vt;for(let s=0;s<i;++s){e.geometries[s].indexBuffer=new Uint32Array(Math.round(t*ns.indicesFor(s)));const i=[],n=this.tileBufferData?.geometries[s].vertexBuffer;if(!n)continue;for(const t in n)i.push(n[t].stride);const r=us._computeVertexAlignment(i),o=Math.round(t*ns.verticesFor(s)),h=us._align(o,r);for(const t in n){const i=n[t].stride;e.geometries[s].vertexBuffer[t]={stride:i,data:E(h,i)}}}rs.reset(),this.tileDisplayData.displayList?.clear();for(let t=0;t<i;++t){const i=s[t];for(const s of i){if(s.meshData)s.writeMeshDataToBuffers(rs.verticesFor(t),e.geometries[t].vertexBuffer,rs.indicesFor(t),e.geometries[t].indexBuffer),s.meshData=null;else{const i=this.tileBufferData?.geometries[t];if(i){const n=i.vertexBuffer,r=i.indexBuffer,o=e.geometries[t].vertexBuffer,h=e.geometries[t].indexBuffer,c=rs.verticesFor(t),l=rs.indicesFor(t);K(c,l,o,h,s,n,r),s.vertexFrom=c,s.indexFrom=l}}rs.needMore(t,s.vertexCount,s.indexCount)}}const{displayList:n,displayObjects:r}=this.tileDisplayData;if(n)for(const t of r)n.addToList(t.displayRecords);this.tileBufferData=e}getStrides(){const t=[],s=this.tileBufferData?.geometries;if(!s)return t;for(let i=0;i<s.length;++i){const e=s[i];t[i]={};for(const s in e.vertexBuffer)t[i][s]=e.vertexBuffer[s].stride}return t}clone(){const t=new us;return t.tileBufferData=this.tileBufferData?.clone()??null,t.tileDisplayData=this.tileDisplayData?.clone()??null,t}_guessSize(){const t=this.tileDisplayData?.displayObjects??[],s=Math.min(t.length,4),i=12,e=40;let n=0;for(let i=0;i<s;i++)n=Math.max(n,t[i].displayRecords.length);return 2*(t.length*i+t.length*n*e)}serialize(){const t=this.tileBufferData.serialize(),s=this.tileBufferData.getBuffers(),i=this.tileDisplayData.serialize(new ht(Int32Array,this._guessSize())).buffer();return s.push(i),{result:{displayData:i,bufferData:t},transferList:s}}static fromVertexData(t,s){const i={},e=new Map;for(const t of s)e.set(t.id,t);return $((s=>{const n=t.data[s];if(null!=n){const t=et.from(n.records).getCursor();for(;t.next();){const i=t.id,n=t.materialKey,r=t.indexFrom,o=t.indexCount,h=t.vertexFrom,c=t.vertexCount,l=e.get(i),u=new Ht(i,s,n);u.indexFrom=r,u.indexCount=o,u.vertexFrom=h,u.vertexCount=c,l.displayRecords.push(u)}i[s]=ss.fromVertexData(n,s)}else i[s]=new es(s,0,J.DEFAULT).intoBuffers()})),us.fromMeshData({displayObjects:s,vertexBuffersMap:i})}static fromMeshData(t){const s=new us,i=new Wt,e=new Vt;i.displayObjects=t.displayObjects;for(const s in t.vertexBuffersMap){const i=s,n=t.vertexBuffersMap[i];e.geometries[i].indexBuffer=n.indexBuffer,e.geometries[i].vertexBuffer=n.namedBuffers}return s.tileDisplayData=i,s.tileBufferData=e,s}static bind(t,s){const i=new us;return i.tileDisplayData=t,i.tileBufferData=s,i}static create(t,s){const i=new us;i.tileDisplayData=new Wt,i.tileDisplayData.displayObjects=t;const e=[0,0,0,0,0],n=[0,0,0,0,0],r=[[],[],[],[],[]];for(const s of t)for(const t of s.displayRecords)r[t.geometryType].push(t),e[t.geometryType]+=t.meshData.vertexCount,n[t.geometryType]+=t.meshData.indexData.length;const o=new Vt,h=cs(s);for(let t=0;t<os;t++){const s=new Uint32Array(n[t]),i=hs(h[t],e[t]);Ht.writeAllMeshDataToBuffers(r[t],i,s),o.geometries[t]={indexBuffer:s,vertexBuffer:i}}return i.tileBufferData=o,i}static _align(t,s){const i=t%s;return 0===i?t:t+(s-i)}static _computeVertexAlignment(t){let s=!1,i=!1;for(const e of t)e%4==2?s=!0:e%4!=0&&(i=!0);return i?4:s?2:1}}const as=512,fs=50;function ds(t,s){const n=e(s);if(!n)return null;const[r,o]=n.valid;return t[2]>o?[i([t[0],t[1],o,t[3]]),i([r,t[1],r+t[2]-o,t[3]])]:t[0]<r?[i([r,t[1],t[2],t[3]]),i([o-(r-t[0]),t[1],o,t[3]])]:null}function ps(t){return"text"===t||"esriTS"===t}function ms(t){return"simple-marker"===t||"picture-marker"===t||"esriSMS"===t||"esriPMS"===t}function ws(t){switch(t.geometry.type){case"point":case"multipoint":return 0;case"polyline":return 1;case"polygon":case"extent":return 2}return 0}function ys(t){if(!t)return null;const{xmin:i,ymin:e,xmax:n,ymax:r,spatialReference:o}=t;return new s({rings:[[[i,e],[i,r],[n,r],[n,e],[i,e]]],spatialReference:o})}class gs extends dt{static from(t,s,i){const e=pt.createInstance(),r=[],o=t.filter((t=>!!t.geometry));for(const t of o){const i=n(t.geometry);yt(r,[t],i,!1,!1,s)}return new gs(e,r,i)}constructor(t,s,i){super(t,s,null),this._transform=i}get geometryType(){const t=this._current;return t?t.geometryType:null}get insertAfter(){return this._current.insertAfter}readGraphic(){return this._current}getCursor(){return this.copy()}copy(){const t=new gs(this.instance,this._features,this._transform);return this.copyInto(t),t}}const xs=new At,vs=new At,bs="esriGeometryPolyline";function _s(t){t.coords.length=0,t.lengths.length=0}class Ms{constructor(){this.bounds=i(),this.graphic=null}static acquire(t=null,s,i,e,n){let r;return 0===Ms._pool.length?r=new Ms:(r=Ms._pool.pop(),this._set.delete(r)),r.acquire(t,s,i,e,n),r}static release(t){t&&!this._set.has(t)&&(t.release(),this._pool.push(t),this._set.add(t))}static getCentroidQuantized(t,s){if(r(t.geometry)){const i=t.symbol;if(null==i)return null;if(i?.layers.length>0&&i.layers.some((t=>"text"===t.type||"marker"===t.type))){const i=o(t.geometry);return null!==i?Bt(s,{},{x:i[0],y:i[1]},!1,!1):null}}return null}acquire(t=null,s,i,e,n){t&&this.set(t,s,i,e,n)}release(){this.graphic=null,this.symbolResource=null,this.geometry=null}get symbol(){return this.symbolResource.symbol}set(t,s,i,e,n){this.graphic=t,this.geometry=i,this.symbolResource=s,this.bounds=e,n&&(this.size=n)}getGeometryQuantized(t,s,i,r){const o=this.geometry,c=n(o);if(null==c)return null;switch(c){case"esriGeometryPolygon":{const s=o,{rings:i}=s;if(!i||0===i.length)return null;let e;if(e=1===i.length&&2===i[0].length?Dt(t,{paths:[[i[0][0],i[0][1]]]}):Dt(t,this.geometry),!e){const s={x:i[0][0][0],y:i[0][0][1]};if(e=Dt(t,s),e){const{x:t,y:s}=e;return{rings:[[[t-1,s],[1,-1],[1,1],[-1,1],[-1,-1]]]}}}return e}case"esriGeometryPolyline":{const s=o;_s(xs),_s(vs);const i=s.hasZ??!1,e=s.hasM??!1;return gt(xs,s),xt(vs,xs,i,e,bs,t.scale[0]),vt(xs,vs,i,e,bs,t),bt(xs,s.hasZ??!1,s.hasM??!1)}case"esriGeometryMultipoint":{const n=o,c=.5*r*Math.max(Math.abs(this.size[0])+this.size[2]-this.size[0],Math.abs(this.size[1])+this.size[3]-this.size[1]),l=e(i);let u=n.points;if(l){const[t,i]=l.valid,e=i-t;u=u.filter((n=>{if(n[0]+c>i||n[0]-c<t){const t=[...n];return n[0]+c>i?t[0]-=e:t[0]+=e,h(s,n,c)||h(s,t,c)}return h(s,n,c)}))}return 0===u.length?{points:u}:Dt(t,{points:u})}}return Dt(t,this.geometry)}}Ms._pool=[],Ms._set=new Set;const Bs={minX:0,minY:0,maxX:0,maxY:0},Ds=i(),As=1e-5;function Fs(t,s,i,e,n){return Bs.minX=s,Bs.minY=i,Bs.maxX=e,Bs.maxY=n,t.search(Bs)}function js(t){return{minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]}}class Ts{constructor(t,s,i,e,n,r,o){this._graphics=e,this._onAdd=n,this._onRemove=r,this._hashToCIM=o,this._index=_t(9,js),this._itemByGraphic=new Map,this._inflatedSizeHelper=new R,this._tileInfoView=t,this._uidFieldName=i;const h=t.getClosestInfoForScale(s);h&&(this._resolution=this._tileInfoView.getTileResolution(h.level))}setResourceManager(t){this._cimResourceManager=t,this._hittestDrawHelper=new z(t)}hitTest(t,s,e,n,r){t=Mt(t,this._tileInfoView.spatialReference);const o=.5*n*window.devicePixelRatio*e;Ds[0]=t-o,Ds[1]=s-o,Ds[2]=t+o,Ds[3]=s+o;const h=.5*n*(e+fs),l=Fs(this._index,t-h,s-h,t+h,s+h);if(!l||0===l.length)return[];const u=[],a=i(),f=i();for(const t of l){const{geometry:s,symbolResource:i}=t;this._getSymbolBounds(a,i,s,f,r),f[3]=f[2]=f[1]=f[0]=0,c(a,Ds)&&t.graphic?.visible&&u.push(t)}if(0===u.length)return[];const d=this._hittestDrawHelper,p=[];for(const t of u){const{geometry:s,symbolResource:i}=t,{hash:e,textInfo:o}=i,h=this._hashToCIM.get(e);h&&(d.hitTest(Ds,h.symbol,s,o,r,n)&&p.push(t))}return p.sort(Cs),p.map((t=>t.graphic))}getGraphicsData(t,s,i){const e=this._searchForItems(s);if(0===e.length||0===i.length)return[];e.sort(((t,s)=>t.zorder-s.zorder)),e[0].insertAfter=-1;for(let t=1;t<e.length;t++)e[t].insertAfter=e[t-1].graphic.uid;e.sort(((t,s)=>t.graphic.uid-s.graphic.uid)),i.sort(((t,s)=>t.uid-s.uid));let n,r=0,o=0;const h=s.resolution,c=[],l={originPosition:"upperLeft",scale:[h,h],translate:[s.bounds[0],s.bounds[3]]};for(const u of i){for(o=-2;r<e.length;)if(n=e[r],r++,u.uid===n.graphic.uid){o=n.insertAfter;break}if(!n?.geometry||-2===o)continue;const i=n.getGeometryQuantized(l,s.bounds,this._tileInfoView.spatialReference,h),a={...n.graphic.attributes};a[this._uidFieldName]=u.uid,null==n.groupId&&(n.groupId=t.createTemplateGroup(n.symbol,null)),c.push({centroid:Ms.getCentroidQuantized(n,l),geometry:i,attributes:a,symbol:n.symbol,groupId:n.groupId,insertAfter:o,zorder:n.zorder})}return c.sort(((t,s)=>t.zorder-s.zorder)),c}queryTileData(t,s){if(0===this._graphics.length)return[];const{bounds:i,resolution:e}=s,n=this._searchForItems(s),r=[];return 0===n.length||this._createTileGraphics(r,t,n,{originPosition:"upperLeft",scale:[e,e],translate:[i[0],i[3]]},s),r}has(t){return this._itemByGraphic.has(t)}getBounds(t){const s=this._itemByGraphic.get(t);return s?s.bounds:null}getAllBounds(){return Array.from(this._itemByGraphic.values()).filter((t=>t.graphic.visible)).map((t=>t.bounds))}addOrModify(t,s,i){if(!t||null==s)return;this.has(t)&&this.remove(t),this._onAdd(t);const e=[0,0,0,0],n=this._getSymbolBounds(null,s,i,e,0),r=Ms.acquire(t,s,i,null!=n?n:null,e);return this._itemByGraphic.set(t,r),i&&this._index.insert(r),r.bounds}remove(t){if(!this._itemByGraphic.has(t))return;this._onRemove(t);const s=this._itemByGraphic.get(t);s?.bounds&&this._index.remove(s),this._itemByGraphic.delete(t)}updateZ(){const t=this._graphics.items;let s,i;for(let e=0;e<t.length;e++)i=t[e],s=this._itemByGraphic.get(i),s&&(s.zorder=e)}update(t,s,i){const e=this._itemByGraphic.get(t);e.groupId=null;const n=a(e.bounds);this._index.remove(e);const r=this._getSymbolBounds(e.bounds,s,i,e.size,0);return null!=r&&e.set(t,s,i,r,e.size),i&&this._index.insert(e),{oldBounds:n,newBounds:e.bounds}}updateLevel(t){if(this._resolution===t)return;this._resolution=t,this._index.clear();const s=this._itemByGraphic,i=[];for(const[t,e]of s){const t=this._getSymbolBounds(e.bounds,e.symbolResource,e.geometry,e.size,0);e.geometry&&null!=t&&(e.bounds=t,i.push(e))}this._index.load(i)}clear(){this._itemByGraphic.clear(),this._index.clear()}_createTileGraphics(t,s,i,e,n){const r=this._uidFieldName,o=this._tileInfoView.spatialReference,{bounds:h,resolution:c}=n;let l,u,a,f;i.sort(((t,s)=>t.zorder-s.zorder));for(let n=0;n<i.length;n++){a=i[n],l=a.graphic,u=a.getGeometryQuantized(e,h,o,c),f=0===n?-1:i[n-1].graphic.uid;const d={...a.graphic.attributes};d[r]=l.uid,null==a.groupId&&(a.groupId=s.createTemplateGroup(a.symbol,null)),t.push({centroid:Ms.getCentroidQuantized(a,e),geometry:u,attributes:d,symbol:a.symbol,groupId:a.groupId,insertAfter:f,zorder:a.zorder})}}_searchForItems(t){const s=this._tileInfoView.spatialReference,n=t.bounds,r=e(s);if(r&&s.isWrappable){const[s,e]=r.valid,o=Math.abs(n[2]-e)<As,h=Math.abs(n[0]-s)<As;if((!o||!h)&&(o||h)){const r=t.resolution;let h;h=i(o?[s,n[1],s+r*fs,n[3]]:[e-r*fs,n[1],e,n[3]]);const c=Fs(this._index,n[0],n[1],n[2],n[3]),l=Fs(this._index,h[0],h[1],h[2],h[3]);return[...new Set([...c,...l])]}}return Fs(this._index,n[0],n[1],n[2],n[3])}_getSymbolBounds(t,s,e,n,r){if(!s||!s.symbol||!e)return null;if(t||(t=i()),l(t,e),!n||0===n[0]&&0===n[1]&&0===n[2]&&0===n[3]){const{hash:t,textInfo:i}=s,e=this._hashToCIM.get(t);if(!e)return null;n||(n=[0,0,0,0]);const o=this._inflatedSizeHelper.getSymbolInflateSize(n,e.symbol,this._cimResourceManager,r,i);n[0]=u(o[0]),n[1]=u(o[1]),n[2]=u(o[2]),n[3]=u(o[3])}const o=this._resolution,h=R.safeSize(n);return t[0]-=h*o,t[1]-=h*o,t[2]+=h*o,t[3]+=h*o,t}}const Cs=(t,s)=>{const i=ws(t.graphic),e=ws(s.graphic);return i===e?s.zorder-t.zorder:i-e};const Ss=f("esri-2d-graphic-debug");function Ps(t,s,i){let e=i.get(t);return e||(e={tile:s,addedOrModified:[],removed:[]},i.set(t,e)),e}let Gs=class extends(d(p(m))){constructor(t){super(t),this._storage=new mt,this._displayIds=new Map,this._controller=new AbortController,this._tiles=new Map,this._graphicStoreUpdate=!1,this._graphicsSet=new Set,this._matcher=Promise.resolve(null),this._tileUpdateSet=new Set,this._tilesToUpdate=new Map,this._graphicIdToAbortController=new Map,this._attached=!1,this._updatingGraphicsTimer=null,this._hashToExpandedSymbol=new Map,this._hashToExpandedSymbolPromise=new Map,this._hashToCIMSymbolPromise=new Map,this._hashToCIM=new Map,this._processing=!1,this._needsProcessing=!1,this._pendingUpdate={added:new Set,updated:new Set,removed:new Set},this.lastUpdateId=-1,this.renderer=null,this.updateRequested=!1,this.defaultPointSymbolEnabled=!0,this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}destroy(){this._updatingGraphicsTimer&&(clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=null,this.notifyChange("updating")),this._controller.abort(),this.container.destroy(),this._set("graphics",null),this._graphicStore.clear(),this._attributeStore=null,this._hashToExpandedSymbol.clear(),this.view=null,this.renderer=null,this._hashToCIM.clear(),this._hashToCIMSymbolPromise.clear(),this._hashToExpandedSymbolPromise.clear()}_createMatcher(t,s,i){if(t){const e=nt(t),n=rt({indexCount:0,fields:{}},"feature",t,e);this._matcher=ct(n,s,null,i)}}_createDisplayId(t){let s=this._displayIds.get(t);return s||(s=this._storage.createDisplayId(),this._displayIds.set(t,s)),s}initialize(){this._attributeStore=new wt({type:"local",initialize:t=>Promise.resolve(this.container.attributeView.initialize(t)),update:t=>this.container.attributeView.requestUpdate(t),render:()=>this.container.requestRender()},Ft("2d")),this.container.hasHighlight=()=>this._attributeStore.hasHighlight;const t=t=>{this._createDisplayId(t.uid),this._setFilterState(t.uid,t.visible)},s=t=>{const s=this._displayIds.get(t.uid);this._displayIds.delete(t.uid),this._storage.releaseDisplayId(s)},i=new lt(this.container.getMaterialItems.bind(this.container),this.view.featuresTilingScheme.tileInfo);this._graphicStore=new Ts(this.view.featuresTilingScheme,this.view.state.scale,this.uid,this.graphics,t,s,this._hashToCIM),this._meshFactory=new ut(null,this.uid,i),this._templateStore=i,this.handles.add([w((()=>this._effectiveRenderer),(t=>{this._createMatcher(t,i,this.container.stage.resourceManager);for(const t of this.graphics)this._pendingUpdate.updated.add(t);this.requestUpdate()})),this.view.graphicsTileStore.on("update",this._onTileUpdate.bind(this)),this.container.on("attach",(()=>{Ss&&this.container.enableRenderingBounds((()=>this._graphicStore.getAllBounds())),this.graphics.items.length>0&&this._graphicsChangeHandler({target:this.graphics,added:this.graphics.items,removed:[],moved:[]}),this.handles.add(this.graphics.on("change",(t=>this._graphicsChangeHandler(t))),"graphics");const t=this.container.stage.resourceManager;this._createMatcher(this._effectiveRenderer,i,t),this._graphicStore.setResourceManager(t),this._attached=!0,this.notifyChange("updating")}))]);const e=this.view.graphicsTileStore.tiles;this._onTileUpdate({added:e,removed:[]})}get _effectiveRenderer(){return"function"==typeof this.renderer?this.renderer():this.renderer}get updating(){return!this._attached||null!==this._updatingGraphicsTimer||this._pendingUpdate.added.size>0||this._pendingUpdate.removed.size>0||this._pendingUpdate.updated.size>0||this._tileUpdateSet.size>0||this._tilesToUpdate.size>0||this._attributeStore?.updatingHandles.updating||this._processing}hitTest(t){if(!this.view||this.view.suspended)return[];const{resolution:s,rotation:i}=this.view.state;return this._graphicStore.hitTest(t.x,t.y,2,s,i)}update(t){y(this._controller.signal);const s=t.state,{resolution:i}=s;if(this._graphicStore.updateLevel(i),this._graphicStoreUpdate=!0,this.updateRequested=!1,this._pendingUpdate.updated.size>0){if(!this._processing)return void this._updateGraphics();this._needsProcessing=!0}}viewChange(){this.requestUpdate()}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback())}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}graphicUpdateHandler(t){const{graphic:s,property:i}=t;switch(i){case"attributes":case"geometry":case"symbol":this._pendingUpdate.updated.add(s),this.requestUpdate();break;case"visible":this._setFilterState(s.uid,s.visible),this._attributeStore.sendUpdates()}}setHighlight(t){const s=t.map((t=>this._displayIds.get(t))).filter(g);this._attributeStore.setHighlight(t,s)}_getIntersectingTiles(t){const s=this._graphicStore.getBounds(t);if(!s||0===x(s)||0===v(s))return[];const i=ds(s,this.view.spatialReference);return null!=i?[...new Set([...this.view.graphicsTileStore.boundsIntersections(i[0]),...this.view.graphicsTileStore.boundsIntersections(i[1])])]:this.view.graphicsTileStore.boundsIntersections(s)}async _updateTile(t){y(this._controller.signal);const s=t.tile,i=this._getGraphicsData(this._templateStore,s,t.addedOrModified),e=await this._processGraphics(s,i);return y(this._controller.signal),this._patchTile(s.key,{type:"update",addOrUpdate:e,remove:t.removed,end:!0,clear:!1,sort:!1}),e}_patchTile(t,s){const i=this._tiles.get(t);i&&(this.container.onTileData(i,s),this.container.requestRender())}_graphicsChangeHandler(t){const s=this._pendingUpdate;for(const i of t.added)s.added.add(i);for(const i of t.moved)s.updated.add(i);for(const i of t.removed)this._pendingUpdate.added.has(i)?s.added.delete(i):s.removed.add(i);this._processing?this._needsProcessing=!0:this._updateGraphics()}_getGraphicsToUpdate(){const t={added:[],removed:[],updated:[]};if(!this.graphics)return t;const s=this._pendingUpdate;for(const i of this.graphics.items)s.added.has(i)?t.added.push(i):s.updated.has(i)&&t.updated.push(i);for(const i of s.removed)this._graphicStore.has(i)&&t.removed.push(i);return s.added.clear(),s.removed.clear(),s.updated.clear(),t}async _updateGraphics(){this._processing=!0;const{added:t,removed:s,updated:i}=this._getGraphicsToUpdate(),e=this._tilesToUpdate;let n;try{if(!this._graphicStoreUpdate){const t=this.view.state,{resolution:s}=t;this._graphicStore.updateLevel(s)}const r=[],o=new Array(t.length+s.length);for(let t=0;t<i.length;t++){const s=i[t],h=this._getIntersectingTiles(s);for(const t of h){n=t.id;Ps(n,t,e).removed.push(this._displayIds.get(s.uid))}r.push(this._updateGraphic(s,null)),o[t]=s}const h=i.length;for(let s=0;s<t.length;s++){const i=t[s];o[h+s]=i,this._graphicsSet.add(i),r.push(this._addGraphic(i))}for(const t of s){this._abortProcessingGraphic(t.uid);const s=this._getIntersectingTiles(t);for(const i of s){n=i.id;Ps(n,i,e).removed.push(this._displayIds.get(t.uid))}this._graphicsSet.delete(t),this._graphicStore.remove(t)}let c;this._flipUpdatingGraphics(),await Promise.all(r);for(let t=0;t<o.length;t++){c=o[t];const s=this._getIntersectingTiles(c);for(const t of s){n=t.id;Ps(n,t,e).addedOrModified.push(c)}}this._graphicStore.updateZ();const l=[];for(const[t,s]of e)l.push(this._updateTile(s));await Promise.all(l)}catch(t){}for(const t of s)try{const s=await this._getSymbolForGraphic(t,null);if(s){const t=s.hash();this._hashToExpandedSymbol.delete(t)}}catch(t){}e.clear(),this.notifyChange("updating"),this._processing=!1,this._needsProcessing&&(this._needsProcessing=!1,this._updateGraphics())}_getArcadeInfo(t){const s=(t.attributes?Object.keys(t.attributes):[]).map((s=>({name:s,alias:s,type:"string"==typeof t.attributes[s]?"esriFieldTypeString":"esriFieldTypeDouble"})));return null==t.geometry?null:{geometryType:n(t.geometry),spatialReference:b.fromJSON(t.geometry.spatialReference),fields:s}}_getSymbolForGraphic(t,s){return y(this._controller.signal),null!=t.symbol?Promise.resolve(t.symbol):null!=this._effectiveRenderer?this._effectiveRenderer.getSymbolAsync(t,{scale:this.view.state.scale,signal:null!=s?s.signal:null}):Promise.resolve(this._getNullSymbol(t))}_getCIMSymbol(t,s,i){let e=this._hashToCIM.get(s);if(e)return Promise.resolve(e);const n=U(t);if(null!=n){if("CIMSymbolReference"===n.type)return e=n,this._hashToCIM.set(s,e),Promise.resolve(e);let t=this._hashToCIMSymbolPromise.get(s);return t||(t=n.fetchCIMSymbol(i).then((t=>(this._hashToCIM.set(s,t.data),this._hashToCIMSymbolPromise.delete(s),t))).catch((t=>(this._hashToCIMSymbolPromise.delete(s),_(t),null))),this._hashToCIMSymbolPromise.set(s,t),t)}return Promise.resolve(null)}_expandCIMSymbol(t,s,i,e){const n=this._hashToExpandedSymbol.get(i);if(n)return Promise.resolve(n);let r=this._hashToExpandedSymbolPromise.get(i);if(r)return r;const o=this.container.stage,h=this._getArcadeInfo(s),c=nt(null),l=jt(t,c);return r=at(l,h,o.resourceManager,e),this._hashToExpandedSymbolPromise.set(i,r),r.then((t=>(this._hashToExpandedSymbol.set(i,t),this._hashToExpandedSymbolPromise.delete(i),t))),r}async _getSymbolResources(t,s){y(this._controller.signal);return this.container.stage?this._getSymbolForGraphic(t,s).then((i=>{if(!i)return null;const e=i.hash();return this._getCIMSymbol(i,e,s).then((i=>null==i?null:this._expandCIMSymbol(i,t,e,s).then((t=>{const s=t.layers.filter((t=>"text"===t.type&&"string"==typeof t.text));if(s&&s.length>0){const i=new Array(s.length);for(let t=0;t<s.length;t++){const e=s[t],n=[],[r]=O(e.text);e.text=r;for(let t=0;t<r.length;t++)n.push(r.charCodeAt(t));i[t]={symbol:e,id:t,glyphIds:n}}const n=new Map;return this.container.getMaterialItems(i).then((i=>{M(i);for(let t=0;t<s.length;t++){const e=s[t];n.set(e.cim,{text:e.text,mosaicItem:i[t].mosaicItem})}return{symbol:t,textInfo:n,hash:e}}))}return{symbol:t,hash:e}}))))})).catch((t=>(_(t),null))):null}async _projectAndNormalizeGeometry(t,s){if(y(this._controller.signal),null==t.geometry||"mesh"===t.geometry.type)return null;let i=t.geometry;if(r(i)){const t=i.rings;i.rings=t}else if(B(i)){const t=i.paths;i.paths=t}else if(D(i)){const e=await this._getSymbolForGraphic(t,s);if(y(this._controller.signal),e&&(ms(e.type)||ps(e.type))){i=i.center}else i=ys(i)}await V(i.spatialReference,this.view.spatialReference);const e=k(i),n=X(e,i.spatialReference,this.view.spatialReference);return n&&A(n),n}_onTileUpdate(t){const s=e(this.view.spatialReference);if(t.added&&t.added.length>0)for(const i of t.added)this._addNewTile(i,s);if(t.removed&&t.removed.length>0)for(const s of t.removed)this._removeTile(s.key)}async _addGraphic(t){this._abortProcessingGraphic(t.uid),y(this._controller.signal);const s=new AbortController;this._graphicIdToAbortController.set(t.uid,s);const i={signal:s.signal};try{await this._addOrUpdateGraphic(t,i),y(this._controller.signal),this._graphicIdToAbortController.delete(t.uid)}catch(s){if(this._graphicIdToAbortController.delete(t.uid),!F(s))throw s}}_updateGraphic(t,s){y(this._controller.signal);const i=this._projectAndNormalizeGeometry(t,s),e=this._getSymbolResources(t,s);return Promise.all([i,e]).then((([s,i])=>{y(this._controller.signal),this._graphicStore.addOrModify(t,i,s)}))}_addOrUpdateGraphic(t,s){y(this._controller.signal);const i=this._projectAndNormalizeGeometry(t,s),e=this._getSymbolResources(t,s);return Promise.all([i,e]).then((([s,i])=>{y(this._controller.signal),this._graphicsSet.has(t)&&this._graphicStore.addOrModify(t,i,s)}))}_addTile(t){const s=this.view.featuresTilingScheme.getTileBounds(i(),t),e=this.view.featuresTilingScheme.getTileResolution(t.level),n=new Ut(t,e,s[0],s[3]);return this._tiles.set(t,n),this.container.addChild(n),n}async _addNewTile(t,s){const i=this._addTile(t.key),e=this._graphicStore.queryTileData(this._templateStore,t);if(0===e.length)return;if(s){const i=Math.round((s.valid[1]-s.valid[0])/t.resolution);for(const t of e)t.geometry&&(j(t.geometry)||T(t.geometry))&&this._wrapPoints(t,i)}const n=t.key;this._tileUpdateSet.add(t.key),this.notifyChange("updating");try{const s={type:"update",clear:!1,addOrUpdate:await this._processGraphics(t,e),remove:[],end:!0,sort:!1};i.patch(s),this._tileUpdateSet.delete(n),this.notifyChange("updating")}catch(t){if(this._tileUpdateSet.delete(n),this.notifyChange("updating"),!F(t))throw t}}_removeTile(t){if(!this._tiles.has(t))return;const s=this._tiles.get(t);this.container.removeChild(s),s.destroy(),this._tiles.delete(t)}_setFilterState(t,s){const i=this._displayIds.get(t),e=this._attributeStore.getHighlightFlag(t);this._attributeStore.setData(i,0,0,e|(s?q:0))}_getGraphicsData(t,s,i){const n=this.view,r=e(n.spatialReference),o=this._graphicStore.getGraphicsData(t,s,i);if(r){const t=Math.round((r.valid[1]-r.valid[0])/s.resolution);for(const s of o)s.geometry&&(j(s.geometry)||T(s.geometry))&&this._wrapPoints(s,t)}return o}_wrapPoints(t,s){const i=t.geometry;T(i)?this._wrapMultipoint(i,s):this._wrapPoint(t,s)}_wrapMultipoint(t,s){const i=t.points,e=[];let n=0,r=0;for(const[t,o]of i){if(e.push([t+n,o]),n=0,s===as){const i=5*fs;t+r<i?(e.push([s,0]),n=-s):t+r>as-i&&(e.push([-s,0]),n=s)}else t+r<-fs?(e.push([s,0]),n=-s):t+r>as+fs&&(e.push([-s,0]),n=s);r+=t}t.points=e}_wrapPoint(t,s){const i=t.geometry;if(s===as){const e=5*fs;i.x<e?t.geometry={points:[[i.x,i.y],[s,0]]}:i.x>as-e&&(t.geometry={points:[[i.x,i.y],[-s,0]]})}else i.x<-fs?t.geometry={points:[[i.x,i.y],[s,0]]}:i.x>as+fs&&(t.geometry={points:[[i.x,i.y],[-s,0]]})}_processGraphics(t,s,i){if(!(s&&s.length)||!this._meshFactory)return Promise.resolve(null);const e=gs.from(s,this.uid,t.transform),n=this._meshFactory;return this._matcher.then((s=>n.analyzeGraphics(e,this.container.stage.resourceManager,s,null,null,i).then((()=>(this._attributeStore.sendUpdates(),this._processAnalyzedGraphics(t,e))))))}_processAnalyzedGraphics(t,s){const i=this._meshFactory,e=s.getSize(),n=s.getCursor(),r={features:e,records:e,metrics:0},o=new ft(t.key.id,r,J.DEFAULT,!1,!1),h=[];for(;n.next();){const s=n.readGraphic();s.insertAfter=-1===s.insertAfter?-1:this._displayIds.get(s.insertAfter),s.displayId=this._displayIds.get(s.attributes[this.uid]);const e=new Jt(s.displayId);e.insertAfter=s.insertAfter,h.push(e),i.writeGraphic(o,n,t.level,this.container.stage.resourceManager)}const c=t.tileInfoView.tileInfo.isWrappable,l=o.serialize(c);if(1!==l.length)return new us;const u=l[0].message;return us.fromVertexData(u,h)}_abortProcessingGraphic(t){this._graphicIdToAbortController.get(t)?.abort()}_getNullSymbol(t){const s=t.geometry;return B(s)?C:r(s)||D(s)?S:this.defaultPointSymbolEnabled?P:null}_flipUpdatingGraphics(){this._updatingGraphicsTimer&&clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=setTimeout((()=>{this._updatingGraphicsTimer=null,this.notifyChange("updating")}),160),this.notifyChange("updating")}};G([I()],Gs.prototype,"_effectiveRenderer",null),G([I({constructOnly:!0})],Gs.prototype,"requestUpdateCallback",void 0),G([I()],Gs.prototype,"container",void 0),G([I({constructOnly:!0})],Gs.prototype,"graphics",void 0),G([I()],Gs.prototype,"renderer",void 0),G([I()],Gs.prototype,"updating",null),G([I()],Gs.prototype,"view",void 0),G([I()],Gs.prototype,"updateRequested",void 0),G([I()],Gs.prototype,"defaultPointSymbolEnabled",void 0),Gs=G([L("esri.views.2d.layers.support.GraphicsView2D")],Gs);const Is=Gs;export{Is as o};
//# sourceMappingURL=p-8b9c0412.js.map