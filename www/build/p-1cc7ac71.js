import{bV as t,cp as s,ba as i,ef as n,fw as e,e7 as r,fx as o,cV as h,cW as c,fy as u,e5 as a,l,n as f,w as d,eo as m}from"./p-b54724b6.js";import{v as p,b as _,j as b}from"./p-779af821.js";import{s as j,d as T,q as O,p as M,z as g,V as N,_ as w,k as E,Q as R}from"./p-80e8e171.js";import"./p-e9a502d1.js";import{i as x}from"./p-673b0971.js";import{m as A}from"./p-c9a18189.js";import"./p-52d8e383.js";import"./p-de65f975.js";import"./p-cc24e5bd.js";import"./p-603bf978.js";import"./p-783b6965.js";import"./p-76eeb521.js";import"./p-74887bd8.js";import"./p-0609006d.js";import"./p-8cdc652c.js";import"./p-c736af50.js";import"./p-2570f2bd.js";import"./p-13e550f5.js";import"./p-795f7c81.js";function y(t){return t?{ray:T(t.ray),c0:t.c0,c1:t.c1}:{ray:T(),c0:0,c1:Number.MAX_VALUE}}new j((()=>y()));function F(t,s){for(let i=0;i<v;i++){const n=t[i];if(n[0]*s[0]+n[1]*s[1]+n[2]*s[2]+n[3]>=s[3])return!1}return!0}var S,I;!function(t){t[t.LEFT=0]="LEFT",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.TOP=3]="TOP",t[t.NEAR=4]="NEAR",t[t.FAR=5]="FAR"}(S||(S={})),function(t){t[t.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",t[t.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",t[t.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",t[t.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",t[t.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",t[t.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",t[t.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",t[t.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"}(I||(I={}));const v=6;new j(y);class L{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,s){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new P,this._objectCount=0,s&&(void 0!==s.maximumObjectsPerNode&&(this._maximumObjectsPerNode=s.maximumObjectsPerNode),void 0!==s.maximumDepth&&(this._maximumDepth=s.maximumDepth))}destroy(){this._degenerateObjects.clear(),P.clearPool(),K[0]=null,$.prune(),rt.prune()}add(t,s=t.length){this._objectCount+=s,this._grow(t,s);const i=P.acquire();for(let n=0;n<s;n++){const s=t[n];this._isDegenerate(s)?this._degenerateObjects.add(s):(i.init(this._root),this._add(s,i))}P.release(i)}remove(t,s=null){this._objectCount-=t.length;const i=P.acquire();for(const n of t){const t=null!=s?s:O(this.objectToBoundingSphere(n),tt);V(t[3])?(i.init(this._root),this._remove(n,t,i)):this._degenerateObjects.delete(n)}P.release(i),this._shrink()}update(t,s){if(!V(s[3])&&this._isDegenerate(t))return;const i=Q(t);this.remove(i,s),this.add(i)}forEachAlongRay(t,s,i){const n=M(t,s);this._forEachNode(this._root,(t=>{if(!this._intersectsNode(n,t))return!1;const s=t.node;return s.terminals.forAll((t=>{this._intersectsObject(n,t)&&i(t)})),null!==s.residents&&s.residents.forAll((t=>{this._intersectsObject(n,t)&&i(t)})),!0}))}forEachAlongRayWithVerticalOffset(t,s,i,n){const e=M(t,s);this._forEachNode(this._root,(t=>{if(!this._intersectsNodeWithOffset(e,t,n))return!1;const s=t.node;return s.terminals.forAll((t=>{this._intersectsObjectWithOffset(e,t,n)&&i(t)})),null!==s.residents&&s.residents.forAll((t=>{this._intersectsObjectWithOffset(e,t,n)&&i(t)})),!0}))}forEach(t){this._forEachNode(this._root,(s=>{const i=s.node;return i.terminals.forAll(t),null!==i.residents&&i.residents.forAll(t),!0})),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,s,e,r=(()=>!0),o=1/0){let h=1/0,c=1/0,u=null;const a=z(t,s),l=i=>{if(--o,!r(i))return;const n=this.objectToBoundingSphere(i);if(!F(e,n))return;const a=G(t,s,g(n)),l=a-n[3],f=a+n[3];l<h&&(h=l,c=f,u=i)};return this._forEachNodeDepthOrdered(this._root,(r=>{if(o<=0||!F(e,r.bounds))return!1;i(X,a,r.halfSize),n(X,X,r.bounds);if(G(t,s,X)>c)return!1;const h=r.node;return h.terminals.forAll((t=>l(t))),null!==h.residents&&h.residents.forAll((t=>l(t))),!0}),t,s),u}forEachInDepthRange(t,s,e,r,o,h,c){let u=-1/0,a=1/0;const l={setRange:t=>{e===L.DepthOrder.FRONT_TO_BACK?(u=Math.max(u,t.near),a=Math.min(a,t.far)):(u=Math.max(u,-t.far),a=Math.min(a,-t.near))}};l.setRange(r);const f=G(s,e,t),d=z(s,e),m=z(s,-e),p=t=>{if(!c(t))return;const i=this.objectToBoundingSphere(t),n=g(i),r=G(s,e,n)-f,d=r-i[3],m=r+i[3];d>a||m<u||!F(h,i)||o(t,l)};this._forEachNodeDepthOrdered(this._root,(t=>{if(!F(h,t.bounds))return!1;i(X,d,t.halfSize),n(X,X,t.bounds);if(G(s,e,X)-f>a)return!1;i(X,m,t.halfSize),n(X,X,t.bounds);if(G(s,e,X)-f<u)return!1;const r=t.node;return r.terminals.forAll((t=>p(t))),null!==r.residents&&r.residents.forAll((t=>p(t))),!0}),s,e)}forEachNode(t){this._forEachNode(this._root,(s=>t(s.node,s.bounds,s.halfSize,s.depth)))}forEachNeighbor(t,s){const i=E(s),n=g(s),r=s=>{const r=this.objectToBoundingSphere(s),o=E(r),h=i+o;return!(e(g(r),n)-h*h<=0)||t(s)};let o=!0;const h=t=>{o&&(o=r(t))};this._forEachNode(this._root,(t=>{const s=E(t.bounds),r=i+s;if(e(g(t.bounds),n)-r*r>0)return!1;const c=t.node;return c.terminals.forAll(h),o&&null!==c.residents&&c.residents.forAll(h),o})),o&&this.forEachDegenerateObject(h)}_intersectsNode(t,s){return B(s.bounds,2*-s.halfSize,Y),B(s.bounds,2*s.halfSize,Z),x(t.origin,t.direction,Y,Z)}_intersectsNodeWithOffset(t,s,i){return B(s.bounds,2*-s.halfSize,Y),B(s.bounds,2*s.halfSize,Z),i.applyToMinMax(Y,Z),x(t.origin,t.direction,Y,Z)}_intersectsObject(t,s){const i=this.objectToBoundingSphere(s);return!(i[3]>0)||N(i,t)}_intersectsObjectWithOffset(t,s,i){const n=this.objectToBoundingSphere(s);return!(n[3]>0)||N(i.applyToBoundingSphere(n),t)}_forEachNode(t,s){let i=P.acquire().init(t);const n=[i];for(;0!==n.length;){if(i=n.pop(),s(i)&&!i.isLeaf())for(let t=0;t<i.node.children.length;t++){i.node.children[t]&&n.push(P.acquire().init(i).advance(t))}P.release(i)}}_forEachNodeDepthOrdered(t,s,i,n=L.DepthOrder.FRONT_TO_BACK){let e=P.acquire().init(t);const r=[e];for(H(i,n,ot);0!==r.length;){if(e=r.pop(),s(e)&&!e.isLeaf())for(let t=7;t>=0;--t){const s=ot[t];e.node.children[s]&&r.push(P.acquire().init(e).advance(s))}P.release(e)}}_remove(t,s,i){$.clear();const n=i.advanceTo(s,((t,s)=>{$.push(t.node),$.push(s)}))?i.node.terminals:i.node.residents;if(n.removeUnordered(t),0===n.length)for(let t=$.length-2;t>=0;t-=2){const s=$.data[t],i=$.data[t+1];if(!this._purge(s,i))break}}_nodeIsEmpty(t){if(0!==t.terminals.length)return!1;if(null!==t.residents)return 0===t.residents.length;for(let s=0;s<t.children.length;s++)if(t.children[s])return!1;return!0}_purge(t,i){return i>=0&&(t.children[i]=null),!!this._nodeIsEmpty(t)&&(null===t.residents&&(t.residents=new s({shrink:!0})),!0)}_add(t,s){s.advanceTo(this.objectToBoundingSphere(t))?s.node.terminals.push(t):(s.node.residents.push(t),s.node.residents.length>this._maximumObjectsPerNode&&s.depth<this._maximumDepth&&this._split(s))}_split(t){const s=t.node.residents;t.node.residents=null;for(let i=0;i<s.length;i++){const n=P.acquire().init(t);this._add(s.at(i),n),P.release(n)}}_grow(t,s){if(0!==s&&(D(t,s,(t=>this.objectToBoundingSphere(t)),st),V(st[3])&&!this._fitsInsideTree(st)))if(this._nodeIsEmpty(this._root.node))O(st,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const t=this._rootBoundsForRootAsSubNode(st);this._placingRootViolatesMaxDepth(t)?this._rebuildTree(st,t):this._growRootAsSubNode(t),P.release(t)}}_rebuildTree(t,s){r(it,s.bounds),it[3]=s.halfSize,D([t,it],2,(t=>t),nt);const i=P.acquire().init(this._root);this._root.initFrom(null,nt,nt[3]),this._root.increaseHalfSize(1.25),this._forEachNode(i,(t=>(this.add(t.node.terminals.data,t.node.terminals.length),null!==t.node.residents&&this.add(t.node.residents.data,t.node.residents.length),!0))),P.release(i)}_placingRootViolatesMaxDepth(t){const s=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let i=0;return this._forEachNode(this._root,(t=>(i=Math.max(i,t.depth),i+s<=this._maximumDepth))),i+s>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const s=t[3],i=t;let n=-1/0;const e=this._root.bounds,r=this._root.halfSize;for(let t=0;t<3;t++){const o=e[t]-r-(i[t]-s),h=i[t]+s-(e[t]+r),c=Math.max(0,Math.ceil(o/(2*r))),u=Math.max(0,Math.ceil(h/(2*r)))+1,a=2**Math.ceil(Math.log(c+u)*Math.LOG2E);n=Math.max(n,a),et[t].min=c,et[t].max=u}for(let t=0;t<3;t++){let s=et[t].min,i=et[t].max;const o=(n-(s+i))/2;s+=Math.ceil(o),i+=Math.floor(o);const h=e[t]-r-s*r*2;U[t]=h+(i+s)*r}const o=n*r;return U[3]=o*q,P.acquire().initFrom(null,U,o,0)}_growRootAsSubNode(t){const s=this._root.node;r(st,this._root.bounds),st[3]=this._root.halfSize,this._root.init(t),t.advanceTo(st,null,!0),t.node.children=s.children,t.node.residents=s.residents,t.node.terminals=s.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(-1===t)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let t=null;const s=this._root.node.children;let i=0,n=0;for(;n<s.length&&null==t;)i=n++,t=s[i];for(;n<s.length;)if(s[n++])return-1;return i}_isDegenerate(t){return!V(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const s=this._root.bounds,i=this._root.halfSize;return t[3]<=i&&t[0]>=s[0]-i&&t[0]<=s[0]+i&&t[1]>=s[1]-i&&t[1]<=s[1]+i&&t[2]>=s[2]-i&&t[2]<=s[2]+i}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:s,_objectCount:i}=this,n=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:s,objectCount:i,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:n}}}_nodeToJSON(t){const s=t.children.map((t=>t?this._nodeToJSON(t):null)),i=t.residents?.map((t=>this.objectToBoundingSphere(t))),n=t.terminals?.map((t=>this.objectToBoundingSphere(t)));return{children:s,residents:i,terminals:n}}static fromJSON(t){const s=new L((t=>t),{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return s._objectCount=t.objectCount,s._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),s}}class P{constructor(){this.bounds=w(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,s,i,n=this.depth){return this.node=null!=t?t:P.createEmptyNode(),null!=s&&O(s,this.bounds),this.halfSize=i,this.depth=n,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*q}advance(t){let s=this.node.children[t];s||(s=P.createEmptyNode(),this.node.children[t]=s),this.node=s,this.halfSize/=2,this.depth++;const i=W[t];return this.bounds[0]+=i[0]*this.halfSize,this.bounds[1]+=i[1]*this.halfSize,this.bounds[2]+=i[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,s,i=!1){for(;;){if(this.isTerminalFor(t))return s&&s(this,-1),!0;if(this.isLeaf()){if(!i)return s&&s(this,-1),!1;this.node.residents=null}const n=this._childIndex(t);s&&s(this,n),this.advance(n)}}isLeaf(){return null!=this.node.residents}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const s=this.bounds;return(s[0]<t[0]?1:0)+(s[1]<t[1]?2:0)+(s[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new s({shrink:!0}),residents:new s({shrink:!0})}}static acquire(){return P._pool.acquire()}static release(t){P._pool.release(t)}static clearPool(){P._pool.prune()}}function C(t,s){t[0]=Math.min(t[0],s[0]-s[3]),t[1]=Math.min(t[1],s[1]-s[3]),t[2]=Math.min(t[2],s[2]-s[3])}function k(t,s){t[0]=Math.max(t[0],s[0]+s[3]),t[1]=Math.max(t[1],s[1]+s[3]),t[2]=Math.max(t[2],s[2]+s[3])}function B(t,s,i){i[0]=t[0]+s,i[1]=t[1]+s,i[2]=t[2]+s}function D(t,s,i,n){if(1===s){const s=i(t[0]);O(s,n)}else{Y[0]=1/0,Y[1]=1/0,Y[2]=1/0,Z[0]=-1/0,Z[1]=-1/0,Z[2]=-1/0;for(let n=0;n<s;n++){const s=i(t[n]);V(s[3])&&(C(Y,s),k(Z,s))}o(n,Y,Z,.5),n[3]=Math.max(Z[0]-Y[0],Z[1]-Y[1],Z[2]-Y[2])/2}}function H(t,s,i){if(!rt.length)for(let t=0;t<8;++t)rt.push({index:0,distance:0});for(let i=0;i<8;++i){const n=W[i];rt.data[i].index=i,rt.data[i].distance=G(t,s,n)}rt.sort(((t,s)=>t.distance-s.distance));for(let t=0;t<8;++t)i[t]=rt.data[t].index}function z(t,s){let i,n=1/0;for(let e=0;e<8;++e){const r=G(t,s,J[e]);r<n&&(n=r,i=J[e])}return i}function G(t,s,i){return s*(t[0]*i[0]+t[1]*i[1]+t[2]*i[2])}function V(t){return!isNaN(t)&&t!==-1/0&&t!==1/0&&t>0}P._pool=new t(P),function(t){var s;(s=t.DepthOrder||(t.DepthOrder={}))[s.FRONT_TO_BACK=1]="FRONT_TO_BACK",s[s.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(L||(L={}));const W=[c(-1,-1,-1),c(1,-1,-1),c(-1,1,-1),c(1,1,-1),c(-1,-1,1),c(1,-1,1),c(-1,1,1),c(1,1,1)],J=[c(-1,-1,-1),c(-1,-1,1),c(-1,1,-1),c(-1,1,1),c(1,-1,-1),c(1,-1,1),c(1,1,-1),c(1,1,1)],q=Math.sqrt(3),K=[null];function Q(t){return K[0]=t,K}const U=w(),X=h(),Y=h(),Z=h(),$=new s,tt=w(),st=w(),it=w(),nt=w(),et=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],rt=new s,ot=[0,0,0,0,0,0,0,0],ht=L;const ct=1e3;function ut(t,s,i){const e=w(),r=g(e);return u(r,r,t,.5),u(r,r,s,.5),e[3]=a(r,t),n(r,r,i),e}let at=class{constructor(){this._idToComponent=new Map,this._components=new ht((t=>t.bounds)),this._edges=new ht((t=>t.bounds)),this._tmpLineSegment=p(),this._tmpP1=h(),this._tmpP2=h(),this._tmpP3=h(),this.remoteClient=null}async fetchCandidates(t,s){await Promise.resolve(),d(s),await this._ensureEdgeLocations(t,s);const i=[];return this._edges.forEachNeighbor((s=>(this._addCandidates(t,s,i),i.length<ct)),t.bounds),{result:{candidates:i}}}async _ensureEdgeLocations(t,s){const i=[];if(this._components.forEachNeighbor((t=>{if(null==t.info){const{id:s,uid:n}=t;i.push({id:s,uid:n})}return!0}),t.bounds),!i.length)return;const n={components:i},e=await this.remoteClient.invoke("fetchAllEdgeLocations",n,s??{});for(const t of e.components)this._setFetchEdgeLocations(t)}async add(t){const s=new ft(t.id,t.bounds);return this._idToComponent.set(s.id,s),this._components.add([s]),{result:{}}}async remove(t){const s=this._idToComponent.get(t.id);if(s){const t=[];this._edges.forEachNeighbor((i=>(i.component===s&&t.push(i),!0)),s.bounds),this._edges.remove(t),this._components.remove([s]),this._idToComponent.delete(s.id)}return{result:{}}}_setFetchEdgeLocations(t){const s=this._idToComponent.get(t.id);if(null==s||t.uid!==s.uid)return;const i=A.createView(t.locations),n=new Array(i.count),e=h(),r=h();for(let o=0;o<i.count;o++){i.position0.getVec(o,e),i.position1.getVec(o,r);const h=ut(e,r,t.origin),c=new dt(s,o,h);n[o]=c}this._edges.add(n);const{objectIds:o,origin:c}=t;s.info={locations:i,objectIds:o,origin:c}}_addCandidates(t,s,i){const{info:e}=s.component,{origin:r,objectIds:o}=e,h=e.locations,c=h.position0.getVec(s.index,this._tmpP1),u=h.position1.getVec(s.index,this._tmpP2);n(c,c,r),n(u,u,r);const a=o[h.componentIndex.get(s.index)];this._addEdgeCandidate(t,a,c,u,i),this._addVertexCandidate(t,a,c,i),this._addVertexCandidate(t,a,u,i)}_addEdgeCandidate(t,s,i,n,e){if(!t.returnEdge)return;const r=g(t.bounds),o=_(i,n,this._tmpLineSegment),h=b(o,r,this._tmpP3);R(t.bounds,h)&&e.push({type:"edge",objectId:s,target:m(h),distance:a(r,h),start:m(i),end:m(n)})}_addVertexCandidate(t,s,i,n){if(!t.returnVertex)return;const e=g(t.bounds);R(t.bounds,i)&&n.push({type:"vertex",objectId:s,target:m(i),distance:a(e,i)})}};at=l([f("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],at);const lt=at;class ft{constructor(t,s){this.id=t,this.bounds=s,this.info=null,this.uid=++ft.uid}}ft.uid=0;class dt{constructor(t,s,i){this.component=t,this.index=s,this.bounds=i}}export default lt;
//# sourceMappingURL=p-1cc7ac71.js.map