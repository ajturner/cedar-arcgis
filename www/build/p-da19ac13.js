import{l as t,y as e,hy as n,W as r,a8 as s,n as o,o as i,hz as a,bk as l,a5 as c,$ as u,b as h,a4 as f,U as p,dm as m,aT as d,hA as w,ec as y,ef as g,cV as v,ca as x,w as b,a6 as A,hB as j,dv as M,s as T,aq as F,aN as S,aw as P,hC as E,V as R,ex as C,ey as N,ed as D,e6 as O,eC as U,fG as L,er as $,ba as I,aO as _,_ as k,aP as z,b0 as V,ad as H,b7 as W,N as B,M as G,cW as J,eV as q,aU as K}from"./p-b54724b6.js";import{I as Z,o as Q,r as X,D as Y,O as tt,h as et,_ as nt,R as rt,E as st,j as ot,v as it,q as at,N as lt,g as ct,a as ut,x as ht,w as ft,l as pt}from"./p-3800516a.js";import{r as mt}from"./p-2b55d8a8.js";import{m as dt}from"./p-728b50df.js";import{e as wt,a as yt,t as gt,p as vt,m as xt}from"./p-4f2ece68.js";import{i as bt}from"./p-38e70926.js";import{t as At}from"./p-c736af50.js";import{e as jt}from"./p-8cdc652c.js";import{o as Mt,h as Tt,m as Ft,i as St,a as Pt}from"./p-8a927e72.js";import{a as Et}from"./p-52a9dec5.js";import{e as Rt}from"./p-de65f975.js";import{e as Ct}from"./p-cc24e5bd.js";import{c as Nt}from"./p-2563414c.js";import{e as Dt}from"./p-5abe9c67.js";var Ot;const Ut=new WeakMap;let Lt=0,$t=Ot=class extends i{constructor(t){super(t),this.wrap="repeat"}get url(){return this._get("url")||null}set url(t){this._set("url",t),t&&this._set("data",null)}get data(){return this._get("data")||null}set data(t){this._set("data",t),t&&this._set("url",null)}writeData(t,e,n,r){if(t instanceof HTMLImageElement){const s={type:"image-element",src:a(t.src,r),crossOrigin:t.crossOrigin};e[n]=s}else if(t instanceof HTMLCanvasElement){const r=t.getContext("2d").getImageData(0,0,t.width,t.height),s={type:"canvas-element",imageData:this._encodeImageData(r)};e[n]=s}else if(t instanceof HTMLVideoElement){const s={type:"video-element",src:a(t.src,r),autoplay:t.autoplay,loop:t.loop,muted:t.muted,crossOrigin:t.crossOrigin,preload:t.preload};e[n]=s}else if(t instanceof ImageData){const r={type:"image-data",imageData:this._encodeImageData(t)};e[n]=r}}readData(t){switch(t.type){case"image-element":{const e=new Image;return e.src=t.src,e.crossOrigin=t.crossOrigin,e}case"canvas-element":{const e=this._decodeImageData(t.imageData),n=document.createElement("canvas");return n.width=e.width,n.height=e.height,n.getContext("2d").putImageData(e,0,0),n}case"image-data":return this._decodeImageData(t.imageData);case"video-element":{const e=document.createElement("video");return e.src=t.src,e.crossOrigin=t.crossOrigin,e.autoplay=t.autoplay,e.loop=t.loop,e.muted=t.muted,e.preload=t.preload,e}default:return}}get transparent(){const t=this.data,e=this.url;if(t instanceof HTMLCanvasElement)return this._imageDataContainsTransparent(t.getContext("2d").getImageData(0,0,t.width,t.height));if(t instanceof ImageData)return this._imageDataContainsTransparent(t);if(e){const t=e.substr(e.length-4,4).toLowerCase(),n=e.substr(0,15).toLocaleLowerCase();if(".png"===t||"data:image/png;"===n)return!0}return!1}set transparent(t){this._overrideIfSome("transparent",t)}get contentHash(){const t="string"==typeof this.wrap?this.wrap:"object"==typeof this.wrap?`${this.wrap.horizontal}/${this.wrap.vertical}`:"",e=(e="")=>`d:${e},t:${this.transparent},w:${t}`;return null!=this.url?e(this.url):null!=this.data?this.data instanceof HTMLImageElement||this.data instanceof HTMLVideoElement?e(this.data.src):(Ut.has(this.data)||Ut.set(this.data,++Lt),e(Ut.get(this.data))):e()}get memoryUsage(){let t=0;if(t+=null!=this.url?this.url.length:0,null!=this.data){const e=this.data;"data"in e?t+=e.data.byteLength:e instanceof HTMLImageElement?t+=e.naturalWidth*e.naturalHeight*3:e instanceof HTMLCanvasElement&&(t+=e.width*e.height*3)}return t}clone(){const t={url:this.url,data:this.data,wrap:this._cloneWrap()};return new Ot(t)}cloneWithDeduplication(t){const e=t.get(this);if(e)return e;const n=this.clone();return t.set(this,n),n}_cloneWrap(){return"string"==typeof this.wrap?this.wrap:{horizontal:this.wrap.horizontal,vertical:this.wrap.vertical}}_encodeImageData(t){let e="";for(let n=0;n<t.data.length;n++)e+=String.fromCharCode(t.data[n]);return{data:btoa(e),width:t.width,height:t.height}}_decodeImageData(t){const e=atob(t.data),n=new Uint8ClampedArray(e.length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t);return mt(n,t.width,t.height)}_imageDataContainsTransparent(t){for(let e=3;e<t.data.length;e+=4)if(255!==t.data[e])return!0;return!1}static from(t){return"string"==typeof t?new Ot({url:t}):t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageData||t instanceof HTMLVideoElement?new Ot({data:t}):l(Ot,t)}};t([e({type:String,json:{write:n}})],$t.prototype,"url",null),t([e({json:{write:{overridePolicy(){return{enabled:!this.url}}}}}),e()],$t.prototype,"data",null),t([r("data")],$t.prototype,"writeData",null),t([s("data")],$t.prototype,"readData",null),t([e({type:Boolean,json:{write:{overridePolicy(){return{enabled:this._isOverridden("transparent")}}}}})],$t.prototype,"transparent",null),t([e({json:{write:!0}})],$t.prototype,"wrap",void 0),t([e({readOnly:!0})],$t.prototype,"contentHash",null),$t=Ot=t([o("esri.geometry.support.MeshTexture")],$t);const It=$t;let _t=class extends(c(i)){constructor(t){super(t),this.offset=[0,0],this.rotation=0,this.scale=[1,1]}};t([e({type:[Number],nonNullable:!0,json:{write:!0}})],_t.prototype,"offset",void 0),t([e({type:Number,nonNullable:!0,json:{write:!0}})],_t.prototype,"rotation",void 0),t([e({type:[Number],nonNullable:!0,json:{write:!0}})],_t.prototype,"scale",void 0),_t=t([o("esri.geometry.support.MeshTextureTransform")],_t);const kt=_t;var zt;let Vt=zt=class extends i{constructor(t){super(t),this.color=null,this.colorTexture=null,this.colorTextureTransform=null,this.normalTexture=void 0,this.normalTextureTransform=void 0,this.alphaMode="auto",this.alphaCutoff=.5,this.doubleSided=!0}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=null!=t?t.get(this):null;if(n)return n;const r=new zt(this.clonePropertiesWithDeduplication(e));return null!=t&&t.set(this,r),r}clonePropertiesWithDeduplication(t){return{color:null!=this.color?this.color.clone():null,colorTexture:this.colorTexture?.cloneWithDeduplication(t),normalTexture:this.normalTexture?.cloneWithDeduplication(t),alphaMode:this.alphaMode,alphaCutoff:this.alphaCutoff,doubleSided:this.doubleSided,colorTextureTransform:this.colorTextureTransform?.clone(),normalTextureTransform:this.normalTextureTransform?.clone()}}get memoryUsage(){return this.getMemoryUsage()}getMemoryUsage(){let t=0;return t+=null!=this.color?16:0,null!=this.colorTexture&&(t+=this.colorTexture.memoryUsage),t+=null!=this.colorTextureTransform?20:0,null!=this.normalTexture&&(t+=this.normalTexture.memoryUsage),t+=null!=this.normalTextureTransform?20:0,t}};t([e({type:u,json:{write:!0}})],Vt.prototype,"color",void 0),t([e({type:It,json:{write:!0}})],Vt.prototype,"colorTexture",void 0),t([e({type:kt,json:{write:!0}})],Vt.prototype,"colorTextureTransform",void 0),t([e({type:It,json:{write:!0}})],Vt.prototype,"normalTexture",void 0),t([e({type:kt,json:{write:!0}})],Vt.prototype,"normalTextureTransform",void 0),t([e({nonNullable:!0,json:{write:!0}})],Vt.prototype,"alphaMode",void 0),t([e({nonNullable:!0,json:{write:!0}})],Vt.prototype,"alphaCutoff",void 0),t([e({nonNullable:!0,json:{write:!0}})],Vt.prototype,"doubleSided",void 0),Vt=zt=t([o("esri.geometry.support.MeshMaterial")],Vt);const Ht=Vt;var Wt;let Bt=Wt=class extends Ht{constructor(t){super(t),this.emissiveColor=null,this.emissiveTexture=null,this.emissiveTextureTransform=void 0,this.occlusionTexture=null,this.occlusionTextureTransform=void 0,this.metallic=1,this.roughness=1,this.metallicRoughnessTexture=null,this.metallicRoughnessTextureTransform=void 0}clone(){return this.cloneWithDeduplication(null,new Map)}cloneWithDeduplication(t,e){const n=null!=t?t.get(this):null;if(n)return n;const r=new Wt(this.clonePropertiesWithDeduplication(e));return null!=t&&t.set(this,r),r}getMemoryUsage(){let t=super.getMemoryUsage();return t+=null!=this.emissiveColor?16:0,null!=this.emissiveTexture&&(t+=this.emissiveTexture.memoryUsage),t+=null!=this.emissiveTextureTransform?20:0,null!=this.occlusionTexture&&(t+=this.occlusionTexture.memoryUsage),t+=null!=this.occlusionTextureTransform?20:0,null!=this.metallicRoughnessTexture&&(t+=this.metallicRoughnessTexture.memoryUsage),t+=null!=this.metallicRoughnessTextureTransform?20:0,t}clonePropertiesWithDeduplication(t){return{...super.clonePropertiesWithDeduplication(t),emissiveColor:this.emissiveColor?.clone(),emissiveTexture:this.emissiveTexture?.cloneWithDeduplication(t),emissiveTextureTransform:this.emissiveTextureTransform?.clone(),occlusionTexture:this.occlusionTexture?.cloneWithDeduplication(t),occlusionTextureTransform:this.occlusionTextureTransform?.clone(),metallic:this.metallic,roughness:this.roughness,metallicRoughnessTexture:this.metallicRoughnessTexture?.cloneWithDeduplication(t),metallicRoughnessTextureTransform:this.metallicRoughnessTextureTransform?.clone()}}};t([e({type:u,json:{write:!0}})],Bt.prototype,"emissiveColor",void 0),t([e({type:It,json:{write:!0}})],Bt.prototype,"emissiveTexture",void 0),t([e({type:kt,json:{write:!0}})],Bt.prototype,"emissiveTextureTransform",void 0),t([e({type:It,json:{write:!0}})],Bt.prototype,"occlusionTexture",void 0),t([e({type:kt,json:{write:!0}})],Bt.prototype,"occlusionTextureTransform",void 0),t([e({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],Bt.prototype,"metallic",void 0),t([e({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],Bt.prototype,"roughness",void 0),t([e({type:It,json:{write:!0}})],Bt.prototype,"metallicRoughnessTexture",void 0),t([e({type:kt,json:{write:!0}})],Bt.prototype,"metallicRoughnessTextureTransform",void 0),Bt=Wt=t([o("esri.geometry.support.MeshMaterialMetallicRoughness")],Bt);const Gt=Bt;var Jt;const qt="esri.geometry.support.MeshVertexAttributes",Kt=h.getLogger(qt);let Zt=Jt=class extends i{constructor(t){super(t),this.color=null,this.position=new Float64Array(0),this.uv=null,this.normal=null,this.tangent=null}castColor(t){return Xt(t,Uint8Array,[Uint8ClampedArray],{loggerTag:".color=",stride:4},Kt)}castPosition(t){t&&t instanceof Float32Array&&Kt.warn(".position=","Setting position attribute from a Float32Array may cause precision problems. Consider storing data in a Float64Array or a regular number array");return Xt(t,Float64Array,[Float32Array],{loggerTag:".position=",stride:3},Kt)}castUv(t){return Xt(t,Float32Array,[Float64Array],{loggerTag:".uv=",stride:2},Kt)}castNormal(t){return Xt(t,Float32Array,[Float64Array],{loggerTag:".normal=",stride:3},Kt)}castTangent(t){return Xt(t,Float32Array,[Float64Array],{loggerTag:".tangent=",stride:4},Kt)}clone(){const t={position:p(this.position),uv:p(this.uv),normal:p(this.normal),tangent:p(this.tangent),color:p(this.color)};return new Jt(t)}clonePositional(){const t={position:p(this.position),normal:p(this.normal),tangent:p(this.tangent),uv:this.uv,color:this.color};return new Jt(t)}get memoryUsage(){let t=0;return t+=this.position.byteLength,null!=this.uv&&(t+=this.uv.byteLength),null!=this.normal&&(t+=this.normal.byteLength),null!=this.tangent&&(t+=this.tangent.byteLength),null!=this.color&&(t+=this.color.byteLength),t}};function Qt(t,e,n,r){const{loggerTag:s,stride:o}=e;return t.length%o!=0?(r.error(s,`Invalid array length, expected a multiple of ${o}`),new n([])):t}function Xt(t,e,n,r,s){if(!t)return t;if(t instanceof e)return Qt(t,r,e,s);for(const o of n)if(t instanceof o)return Qt(new e(t),r,e,s);if(Array.isArray(t))return Qt(new e(t),r,e,s);{const r=n.map((t=>`'${t.name}'`));return s.error(`Failed to set property, expected one of ${r}, but got ${t.constructor.name}`),new e([])}}function Yt(t,e,n){e[n]=te(t)}function te(t){const e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=t[n];return e}t([e({json:{write:Yt}})],Zt.prototype,"color",void 0),t([f("color")],Zt.prototype,"castColor",null),t([e({nonNullable:!0,json:{write:Yt}})],Zt.prototype,"position",void 0),t([f("position")],Zt.prototype,"castPosition",null),t([e({json:{write:Yt}})],Zt.prototype,"uv",void 0),t([f("uv")],Zt.prototype,"castUv",null),t([e({json:{write:Yt}})],Zt.prototype,"normal",void 0),t([f("normal")],Zt.prototype,"castNormal",null),t([e({json:{write:Yt}})],Zt.prototype,"tangent",void 0),t([f("tangent")],Zt.prototype,"castTangent",null),Zt=Jt=t([o(qt)],Zt);var ee;const ne="esri.geometry.support.MeshComponent",re=h.getLogger(ne);let se=ee=class extends i{static from(t){return l(ee,t)}constructor(t){super(t),this.faces=null,this.material=null,this.shading="source",this.trustSourceNormals=!1}castFaces(t){return Xt(t,Uint32Array,[Uint16Array],{loggerTag:".faces=",stride:3},re)}castMaterial(t){return l(t&&"object"==typeof t&&("metallic"in t||"roughness"in t||"metallicRoughnessTexture"in t)?Gt:Ht,t)}clone(){return new ee({faces:p(this.faces),shading:this.shading,material:p(this.material),trustSourceNormals:this.trustSourceNormals})}cloneWithDeduplication(t,e){const n={faces:p(this.faces),shading:this.shading,material:this.material?this.material.cloneWithDeduplication(t,e):null,trustSourceNormals:this.trustSourceNormals};return new ee(n)}get memoryUsage(){let t=0;return null!=this.faces&&(t+=this.faces.byteLength),null!=this.material&&(t+=this.material.memoryUsage),t}};t([e({json:{write:!0}})],se.prototype,"faces",void 0),t([f("faces")],se.prototype,"castFaces",null),t([e({type:Ht,json:{write:!0}})],se.prototype,"material",void 0),t([f("material")],se.prototype,"castMaterial",null),t([e({type:String,json:{write:!0}})],se.prototype,"shading",void 0),t([e({type:Boolean})],se.prototype,"trustSourceNormals",void 0),se=ee=t([o(ne)],se);const oe=se;function ie(t){const e=le(t.rings,t.hasZ,he.CCW_IS_HOLE),n=new Array;let r=0,s=0;for(const t of e.polygons){const o=t.count,i=t.index,a=yt(e.position,3*i,3*o),l=t.holeIndices.map((t=>t-i)),c=At(bt(a,l,3));n.push({position:a,faces:c}),r+=a.length,s+=c.length}const o=ae(n,r,s),i=Array.isArray(o.position)?jt(o.position,3,{originalIndices:o.faces}):jt(o.position.buffer,6,{originalIndices:o.faces});return o.position=wt(new Float64Array(i.buffer)),o.faces=i.indices,o}function ae(t,e,n){if(1===t.length)return t[0];const r=gt(e),s=new Array(n);let o=0,i=0,a=0;for(const e of t){for(let t=0;t<e.position.length;t++)r[o++]=e.position[t];for(const t of e.faces)s[i++]=t+a;a=o/3}return{position:r,faces:At(s)}}function le(t,e,n){const r=t.length,s=new Array(r),o=new Array(r),i=new Array(r);let a=0,l=0,c=0,u=0;for(let e=0;e<r;++e)u+=t[e].length;const h=gt(3*u);let f=0;for(let u=r-1;u>=0;u--){const p=t[u],m=n===he.CCW_IS_HOLE&&ue(p);if(m&&1!==r)s[a++]=p;else{let t=p.length;for(let e=0;e<a;++e)t+=s[e].length;const n={index:f,pathLengths:new Array(a+1),count:t,holeIndices:new Array(a)};n.pathLengths[0]=p.length,p.length>0&&(i[c++]={index:f,count:p.length}),f=m?ce(p,p.length-1,-1,h,f,p.length,e):ce(p,0,1,h,f,p.length,e);for(let t=0;t<a;++t){const r=s[t];n.holeIndices[t]=f,n.pathLengths[t+1]=r.length,r.length>0&&(i[c++]={index:f,count:r.length}),f=ce(r,0,1,h,f,r.length,e)}a=0,n.count>0&&(o[l++]=n)}}for(let t=0;t<a;++t){const n=s[t];n.length>0&&(i[c++]={index:f,count:n.length}),f=ce(n,0,1,h,f,n.length,e)}return o.length=l,i.length=c,{position:h,polygons:o,outlines:i}}function ce(t,e,n,r,s,o,i){s*=3;for(let a=0;a<o;++a){const o=t[e];r[s++]=o[0],r[s++]=o[1],r[s++]=i?o[2]:0,e+=n}return s/3}function ue(t){return!m(t,!1,!1)}var he;!function(t){t[t.NONE=0]="NONE",t[t.CCW_IS_HOLE=1]="CCW_IS_HOLE"}(he||(he={}));function fe({xmin:t,xmax:e,ymin:n,ymax:r,zmin:s,zmax:o},i,a,l){s??=0,o??=0,pe??=new Float64Array(24);const c=pe;return c[0]=t,c[1]=n,c[2]=s,c[3]=t,c[4]=r,c[5]=s,c[6]=e,c[7]=r,c[8]=s,c[9]=e,c[10]=n,c[11]=s,c[12]=t,c[13]=n,c[14]=o,c[15]=t,c[16]=r,c[17]=o,c[18]=e,c[19]=r,c[20]=o,c[21]=e,c[22]=n,c[23]=o,Z({positions:c,transform:i,vertexSpace:a,inSpatialReference:l,outSpatialReference:l,outPositions:c,local:!1}),me(c,l)}let pe=null;function me(t,e){let n=1/0,r=1/0,s=1/0,o=-1/0,i=-1/0,a=-1/0;const l=t.length;let c=0;for(;c<l;){const e=t[c++],l=t[c++],u=t[c++];n=Math.min(n,e),r=Math.min(r,l),s=Math.min(s,u),o=Math.max(o,e),i=Math.max(i,l),a=Math.max(a,u)}return new d({xmin:n,ymin:r,zmin:s,xmax:o,ymax:i,zmax:a,spatialReference:e})}const de="esri.geometry.support.meshUtils.centerAt";function we(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const{vertexSpace:r}=t,s=n?.origin??t.origin;if(r.isRelative)Q(r,de,n),ye(t,e,s);else{X(t.spatialReference,n)?ge(t,e,s):ve(t,e,s)}}function ye(t,e,n){const{vertexSpace:r}=t;if(!r.isRelative)return;const s=Ae,o=be;if(!w(e,o,t.spatialReference))return void h.getLogger(de).error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`);if(!w(n,s,t.spatialReference)){const e=t.origin;s[0]=e.x,s[1]=e.y,s[2]=e.z,h.getLogger(de).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}const i=y(je,o,s),a=r.origin;r.origin=g(v(),a,i)}function ge(t,e,n){const r=Y(t.vertexAttributes,n,{geographic:!0}),{position:s,normal:o,tangent:i}=tt(r,e,{geographic:!0});t.vertexAttributes.position=s,t.vertexAttributes.normal=o,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}function ve(t,e,n){const r=Ae,s=be;if(w(e,s,t.spatialReference)){if(!w(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,h.getLogger(de).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}xe(t.vertexAttributes.position,s,r),t.vertexAttributesChanged()}else h.getLogger(de).error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}function xe(t,e,n){if(t)for(let r=0;r<t.length;r+=3)for(let s=0;s<3;s++)t[r+s]+=e[s]-n[s]}const be=v(),Ae=v(),je=v();async function Me(t,e,n){const{source:r}=e,{loadGLTFMesh:s}=await x(import("./p-6b0fd432.js"),n),o=await Fe(r,n);b(n);const i=s(new A({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:Te(o),useTransform:!0,signal:n?.signal});i.then((()=>o.dispose()),(()=>o.dispose()));const{vertexAttributes:a,components:l}=await i;t.vertexAttributes=a,t.components=l}function Te(t){const e=M(t.url);return n=>{const r=j(n,e,e),s=r?r.replace(/^ *\.\//,""):null;return(s?t.files.get(s):null)??n}}async function Fe(t,e){if(Array.isArray(t)){if(!t.length)throw new T("mesh-load-external:missing-assets","There must be at least one file to load");return t[0]instanceof File?Ee(t):Re(t,e)}return Pe(t)}async function Se(t,e){const{parts:n}=t;if(1===n.length)return new Oe(n[0].partUrl);const r=await t.toBlob(e);return b(e),Oe.fromBlob(r)}function Pe(t){return Oe.fromBlob(t)}function Ee(t){return De(t.map((t=>({name:t.name,mimeType:t.type,source:Pe(t)}))))}async function Re(t,e){const n=await F(t.map((async t=>{const n=await Se(t);return b(e),{name:t.assetName,mimeType:t.assetMimeType,source:n}})));if(S(e))throw n.forEach((t=>t.source.dispose())),P();return De(n)}const Ce=/^(model\/gltf\+json)|(model\/gltf-binary)$/,Ne=/\.(gltf|glb)/i;function De(t){const e=new Map;let n=null;for(const{name:r,mimeType:s,source:o}of t)(null==n||Ce.test(s)||Ne.test(r))&&(n=o.url),e.set(r,o.url),o.files.forEach(((t,n)=>e.set(n,t)));if(null==n)throw new T("mesh-load-external:missing-files","Missing files to load external mesh source");return new Oe(n,(()=>t.forEach((({source:t})=>t.dispose()))),e)}class Oe{constructor(t,e=(()=>{}),n=new Map){this.url=t,this.dispose=e,this.files=n}static fromBlob(t){const e=URL.createObjectURL(t);return new Oe(e,(()=>URL.revokeObjectURL(e)))}}let Ue=class extends E{constructor(){super(),this.externalSources=new R,this._explicitDisplaySource=null}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(t){if(null!=t&&!Mt(t))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=t,t&&this.externalSources.every((e=>!Tt(e,t)))&&this.externalSources.add(t)}clearSources(){this.displaySource=null,this.externalSources.removeAll()}getExternalSourcesOnService(t){return this.externalSources.items.filter((e=>Ft(e,t)))}get _implicitDisplaySource(){return this.externalSources.find(Mt)}};t([e()],Ue.prototype,"externalSources",void 0),t([e()],Ue.prototype,"displaySource",null),t([e()],Ue.prototype,"_implicitDisplaySource",null),t([e()],Ue.prototype,"_explicitDisplaySource",void 0),Ue=t([o("esri.geometry.support.meshUtils.Metadata")],Ue);const Le="esri.geometry.support.meshUtils.offset";function $e(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const{vertexSpace:r}=t;if(r.isRelative)Q(r,Le,n),Ie(r,e);else{X(t.spatialReference,n)?_e(t,e):ke(t,e)}}function Ie(t,e){const n=t.origin;t.origin=g(v(),n,e)}function _e(t,e){const n=t.spatialReference,r=t.vertexAttributes.position,s=t.vertexAttributes.normal,o=t.vertexAttributes.tangent,i=new Float64Array(r.length),a=null!=s?new Float32Array(s.length):null,l=null!=o?new Float32Array(o.length):null,c=t.extent.center,u=Ve;C(n,[c.x,c.y,c.z],He,Nt(n)),Et(We,He),N(u,e,We),et(r,n,i),null!=s&&null!=a&&nt(s,r,i,n,a),null!=o&&null!=l&&rt(o,r,i,n,l),ze(i,u),st(i,r,n),null!=s&&null!=a&&ot(a,r,i,n,s),null!=o&&null!=l&&it(l,r,i,n,o),t.vertexAttributesChanged()}function ke(t,e){ze(t.vertexAttributes.position,e),t.vertexAttributesChanged()}function ze(t,e){if(t)for(let n=0;n<t.length;n+=3)for(let r=0;r<3;r++)t[n+r]+=e[r]}const Ve=v(),He=Ct(),We=Rt();function Be(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=sn,r=4*t.length,s=new Float64Array(3*r),o=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let l=0,c=0,u=0,h=0;for(let r=0;r<t.length;r++){const f=t[r],p=l/3;for(const t of e)a[h++]=p+t;const m=f.corners;for(let t=0;t<4;t++){const e=m[t];let r=0;i[u++]=.25*n[t][0]+f.uvOrigin[0],i[u++]=f.uvOrigin[1]-.25*n[t][1];for(let t=0;t<3;t++)0!==f.axis[t]?(s[l++]=.5*f.axis[t],o[c++]=f.axis[t]):(s[l++]=.5*e[r++],o[c++]=0)}}return{position:s,normal:o,uv:i,faces:a}}function Ge(t,e){const n=t.components[0],r=n.faces,s=on[e],o=6*s,i=new Array(6),a=new Array(r.length-6);let l=0,c=0;for(let t=0;t<r.length;t++)t>=o&&t<o+6?i[l++]=r[t]:a[c++]=r[t];if(null!=t.vertexAttributes.uv){const e=new Float32Array(t.vertexAttributes.uv),n=4*s*2,r=[0,1,1,1,1,0,0,0];for(let t=0;t<r.length;t++)e[n+t]=r[t];t.vertexAttributes.uv=e}return t.components=[new oe({faces:i,material:n.material}),new oe({faces:a})],t}function Je(t=0){const e=Math.round(8*2**t),n=2*e,r=(e-1)*(n+1)+2*n,s=new Float64Array(3*r),o=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(3*((e-1)*n*2));let l=0,c=0,u=0,h=0;for(let t=0;t<=e;t++){const r=t/e*Math.PI+.5*Math.PI,f=Math.cos(r),p=Math.sin(r);an[2]=p;const m=0===t||t===e,d=m?n-1:n;for(let r=0;r<=d;r++){const p=r/d*2*Math.PI;an[0]=-Math.sin(p)*f,an[1]=Math.cos(p)*f;for(let t=0;t<3;t++)s[l]=.5*an[t],o[l]=an[t],++l;i[c++]=(r+(m?.5:0))/n,i[c++]=t/e,0!==t&&r!==n&&(t!==e&&(a[u++]=h,a[u++]=h+1,a[u++]=h-n),1!==t&&(a[u++]=h,a[u++]=h-n,a[u++]=h-n-1)),h++}}return{position:s,normal:o,uv:i,faces:a}}function qe(t=0){const e=5,n=Math.round(16*2**t),r=(e-1)*(n+1)+2*n,s=new Float64Array(3*r),o=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(3*(4*n));let l=0,c=0,u=0,h=0,f=0;for(let t=0;t<=e;t++){const r=0===t||t===e,p=t<=1||t>=e-1,m=2===t||4===t,d=r?n-1:n;for(let w=0;w<=d;w++){const y=w/d*2*Math.PI,g=r?0:.5;an[0]=g*Math.sin(y),an[1]=g*-Math.cos(y),an[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)s[l++]=an[e],o[c++]=p?2===e?t<=1?1:-1:0:2===e?0:an[e]/g;i[u++]=(w+(r?.5:0))/n,i[u++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,m||0===t||w===n||(t!==e&&(a[h++]=f,a[h++]=f+1,a[h++]=f-n),1!==t&&(a[h++]=f,a[h++]=f-n,a[h++]=f-n-1)),f++}}return{position:s,normal:o,uv:i,faces:a}}function Ke(t,e){const n="number"==typeof e?e:null!=e?e.width:1,r="number"==typeof e?e:null!=e?e.height:1;switch(t){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}function Ze(t){const e=tn.facingAxisOrderSwap[t],n=tn.position,r=tn.normal,s=new Float64Array(n.length),o=new Float32Array(r.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const l=e[a],c=Math.abs(l)-1,u=l>=0?1:-1;s[i]=n[t+c]*u,o[i]=r[t+c]*u,i++}}return{position:s,normal:o,uv:new Float32Array(tn.uv),faces:new Uint32Array(tn.faces),isPlane:!0}}const Qe=1,Xe=2,Ye=3,tn={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[Ye,Qe,Xe],west:[-Ye,-Qe,Xe],north:[-Qe,Ye,Xe],south:[Qe,-Ye,Xe],up:[Qe,Xe,Ye],down:[Qe,-Xe,-Ye]}};function en(t,e,n){t.isPlane||nn(t),rn(t,n?.size);const{vertexAttributes:r,vertexSpace:s,transform:o}=at(t,e,n);return{vertexAttributes:new Zt({...r,uv:t.uv}),vertexSpace:s,transform:o,components:[new oe({faces:t.faces,material:n&&n.material||null})],spatialReference:e.spatialReference}}function nn(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}function rn(t,e){if(null==e)return;const n="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];ln[0]=n[0],ln[4]=n[1],ln[8]=n[2];for(let e=0;e<t.position.length;e+=3){for(let n=0;n<3;n++)an[n]=t.position[e+n];N(an,an,ln);for(let n=0;n<3;n++)t.position[e+n]=an[n]}if(n[0]!==n[1]||n[1]!==n[2]){ln[0]=1/n[0],ln[4]=1/n[1],ln[8]=1/n[2];for(let e=0;e<t.normal.length;e+=3){for(let n=0;n<3;n++)an[n]=t.normal[e+n];N(an,an,ln),D(an,an);for(let n=0;n<3;n++)t.normal[e+n]=an[n]}}}const sn={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},on={south:0,east:1,north:2,west:3,up:4,down:5},an=v(),ln=Rt();const cn="esri.geometry.support.meshUtils.rotate";function un(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const{spatialReference:r,vertexSpace:s}=t;if(s.isRelative){Q(s,cn,n);const r=n?.origin??t.origin;t.transform??=new lt,hn(t.transform,s,e,r)}else{const s=n?.origin??t.origin;X(r,n)?fn(t,e,s):pn(t,e,s)}}function hn(t,e,n,r){const s=e.origin,o=O(dn,r.x,r.y,r.z??0),i=y(dn,o,s);t.applyLocalInverse(i,wn),t.rotation=ct(t.rotation,n,ut()),t.applyLocalInverse(i,i),y(i,i,wn),t.translation=g(v(),t.translation,i)}function fn(t,e,n){const r=t.spatialReference,s=Nt(r),o=xn;w(n,o,s)||w(t.origin,o,s);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,h=null!=l?new Float32Array(l.length):null;C(s,o,gn,s),Et(vn,gn);const f=yn;N(ht(yn),ht(e),vn),f[3]=e[3],et(i,r,c),null!=a&&null!=u&&nt(a,i,c,r,u),null!=l&&null!=h&&rt(l,i,c,r,h),mn(c,f,3,o),st(c,i,r),null!=a&&null!=u&&(mn(u,f,3),ot(u,i,c,r,a)),null!=l&&null!=h&&(mn(h,f,4),it(h,i,c,r,l)),t.vertexAttributesChanged()}function pn(t,e,n){const r=xn;if(!w(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,h.getLogger(cn).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}mn(t.vertexAttributes.position,e,3,r),mn(t.vertexAttributes.normal,e,3),mn(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}function mn(t,e,n,r=U){if(null!=t){L(gn,ft(e),ht(e));for(let e=0;e<t.length;e+=n){for(let n=0;n<3;n++)dn[n]=t[e+n]-r[n];$(dn,dn,gn);for(let n=0;n<3;n++)t[e+n]=dn[n]+r[n]}}}const dn=v(),wn=v(),yn=ut(),gn=Ct(),vn=Rt(),xn=v();const bn="esri.geometry.support.meshUtils.scale";function An(t,e,n){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const{spatialReference:r,vertexSpace:s}=t;if(s.isRelative){Q(s,bn,n);const r=n?.origin??t.origin;t.transform??=new lt,jn(t.transform,s,e,r)}else{const s=X(r,n),o=n?.origin??t.origin;s?Mn(t,e,o):Tn(t,e,o)}}function jn(t,e,n,r){const s=e.origin,o=O(Sn,r.x,r.y,r.z),i=y(Sn,o,s);t.applyLocalInverse(i,Pn);const a=I(v(),t.scale,n);t.scale=a,t.applyLocalInverse(i,i),y(i,i,Pn),t.translation=g(v(),t.translation,i)}function Mn(t,e,n){const r=t.spatialReference,s=Nt(r),o=En;w(n,o,s)||w(t.origin,o,s);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,l=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=null!=a?new Float32Array(a.length):null,h=null!=l?new Float32Array(l.length):null;et(i,r,c),null!=a&&null!=u&&nt(a,i,c,r,u),null!=l&&null!=h&&rt(l,i,c,r,h),Fn(c,e,o),st(c,i,r),null!=a&&null!=u&&ot(u,i,c,r,a),null!=l&&null!=h&&it(h,i,c,r,l),t.vertexAttributesChanged()}function Tn(t,e,n){const r=En;if(!w(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,h.getLogger(bn).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}Fn(t.vertexAttributes.position,e,r),t.vertexAttributesChanged()}function Fn(t,e,n=U){if(t)for(let r=0;r<t.length;r+=3){for(let e=0;e<3;e++)Sn[e]=t[r+e]-n[e];I(Sn,Sn,e);for(let e=0;e<3;e++)t[r+e]=Sn[e]+n[e]}}const Sn=v(),Pn=v(),En=v();var Rn;const Cn="esri.geometry.Mesh",Nn={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:vt,"georeferenced-relative":dt,local:xt}};let Dn=Rn=class extends(_(k.LoadableMixin(z(V)))){constructor(t){super(t),this.components=null,this.vertexSpace=new vt,this.transform=null,this.metadata=new Ue,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new Zt,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add(H((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((t=>t.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{components:t,spatialReference:e,vertexAttributes:n,vertexSpace:r}=this,s=n.position;if(0===s.length||t&&0===t.length)return new d({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e});if("local"===r.type){const{_untransformedExtent:t,transform:n}=this;return fe(t,n,r,e)}if("georeferenced-relative"===r.type){const{transform:t}=this,n=Z({positions:s,transform:t,vertexSpace:r,inSpatialReference:e,outSpatialReference:e,local:!1});return me(n,e)}return me(s,e)}get _untransformedExtent(){return me(this.vertexAttributes.position,this.spatialReference)}get anchor(){const{vertexSpace:t}=this;if(t.isRelative)return t.getOriginPoint(this.spatialReference);const{center:e,zmin:n}=this._transformedExtent;return new A({x:e.x,y:e.y,z:n,spatialReference:this.spatialReference})}get origin(){const{vertexSpace:t}=this;return t.isRelative?t.getOriginPoint(this.spatialReference):this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(oe.from(t)),this.notifyChange("components")):h.getLogger(this).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}h.getLogger(this).error("removeComponent()","Provided component is not part of the list of components")}else h.getLogger(this).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,n,r){return pt(t,e,n,Un),un(this,Un,r),this}offset(t,e,n,r){return this.loaded?(On[0]=t,On[1]=e,On[2]=n,$e(this,On,r),this):(h.getLogger(this).error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(An(this,t,e),this):(h.getLogger(this).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(we(this,t,e),this):(h.getLogger(this).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){const{metadata:{displaySource:e}}=this;return e&&this.addResolvingPromise(Me(this,e,t)),Promise.resolve(this)}addExternalSources(t){this.metadata.externalSources.addMany(t)}updateDisplaySource(t){this.metadata.displaySource=t}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(t){let e=null;if(this.components){const t=new Map,n=new Map;e=this.components.map((e=>e.cloneWithDeduplication(t,n)))}const n={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),vertexSpace:t,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new Rn(n)}cloneShallow(){return new Rn({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const e=import("./p-665ca091.js"),n=this.load(),r=await Promise.all([e,n]),{toBinaryGLTF:s}=r[0];return s(this,t)}get memoryUsage(){let t=0;if(t+=this.vertexAttributes.memoryUsage,null!=this.components)for(const e of this.components)t+=e.memoryUsage;return t}_clearSources(){this.metadata.clearSources()}static createBox(t,e){if(!(t instanceof A))return h.getLogger(Cn).error(".createBox()","expected location to be a Point instance"),null;const n=new Rn(en(Be(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?Ge(n,e.imageFace):n}static createSphere(t,e){return t instanceof A?new Rn(en(Je(e&&e.densificationFactor||0),t,e)):(h.getLogger(Cn).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof A?new Rn(en(qe(e&&e.densificationFactor||0),t,e)):(h.getLogger(Cn).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){if(!(t instanceof A))return h.getLogger(Cn).error(".createPlane()","expected location to be a Point instance"),null;const n=e?.facing??"up",r=Ke(n,e?.size);return new Rn(en(Ze(n),t,{...e,size:r}))}static createFromPolygon(t,e){if(!(t instanceof W))return h.getLogger(Cn).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=ie(t);return new Rn({vertexAttributes:new Zt({position:n.position}),components:[new oe({faces:n.faces,shading:"flat",material:e?.material??null})],spatialReference:t.spatialReference,vertexSpace:new vt})}static async createFromGLTF(t,e,n){if(!(t instanceof A))throw h.getLogger(Cn).error(".createfromGLTF()","expected location to be a Point instance"),new T("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await x(import("./p-6b0fd432.js"),n);return new Rn(await r(t,e,n))}static async createFromFiles(t,e,n){if(!(t instanceof A)){const t="Expected location to be a Point instance";throw h.getLogger(Cn).error(".createFromFiles()",t),new T("invalid-input",t)}const r=Rn.createWithExternalSource(t,e),s=n?.layer;if(!s){const t="A layer is needed to convert the files";throw h.getLogger(Cn).error(".createFromFiles()",t),new T("invalid-input",t)}const[o]=await s.uploadAssets([r],n);return o}static createWithExternalSource(t,e,n){const r=n?.extent??null,{x:s,y:o,z:i,spatialReference:a}=t,l=n?.transform?.clone()??new lt,c=n?.vertexSpace??new xt({origin:[s,o,i??0]}),u={source:e,extent:r},h=new Ue;return h.externalSources.push(u),new Rn({metadata:h,transform:l,vertexSpace:c,spatialReference:a})}static createIncomplete(t,e){const{x:n,y:r,z:s,spatialReference:o}=t,i=e?.transform?.clone()??new lt,a=e?.vertexSpace??new xt({origin:[n,r,s??0]}),l=new Rn({transform:i,vertexSpace:a,spatialReference:o});return l.addResolvingPromise(Promise.reject(new T("mesh-incomplete","Mesh resources are not complete"))),l}};t([e({type:[oe],json:{write:!0}})],Dn.prototype,"components",void 0),t([e({nonNullable:!0,types:Nn,constructOnly:!0,json:{write:!0}})],Dn.prototype,"vertexSpace",void 0),t([e({type:lt,json:{write:!0}})],Dn.prototype,"transform",void 0),t([e({constructOnly:!0})],Dn.prototype,"metadata",void 0),t([e()],Dn.prototype,"hasExtent",null),t([e()],Dn.prototype,"_transformedExtent",null),t([e()],Dn.prototype,"_untransformedExtent",null),t([e()],Dn.prototype,"anchor",null),t([e()],Dn.prototype,"origin",null),t([e({readOnly:!0,json:{read:!1}})],Dn.prototype,"extent",null),t([e({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Dn.prototype,"hasZ",void 0),t([e({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Dn.prototype,"hasM",void 0),t([e({type:Zt,nonNullable:!0,json:{write:!0}})],Dn.prototype,"vertexAttributes",void 0),Dn=Rn=t([o(Cn)],Dn);const On=v(),Un=ut(),Ln=Dn;const $n=()=>h.getLogger("esri.rest.support.meshFeatureSet");function In(t,e,n){const r=n.features;n.features=[],delete n.geometryType;const s=B.fromJSON(n);if(s.geometryType="mesh",!n.assetMaps)return s;const o=Wn(e,n.assetMaps),i=t.sourceSpatialReference??K.WGS84,a=n.globalIdFieldName,{outFields:l}=t,c=null!=l&&l.length>0?_n(l.includes("*")?null:new Set(l)):()=>({});for(const t of r){const n=kn(t,a,i,e,o);null!=n&&s.features.push(new G({geometry:n,attributes:c(t)}))}return s}function _n(t){return({attributes:e})=>{if(!e)return{};if(!t)return e;for(const n in e)t.has(n)||delete e[n];return e}}function kn(t,e,n,r,s){const o=t.attributes[e],i=s.get(o);if(null==i)return $n().error("mesh-feature-set:asset-not-found","Service returned a feature which was not found in the asset map",t),null;if(!t.geometry)return $n().error("mesh-feature-set:no-geometry","Service returned a feature without geometry",t),null;const{originPoint:a,originVector:l}=zn(t,n,r),c=d.fromJSON(t.geometry);c.spatialReference=n;const u=Vn(t.attributes,r),h=i.projectVertices?new dt({origin:l}):new xt({origin:l}),f=Bn(i);return f?Ln.createWithExternalSource(a,f,{extent:c,transform:u,vertexSpace:h}):Ln.createIncomplete(a,{extent:c,transform:u,vertexSpace:h})}function zn({attributes:t},e,{transformFieldRoles:n}){const r=t[n.originX],s=t[n.originY],o=t[n.originZ];return{originPoint:new A({x:r,y:s,z:o,spatialReference:e}),originVector:J(r,s,o)}}function Vn(t,{transformFieldRoles:e}){return new lt({translation:[t[e.translationX],-t[e.translationZ],t[e.translationY]],rotationAxis:[t[e.rotationX],t[e.rotationZ],t[e.rotationY]],rotationAngle:t[e.rotationDeg],scale:[t[e.scaleX],t[e.scaleY],t[e.scaleZ]]})}var Hn;function Wn(t,e){const n=new Map;for(const r of e){const e=r.parentGlobalId;if(null==e)continue;const s=r.assetName,o=r.assetType,i=r.assetHash,a=r.assetURL,l=r.conversionStatus,c=r.seqNo,u=Dt(o,t.supportedFormats);if(!u){$n().error("mesh-feature-set:unknown-format",`Service returned an asset of type ${o}, but it does not list it as a supported type`);continue}const h=q(n,e,(()=>({projectVertices:Jn(r.flags).projectVertices,files:new Map})));q(h.files,s,(()=>({name:s,type:o,mimeType:u,status:Gn(l),parts:[]}))).parts[c]={hash:i,url:a}}return n}function Bn(t){const e=Array.from(t.files.values()),n=new Array;for(const t of e){if(t.status!==Hn.COMPLETED)return null;const e=new Array;for(const n of t.parts){if(!n)return null;e.push(new St(n.url,n.hash))}n.push(new Pt(t.name,t.mimeType,e))}return n}function Gn(t){switch(t){case"COMPLETED":case"SUBMITTED":return Hn.COMPLETED;case"INPROGRESS":return Hn.PENDING;default:return Hn.FAILED}}function Jn(t){return{projectVertices:t.includes("PROJECT_VERTICES")}}!function(t){t[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}(Hn||(Hn={}));const qn=Object.freeze({__proto__:null,assetMapFromAssetMapsJSON:Wn,extractMesh:kn,meshFeatureSetFromJSON:In});export{kt as a,qn as b,Gt as c,oe as g,It as m,Zt as p};
//# sourceMappingURL=p-da19ac13.js.map